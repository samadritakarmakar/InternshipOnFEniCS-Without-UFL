// This code conforms with the UFC specification version 2018.1.0
// and was automatically generated by FFC version 2018.1.0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
//
// This code was generated with the following parameters:
//

//  add_tabulate_tensor_timing:     False
//  convert_exceptions_to_warnings: False
//  cpp_optimize:                   True
//  cpp_optimize_flags:             '-O2'
//  epsilon:                        1e-14
//  error_control:                  False
//  evaluate_basis:                 False
//  external_include_dirs:          ''
//  external_includes:              ''
//  external_libraries:             ''
//  external_library_dirs:          ''
//  form_postfix:                   True
//  format:                         'dolfin'
//  generate_dummy_tabulate_tensor: False
//  max_signature_length:           0
//  optimize:                       True
//  precision:                      None
//  quadrature_degree:              None
//  quadrature_rule:                None
//  representation:                 'quadrature'
//  split:                          True

#include "Plas3D.h"

plas3d_finite_element_0::plas3d_finite_element_0() : ufc::finite_element()
{
    // Do nothing
}

plas3d_finite_element_0::~plas3d_finite_element_0()
{
    // Do nothing
}

const char * plas3d_finite_element_0::signature() const
{
    return "FiniteElement('Quadrature', tetrahedron, 3, quad_scheme='default')";
}

ufc::shape plas3d_finite_element_0::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t plas3d_finite_element_0::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_0::geometric_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_0::space_dimension() const
{
    return 5;
}

std::size_t plas3d_finite_element_0::value_rank() const
{
    return 0;
}

std::size_t plas3d_finite_element_0::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t plas3d_finite_element_0::value_size() const
{
    return 1;
}

std::size_t plas3d_finite_element_0::reference_value_rank() const
{
    return 0;
}

std::size_t plas3d_finite_element_0::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t plas3d_finite_element_0::reference_value_size() const
{
    return 1;
}

std::size_t plas3d_finite_element_0::degree() const
{
    return 3;
}

const char * plas3d_finite_element_0::family() const
{
    return "Quadrature";
}

void plas3d_finite_element_0::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_0::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis_derivatives: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_0::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    throw std::runtime_error("transform_reference_basis_derivatives: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_0::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    throw std::runtime_error("evaluate_basis: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_0::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    throw std::runtime_error("evaluate_basis_all: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_0::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives: Function not supported/implemented for QuadratureElement." << std::endl;
}

void plas3d_finite_element_0::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives_all: Function not supported/implemented for QuadratureElement." << std::endl;
}

double plas3d_finite_element_0::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
}

void plas3d_finite_element_0::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[3];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
}

void plas3d_finite_element_0::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    throw std::runtime_error("interpolate_vertex_values: Function is not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_0::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 2] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 2 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 2 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 3] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 3 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 3 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 4] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 4 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 4 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
}

void plas3d_finite_element_0::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[15] = { 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666 };
    std::copy_n(dof_X, 15, reference_dof_coordinates);
}

std::size_t plas3d_finite_element_0::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * plas3d_finite_element_0::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * plas3d_finite_element_0::create() const
{
    return new plas3d_finite_element_0();
}


plas3d_finite_element_1::plas3d_finite_element_1() : ufc::finite_element()
{
    // Do nothing
}

plas3d_finite_element_1::~plas3d_finite_element_1()
{
    // Do nothing
}

const char * plas3d_finite_element_1::signature() const
{
    return "VectorElement(FiniteElement('Quadrature', tetrahedron, 3, quad_scheme='default'), dim=6)";
}

ufc::shape plas3d_finite_element_1::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t plas3d_finite_element_1::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_1::geometric_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_1::space_dimension() const
{
    return 30;
}

std::size_t plas3d_finite_element_1::value_rank() const
{
    return 1;
}

std::size_t plas3d_finite_element_1::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 6 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t plas3d_finite_element_1::value_size() const
{
    return 6;
}

std::size_t plas3d_finite_element_1::reference_value_rank() const
{
    return 1;
}

std::size_t plas3d_finite_element_1::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 6 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t plas3d_finite_element_1::reference_value_size() const
{
    return 6;
}

std::size_t plas3d_finite_element_1::degree() const
{
    return 3;
}

const char * plas3d_finite_element_1::family() const
{
    return "Quadrature";
}

void plas3d_finite_element_1::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_1::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis_derivatives: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_1::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    throw std::runtime_error("transform_reference_basis_derivatives: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_1::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    throw std::runtime_error("evaluate_basis: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_1::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    throw std::runtime_error("evaluate_basis_all: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_1::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives: Function not supported/implemented for QuadratureElement." << std::endl;
}

void plas3d_finite_element_1::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives_all: Function not supported/implemented for QuadratureElement." << std::endl;
}

double plas3d_finite_element_1::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[6];
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 5:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 6:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 7:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 8:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 9:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 10:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 11:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 12:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 13:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 14:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 15:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 16:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 17:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 18:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 19:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 20:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 21:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 22:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 23:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 24:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 25:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 26:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 27:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 28:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 29:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    }
    return 0.0;
}

void plas3d_finite_element_1::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[6];
    // Declare variable for physical coordinates
    double y[3];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[10] = vals[2];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[11] = vals[2];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[15] = vals[3];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[16] = vals[3];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[17] = vals[3];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[18] = vals[3];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[19] = vals[3];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[20] = vals[4];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[21] = vals[4];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[22] = vals[4];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[23] = vals[4];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[24] = vals[4];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[25] = vals[5];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[26] = vals[5];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[27] = vals[5];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[28] = vals[5];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[29] = vals[5];
}

void plas3d_finite_element_1::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    throw std::runtime_error("interpolate_vertex_values: Function is not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_1::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 2] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 2 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 2 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 3] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 3 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 3 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 4] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 4 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 4 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 5] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 5 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 5 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 6] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 6 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 6 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 7] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 7 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 7 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 8] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 8 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 8 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 9] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 9 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 9 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 10] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 10 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 10 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 11] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 11 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 11 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 12] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 12 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 12 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 13] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 13 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 13 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 14] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 14 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 14 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 15] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 15 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 15 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 16] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 16 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 16 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 17] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 17 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 17 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 18] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 18 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 18 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 19] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 19 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 19 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 20] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 20 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 20 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 21] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 21 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 21 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 22] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 22 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 22 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 23] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 23 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 23 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 24] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 24 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 24 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 25] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 25 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 25 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 26] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 26 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 26 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 27] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 27 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 27 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 28] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 28 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 28 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 29] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 29 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 29 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
}

void plas3d_finite_element_1::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[90] = { 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666 };
    std::copy_n(dof_X, 90, reference_dof_coordinates);
}

std::size_t plas3d_finite_element_1::num_sub_elements() const
{
    return 6;
}

ufc::finite_element * plas3d_finite_element_1::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_0();
    case 1:
        return new plas3d_finite_element_0();
    case 2:
        return new plas3d_finite_element_0();
    case 3:
        return new plas3d_finite_element_0();
    case 4:
        return new plas3d_finite_element_0();
    case 5:
        return new plas3d_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::finite_element * plas3d_finite_element_1::create() const
{
    return new plas3d_finite_element_1();
}


plas3d_finite_element_2::plas3d_finite_element_2() : ufc::finite_element()
{
    // Do nothing
}

plas3d_finite_element_2::~plas3d_finite_element_2()
{
    // Do nothing
}

const char * plas3d_finite_element_2::signature() const
{
    return "VectorElement(FiniteElement('Quadrature', tetrahedron, 3, quad_scheme='default'), dim=36)";
}

ufc::shape plas3d_finite_element_2::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t plas3d_finite_element_2::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_2::geometric_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_2::space_dimension() const
{
    return 180;
}

std::size_t plas3d_finite_element_2::value_rank() const
{
    return 1;
}

std::size_t plas3d_finite_element_2::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 36 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t plas3d_finite_element_2::value_size() const
{
    return 36;
}

std::size_t plas3d_finite_element_2::reference_value_rank() const
{
    return 1;
}

std::size_t plas3d_finite_element_2::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 36 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t plas3d_finite_element_2::reference_value_size() const
{
    return 36;
}

std::size_t plas3d_finite_element_2::degree() const
{
    return 3;
}

const char * plas3d_finite_element_2::family() const
{
    return "Quadrature";
}

void plas3d_finite_element_2::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_2::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    throw std::runtime_error("evaluate_reference_basis_derivatives: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_2::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    throw std::runtime_error("transform_reference_basis_derivatives: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_2::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    throw std::runtime_error("evaluate_basis: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_2::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    throw std::runtime_error("evaluate_basis_all: Function not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_2::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives: Function not supported/implemented for QuadratureElement." << std::endl;
}

void plas3d_finite_element_2::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    std::cerr << "*** FFC warning: " << "evaluate_basis_derivatives_all: Function not supported/implemented for QuadratureElement." << std::endl;
}

double plas3d_finite_element_2::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[36];
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 5:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 6:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 7:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 8:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 9:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 10:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 11:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 12:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 13:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 14:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 15:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 16:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 17:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 18:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 19:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 20:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 21:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 22:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 23:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 24:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 25:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 26:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 27:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 28:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 29:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 30:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 31:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 32:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 33:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 34:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 35:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 36:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 37:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 38:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 39:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 40:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 41:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 42:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 43:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 44:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 45:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[9];
        }
        break;
    case 46:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[9];
        }
        break;
    case 47:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[9];
        }
        break;
    case 48:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[9];
        }
        break;
    case 49:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[9];
        }
        break;
    case 50:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[10];
        }
        break;
    case 51:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[10];
        }
        break;
    case 52:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[10];
        }
        break;
    case 53:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[10];
        }
        break;
    case 54:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[10];
        }
        break;
    case 55:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[11];
        }
        break;
    case 56:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[11];
        }
        break;
    case 57:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[11];
        }
        break;
    case 58:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[11];
        }
        break;
    case 59:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[11];
        }
        break;
    case 60:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[12];
        }
        break;
    case 61:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[12];
        }
        break;
    case 62:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[12];
        }
        break;
    case 63:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[12];
        }
        break;
    case 64:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[12];
        }
        break;
    case 65:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[13];
        }
        break;
    case 66:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[13];
        }
        break;
    case 67:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[13];
        }
        break;
    case 68:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[13];
        }
        break;
    case 69:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[13];
        }
        break;
    case 70:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[14];
        }
        break;
    case 71:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[14];
        }
        break;
    case 72:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[14];
        }
        break;
    case 73:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[14];
        }
        break;
    case 74:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[14];
        }
        break;
    case 75:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[15];
        }
        break;
    case 76:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[15];
        }
        break;
    case 77:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[15];
        }
        break;
    case 78:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[15];
        }
        break;
    case 79:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[15];
        }
        break;
    case 80:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[16];
        }
        break;
    case 81:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[16];
        }
        break;
    case 82:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[16];
        }
        break;
    case 83:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[16];
        }
        break;
    case 84:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[16];
        }
        break;
    case 85:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[17];
        }
        break;
    case 86:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[17];
        }
        break;
    case 87:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[17];
        }
        break;
    case 88:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[17];
        }
        break;
    case 89:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[17];
        }
        break;
    case 90:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[18];
        }
        break;
    case 91:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[18];
        }
        break;
    case 92:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[18];
        }
        break;
    case 93:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[18];
        }
        break;
    case 94:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[18];
        }
        break;
    case 95:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[19];
        }
        break;
    case 96:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[19];
        }
        break;
    case 97:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[19];
        }
        break;
    case 98:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[19];
        }
        break;
    case 99:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[19];
        }
        break;
    case 100:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[20];
        }
        break;
    case 101:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[20];
        }
        break;
    case 102:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[20];
        }
        break;
    case 103:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[20];
        }
        break;
    case 104:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[20];
        }
        break;
    case 105:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[21];
        }
        break;
    case 106:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[21];
        }
        break;
    case 107:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[21];
        }
        break;
    case 108:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[21];
        }
        break;
    case 109:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[21];
        }
        break;
    case 110:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[22];
        }
        break;
    case 111:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[22];
        }
        break;
    case 112:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[22];
        }
        break;
    case 113:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[22];
        }
        break;
    case 114:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[22];
        }
        break;
    case 115:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[23];
        }
        break;
    case 116:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[23];
        }
        break;
    case 117:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[23];
        }
        break;
    case 118:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[23];
        }
        break;
    case 119:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[23];
        }
        break;
    case 120:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[24];
        }
        break;
    case 121:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[24];
        }
        break;
    case 122:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[24];
        }
        break;
    case 123:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[24];
        }
        break;
    case 124:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[24];
        }
        break;
    case 125:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[25];
        }
        break;
    case 126:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[25];
        }
        break;
    case 127:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[25];
        }
        break;
    case 128:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[25];
        }
        break;
    case 129:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[25];
        }
        break;
    case 130:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[26];
        }
        break;
    case 131:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[26];
        }
        break;
    case 132:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[26];
        }
        break;
    case 133:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[26];
        }
        break;
    case 134:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[26];
        }
        break;
    case 135:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[27];
        }
        break;
    case 136:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[27];
        }
        break;
    case 137:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[27];
        }
        break;
    case 138:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[27];
        }
        break;
    case 139:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[27];
        }
        break;
    case 140:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[28];
        }
        break;
    case 141:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[28];
        }
        break;
    case 142:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[28];
        }
        break;
    case 143:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[28];
        }
        break;
    case 144:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[28];
        }
        break;
    case 145:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[29];
        }
        break;
    case 146:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[29];
        }
        break;
    case 147:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[29];
        }
        break;
    case 148:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[29];
        }
        break;
    case 149:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[29];
        }
        break;
    case 150:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[30];
        }
        break;
    case 151:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[30];
        }
        break;
    case 152:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[30];
        }
        break;
    case 153:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[30];
        }
        break;
    case 154:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[30];
        }
        break;
    case 155:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[31];
        }
        break;
    case 156:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[31];
        }
        break;
    case 157:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[31];
        }
        break;
    case 158:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[31];
        }
        break;
    case 159:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[31];
        }
        break;
    case 160:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[32];
        }
        break;
    case 161:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[32];
        }
        break;
    case 162:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[32];
        }
        break;
    case 163:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[32];
        }
        break;
    case 164:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[32];
        }
        break;
    case 165:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[33];
        }
        break;
    case 166:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[33];
        }
        break;
    case 167:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[33];
        }
        break;
    case 168:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[33];
        }
        break;
    case 169:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[33];
        }
        break;
    case 170:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[34];
        }
        break;
    case 171:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[34];
        }
        break;
    case 172:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[34];
        }
        break;
    case 173:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[34];
        }
        break;
    case 174:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[34];
        }
        break;
    case 175:
        {
            y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
            y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
            y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[35];
        }
        break;
    case 176:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[35];
        }
        break;
    case 177:
        {
            y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[35];
        }
        break;
    case 178:
        {
            y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[35];
        }
        break;
    case 179:
        {
            y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
            y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
            y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[35];
        }
        break;
    }
    return 0.0;
}

void plas3d_finite_element_2::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[36];
    // Declare variable for physical coordinates
    double y[3];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[10] = vals[2];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[11] = vals[2];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[15] = vals[3];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[16] = vals[3];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[17] = vals[3];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[18] = vals[3];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[19] = vals[3];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[20] = vals[4];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[21] = vals[4];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[22] = vals[4];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[23] = vals[4];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[24] = vals[4];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[25] = vals[5];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[26] = vals[5];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[27] = vals[5];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[28] = vals[5];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[29] = vals[5];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[30] = vals[6];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[31] = vals[6];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[32] = vals[6];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[33] = vals[6];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[34] = vals[6];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[35] = vals[7];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[36] = vals[7];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[37] = vals[7];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[38] = vals[7];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[39] = vals[7];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[40] = vals[8];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[41] = vals[8];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[42] = vals[8];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[43] = vals[8];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[44] = vals[8];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[45] = vals[9];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[46] = vals[9];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[47] = vals[9];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[48] = vals[9];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[49] = vals[9];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[50] = vals[10];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[51] = vals[10];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[52] = vals[10];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[53] = vals[10];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[54] = vals[10];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[55] = vals[11];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[56] = vals[11];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[57] = vals[11];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[58] = vals[11];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[59] = vals[11];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[60] = vals[12];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[61] = vals[12];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[62] = vals[12];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[63] = vals[12];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[64] = vals[12];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[65] = vals[13];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[66] = vals[13];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[67] = vals[13];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[68] = vals[13];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[69] = vals[13];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[70] = vals[14];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[71] = vals[14];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[72] = vals[14];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[73] = vals[14];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[74] = vals[14];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[75] = vals[15];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[76] = vals[15];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[77] = vals[15];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[78] = vals[15];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[79] = vals[15];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[80] = vals[16];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[81] = vals[16];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[82] = vals[16];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[83] = vals[16];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[84] = vals[16];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[85] = vals[17];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[86] = vals[17];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[87] = vals[17];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[88] = vals[17];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[89] = vals[17];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[90] = vals[18];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[91] = vals[18];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[92] = vals[18];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[93] = vals[18];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[94] = vals[18];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[95] = vals[19];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[96] = vals[19];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[97] = vals[19];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[98] = vals[19];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[99] = vals[19];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[100] = vals[20];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[101] = vals[20];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[102] = vals[20];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[103] = vals[20];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[104] = vals[20];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[105] = vals[21];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[106] = vals[21];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[107] = vals[21];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[108] = vals[21];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[109] = vals[21];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[110] = vals[22];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[111] = vals[22];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[112] = vals[22];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[113] = vals[22];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[114] = vals[22];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[115] = vals[23];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[116] = vals[23];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[117] = vals[23];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[118] = vals[23];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[119] = vals[23];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[120] = vals[24];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[121] = vals[24];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[122] = vals[24];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[123] = vals[24];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[124] = vals[24];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[125] = vals[25];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[126] = vals[25];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[127] = vals[25];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[128] = vals[25];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[129] = vals[25];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[130] = vals[26];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[131] = vals[26];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[132] = vals[26];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[133] = vals[26];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[134] = vals[26];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[135] = vals[27];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[136] = vals[27];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[137] = vals[27];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[138] = vals[27];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[139] = vals[27];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[140] = vals[28];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[141] = vals[28];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[142] = vals[28];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[143] = vals[28];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[144] = vals[28];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[145] = vals[29];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[146] = vals[29];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[147] = vals[29];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[148] = vals[29];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[149] = vals[29];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[150] = vals[30];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[151] = vals[30];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[152] = vals[30];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[153] = vals[30];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[154] = vals[30];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[155] = vals[31];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[156] = vals[31];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[157] = vals[31];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[158] = vals[31];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[159] = vals[31];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[160] = vals[32];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[161] = vals[32];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[162] = vals[32];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[163] = vals[32];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[164] = vals[32];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[165] = vals[33];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[166] = vals[33];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[167] = vals[33];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[168] = vals[33];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[169] = vals[33];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[170] = vals[34];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[171] = vals[34];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[172] = vals[34];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[173] = vals[34];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[174] = vals[34];
    y[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    y[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    y[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[175] = vals[35];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[176] = vals[35];
    y[0] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[177] = vals[35];
    y[0] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[178] = vals[35];
    y[0] = 0.5000000000000001 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    y[1] = 0.5000000000000001 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    y[2] = 0.5000000000000001 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[179] = vals[35];
}

void plas3d_finite_element_2::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    throw std::runtime_error("interpolate_vertex_values: Function is not supported/implemented for QuadratureElement.");
}

void plas3d_finite_element_2::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 2] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 2 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 2 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 3] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 3 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 3 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 4] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 4 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 4 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 5] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 5 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 5 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 6] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 6 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 6 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 7] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 7 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 7 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 8] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 8 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 8 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 9] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 9 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 9 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 10] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 10 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 10 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 11] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 11 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 11 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 12] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 12 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 12 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 13] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 13 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 13 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 14] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 14 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 14 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 15] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 15 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 15 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 16] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 16 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 16 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 17] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 17 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 17 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 18] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 18 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 18 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 19] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 19 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 19 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 20] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 20 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 20 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 21] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 21 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 21 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 22] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 22 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 22 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 23] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 23 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 23 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 24] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 24 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 24 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 25] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 25 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 25 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 26] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 26 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 26 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 27] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 27 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 27 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 28] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 28 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 28 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 29] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 29 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 29 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 30] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 30 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 30 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 31] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 31 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 31 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 32] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 32 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 32 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 33] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 33 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 33 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 34] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 34 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 34 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 35] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 35 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 35 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 36] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 36 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 36 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 37] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 37 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 37 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 38] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 38 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 38 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 39] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 39 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 39 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 40] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 40 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 40 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 41] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 41 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 41 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 42] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 42 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 42 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 43] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 43 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 43 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 44] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 44 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 44 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 45] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 45 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 45 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 46] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 46 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 46 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 47] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 47 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 47 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 48] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 48 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 48 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 49] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 49 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 49 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 50] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 50 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 50 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 51] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 51 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 51 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 52] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 52 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 52 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 53] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 53 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 53 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 54] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 54 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 54 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 55] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 55 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 55 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 56] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 56 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 56 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 57] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 57 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 57 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 58] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 58 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 58 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 59] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 59 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 59 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 60] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 60 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 60 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 61] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 61 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 61 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 62] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 62 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 62 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 63] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 63 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 63 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 64] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 64 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 64 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 65] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 65 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 65 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 66] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 66 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 66 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 67] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 67 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 67 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 68] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 68 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 68 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 69] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 69 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 69 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 70] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 70 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 70 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 71] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 71 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 71 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 72] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 72 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 72 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 73] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 73 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 73 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 74] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 74 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 74 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 75] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 75 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 75 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 76] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 76 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 76 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 77] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 77 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 77 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 78] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 78 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 78 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 79] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 79 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 79 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 80] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 80 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 80 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 81] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 81 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 81 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 82] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 82 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 82 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 83] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 83 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 83 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 84] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 84 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 84 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 85] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 85 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 85 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 86] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 86 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 86 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 87] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 87 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 87 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 88] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 88 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 88 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 89] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 89 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 89 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 90] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 90 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 90 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 91] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 91 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 91 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 92] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 92 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 92 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 93] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 93 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 93 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 94] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 94 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 94 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 95] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 95 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 95 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 96] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 96 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 96 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 97] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 97 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 97 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 98] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 98 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 98 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 99] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 99 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 99 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 100] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 100 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 100 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 101] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 101 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 101 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 102] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 102 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 102 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 103] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 103 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 103 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 104] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 104 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 104 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 105] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 105 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 105 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 106] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 106 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 106 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 107] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 107 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 107 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 108] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 108 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 108 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 109] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 109 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 109 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 110] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 110 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 110 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 111] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 111 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 111 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 112] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 112 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 112 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 113] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 113 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 113 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 114] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 114 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 114 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 115] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 115 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 115 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 116] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 116 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 116 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 117] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 117 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 117 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 118] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 118 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 118 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 119] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 119 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 119 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 120] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 120 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 120 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 121] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 121 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 121 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 122] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 122 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 122 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 123] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 123 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 123 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 124] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 124 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 124 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 125] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 125 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 125 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 126] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 126 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 126 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 127] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 127 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 127 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 128] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 128 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 128 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 129] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 129 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 129 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 130] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 130 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 130 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 131] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 131 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 131 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 132] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 132 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 132 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 133] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 133 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 133 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 134] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 134 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 134 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 135] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 135 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 135 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 136] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 136 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 136 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 137] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 137 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 137 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 138] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 138 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 138 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 139] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 139 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 139 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 140] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 140 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 140 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 141] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 141 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 141 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 142] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 142 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 142 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 143] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 143 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 143 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 144] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 144 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 144 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 145] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 145 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 145 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 146] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 146 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 146 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 147] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 147 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 147 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 148] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 148 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 148 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 149] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 149 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 149 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 150] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 150 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 150 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 151] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 151 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 151 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 152] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 152 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 152 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 153] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 153 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 153 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 154] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 154 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 154 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 155] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 155 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 155 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 156] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 156 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 156 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 157] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 157 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 157 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 158] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 158 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 158 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 159] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 159 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 159 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 160] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 160 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 160 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 161] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 161 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 161 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 162] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 162 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 162 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 163] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 163 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 163 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 164] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 164 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 164 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 165] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 165 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 165 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 166] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 166 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 166 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 167] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 167 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 167 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 168] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 168 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 168 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 169] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 169 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 169 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 170] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 170 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 170 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 171] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 171 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 171 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 172] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 172 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 172 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 173] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 173 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 173 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 174] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 174 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 174 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 175] = 0.25 * coordinate_dofs[0] + 0.25 * coordinate_dofs[3] + 0.25 * coordinate_dofs[6] + 0.25 * coordinate_dofs[9];
    dof_coordinates[3 * 175 + 1] = 0.25 * coordinate_dofs[1] + 0.25 * coordinate_dofs[4] + 0.25 * coordinate_dofs[7] + 0.25 * coordinate_dofs[10];
    dof_coordinates[3 * 175 + 2] = 0.25 * coordinate_dofs[2] + 0.25 * coordinate_dofs[5] + 0.25 * coordinate_dofs[8] + 0.25 * coordinate_dofs[11];
    dof_coordinates[3 * 176] = 0.16666666666666677 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 176 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 176 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 177] = 0.16666666666666677 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 177 + 1] = 0.16666666666666677 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 177 + 2] = 0.16666666666666677 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
    dof_coordinates[3 * 178] = 0.16666666666666674 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 178 + 1] = 0.16666666666666674 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 178 + 2] = 0.16666666666666674 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 179] = 0.5 * coordinate_dofs[0] + 0.1666666666666666 * coordinate_dofs[3] + 0.1666666666666666 * coordinate_dofs[6] + 0.1666666666666666 * coordinate_dofs[9];
    dof_coordinates[3 * 179 + 1] = 0.5 * coordinate_dofs[1] + 0.1666666666666666 * coordinate_dofs[4] + 0.1666666666666666 * coordinate_dofs[7] + 0.1666666666666666 * coordinate_dofs[10];
    dof_coordinates[3 * 179 + 2] = 0.5 * coordinate_dofs[2] + 0.1666666666666666 * coordinate_dofs[5] + 0.1666666666666666 * coordinate_dofs[8] + 0.1666666666666666 * coordinate_dofs[11];
}

void plas3d_finite_element_2::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[540] = { 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.25, 0.25, 0.25, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666, 0.5, 0.1666666666666666, 0.1666666666666666, 0.1666666666666666 };
    std::copy_n(dof_X, 540, reference_dof_coordinates);
}

std::size_t plas3d_finite_element_2::num_sub_elements() const
{
    return 36;
}

ufc::finite_element * plas3d_finite_element_2::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_0();
    case 1:
        return new plas3d_finite_element_0();
    case 2:
        return new plas3d_finite_element_0();
    case 3:
        return new plas3d_finite_element_0();
    case 4:
        return new plas3d_finite_element_0();
    case 5:
        return new plas3d_finite_element_0();
    case 6:
        return new plas3d_finite_element_0();
    case 7:
        return new plas3d_finite_element_0();
    case 8:
        return new plas3d_finite_element_0();
    case 9:
        return new plas3d_finite_element_0();
    case 10:
        return new plas3d_finite_element_0();
    case 11:
        return new plas3d_finite_element_0();
    case 12:
        return new plas3d_finite_element_0();
    case 13:
        return new plas3d_finite_element_0();
    case 14:
        return new plas3d_finite_element_0();
    case 15:
        return new plas3d_finite_element_0();
    case 16:
        return new plas3d_finite_element_0();
    case 17:
        return new plas3d_finite_element_0();
    case 18:
        return new plas3d_finite_element_0();
    case 19:
        return new plas3d_finite_element_0();
    case 20:
        return new plas3d_finite_element_0();
    case 21:
        return new plas3d_finite_element_0();
    case 22:
        return new plas3d_finite_element_0();
    case 23:
        return new plas3d_finite_element_0();
    case 24:
        return new plas3d_finite_element_0();
    case 25:
        return new plas3d_finite_element_0();
    case 26:
        return new plas3d_finite_element_0();
    case 27:
        return new plas3d_finite_element_0();
    case 28:
        return new plas3d_finite_element_0();
    case 29:
        return new plas3d_finite_element_0();
    case 30:
        return new plas3d_finite_element_0();
    case 31:
        return new plas3d_finite_element_0();
    case 32:
        return new plas3d_finite_element_0();
    case 33:
        return new plas3d_finite_element_0();
    case 34:
        return new plas3d_finite_element_0();
    case 35:
        return new plas3d_finite_element_0();
    default:
        return nullptr;
    }
}

ufc::finite_element * plas3d_finite_element_2::create() const
{
    return new plas3d_finite_element_2();
}


plas3d_finite_element_3::plas3d_finite_element_3() : ufc::finite_element()
{
    // Do nothing
}

plas3d_finite_element_3::~plas3d_finite_element_3()
{
    // Do nothing
}

const char * plas3d_finite_element_3::signature() const
{
    return "FiniteElement('Lagrange', tetrahedron, 2)";
}

ufc::shape plas3d_finite_element_3::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t plas3d_finite_element_3::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_3::geometric_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_3::space_dimension() const
{
    return 10;
}

std::size_t plas3d_finite_element_3::value_rank() const
{
    return 0;
}

std::size_t plas3d_finite_element_3::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t plas3d_finite_element_3::value_size() const
{
    return 1;
}

std::size_t plas3d_finite_element_3::reference_value_rank() const
{
    return 0;
}

std::size_t plas3d_finite_element_3::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t plas3d_finite_element_3::reference_value_size() const
{
    return 1;
}

std::size_t plas3d_finite_element_3::degree() const
{
    return 2;
}

const char * plas3d_finite_element_3::family() const
{
    return "Lagrange";
}

void plas3d_finite_element_3::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][10] = { { -0.057735026918962505, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.04114755998989117, 0.029095718698132315, 0.02375655483665995, 0.016798421022632327 } };
    static const double coefficients1[1][10] = { { -0.05773502691896254, 0.06085806194501846, -0.03513641844631533, -0.02484519974999768, 0.06506000486323553, -0.050395263067896955, -0.04114755998989117, 0.029095718698132312, 0.023756554836659945, 0.016798421022632324 } };
    static const double coefficients2[1][10] = { { -0.05773502691896254, 0.0, 0.07027283689263066, -0.024845199749997698, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.01679842102263232 } };
    static const double coefficients3[1][10] = { { -0.05773502691896259, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 } };
    static const double coefficients4[1][10] = { { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 } };
    static const double coefficients5[1][10] = { { 0.2309401076758504, 0.12171612389003694, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, 0.10286889997472796, 0.0, -0.05939138709164987, -0.0671936840905293 } };
    static const double coefficients6[1][10] = { { 0.23094010767585033, 0.12171612389003691, 0.07027283689263064, -0.09938079899999064, 0.0, 0.10079052613579391, -0.02057377999494557, -0.08728715609439694, -0.01187827741832998, 0.016798421022632317 } };
    static const double coefficients7[1][10] = { { 0.23094010767585046, -0.12171612389003691, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164985, -0.06719368409052928 } };
    static const double coefficients8[1][10] = { { 0.23094010767585021, -0.12171612389003696, 0.07027283689263064, -0.09938079899999064, 0.0, -0.10079052613579395, 0.020573779994945588, -0.08728715609439693, -0.01187827741832997, 0.016798421022632324 } };
    static const double coefficients9[1][10] = { { 0.23094010767585038, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132305, 0.023756554836659945, 0.016798421022632314 } };
    for (std::size_t k = 0; k < num_points * 10; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues2[10] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
        basisvalues2[4] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp2_2 * basisvalues2[0];
        basisvalues2[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues2[0];
        basisvalues2[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues2[1];
        const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
        const double tmp4_2 = 0.5 * (1.0 - Y[2]);
        const double tmp5_2 = tmp4_2 * tmp4_2;
        basisvalues2[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues2[2] - 0.5555555555555556 * tmp5_2 * basisvalues2[0];
        basisvalues2[3] = (2.0 * Y[2] + 1.0) * basisvalues2[0];
        basisvalues2[8] = (3.0 * Y[2] + 2.0) * basisvalues2[2];
        basisvalues2[6] = (3.0 * Y[2] + 2.0) * basisvalues2[1];
        basisvalues2[9] = (0.3125 + 1.875 * Y[2]) * basisvalues2[3] - 0.5625 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.75);
        basisvalues2[3] *= std::sqrt(1.25);
        basisvalues2[9] *= std::sqrt(1.75);
        basisvalues2[2] *= std::sqrt(2.5);
        basisvalues2[8] *= std::sqrt(3.5);
        basisvalues2[7] *= std::sqrt(5.25);
        basisvalues2[1] *= std::sqrt(7.5);
        basisvalues2[6] *= std::sqrt(10.5);
        basisvalues2[5] *= std::sqrt(15.75);
        basisvalues2[4] *= std::sqrt(26.25);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[10 * ip] += coefficients0[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[10 * ip + 1] += coefficients1[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[10 * ip + 2] += coefficients2[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[10 * ip + 3] += coefficients3[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[10 * ip + 4] += coefficients4[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[10 * ip + 5] += coefficients5[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[10 * ip + 6] += coefficients6[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[10 * ip + 7] += coefficients7[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[10 * ip + 8] += coefficients8[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[10 * ip + 9] += coefficients9[0][r] * basisvalues2[r];
    }
}

void plas3d_finite_element_3::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(3, order);
    std::fill_n(reference_values, num_points * 10 * num_derivatives, 0.0);
    if (order > 2)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[3][10][10] =
        { { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][10] = { { -0.057735026918962505, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.04114755998989117, 0.029095718698132315, 0.02375655483665995, 0.016798421022632327 } };
    static const double coefficients1[1][10] = { { -0.05773502691896254, 0.06085806194501846, -0.03513641844631533, -0.02484519974999768, 0.06506000486323553, -0.050395263067896955, -0.04114755998989117, 0.029095718698132312, 0.023756554836659945, 0.016798421022632324 } };
    static const double coefficients2[1][10] = { { -0.05773502691896254, 0.0, 0.07027283689263066, -0.024845199749997698, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.01679842102263232 } };
    static const double coefficients3[1][10] = { { -0.05773502691896259, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 } };
    static const double coefficients4[1][10] = { { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 } };
    static const double coefficients5[1][10] = { { 0.2309401076758504, 0.12171612389003694, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, 0.10286889997472796, 0.0, -0.05939138709164987, -0.0671936840905293 } };
    static const double coefficients6[1][10] = { { 0.23094010767585033, 0.12171612389003691, 0.07027283689263064, -0.09938079899999064, 0.0, 0.10079052613579391, -0.02057377999494557, -0.08728715609439694, -0.01187827741832998, 0.016798421022632317 } };
    static const double coefficients7[1][10] = { { 0.23094010767585046, -0.12171612389003691, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164985, -0.06719368409052928 } };
    static const double coefficients8[1][10] = { { 0.23094010767585021, -0.12171612389003696, 0.07027283689263064, -0.09938079899999064, 0.0, -0.10079052613579395, 0.020573779994945588, -0.08728715609439693, -0.01187827741832997, 0.016798421022632324 } };
    static const double coefficients9[1][10] = { { 0.23094010767585038, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132305, 0.023756554836659945, 0.016798421022632314 } };
    const std::size_t reference_offset[10] = {};
    const std::size_t num_components[10] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[2][9][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 0, 2 },
            { 1, 0 },
            { 1, 1 },
            { 1, 2 },
            { 2, 0 },
            { 2, 1 },
            { 2, 2 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues2[10] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
        basisvalues2[4] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp2_2 * basisvalues2[0];
        basisvalues2[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues2[0];
        basisvalues2[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues2[1];
        const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
        const double tmp4_2 = 0.5 * (1.0 - Y[2]);
        const double tmp5_2 = tmp4_2 * tmp4_2;
        basisvalues2[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues2[2] - 0.5555555555555556 * tmp5_2 * basisvalues2[0];
        basisvalues2[3] = (2.0 * Y[2] + 1.0) * basisvalues2[0];
        basisvalues2[8] = (3.0 * Y[2] + 2.0) * basisvalues2[2];
        basisvalues2[6] = (3.0 * Y[2] + 2.0) * basisvalues2[1];
        basisvalues2[9] = (0.3125 + 1.875 * Y[2]) * basisvalues2[3] - 0.5625 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.75);
        basisvalues2[3] *= std::sqrt(1.25);
        basisvalues2[9] *= std::sqrt(1.75);
        basisvalues2[2] *= std::sqrt(2.5);
        basisvalues2[8] *= std::sqrt(3.5);
        basisvalues2[7] *= std::sqrt(5.25);
        basisvalues2[1] *= std::sqrt(7.5);
        basisvalues2[6] *= std::sqrt(10.5);
        basisvalues2[5] *= std::sqrt(15.75);
        basisvalues2[4] *= std::sqrt(26.25);
        // Loop over all dofs
        for (std::size_t i = 0; i < 10; ++i)
        {
            double derivatives[9] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients4[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients5[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients6[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients7[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients8[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients9[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[10 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void plas3d_finite_element_3::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(3, order);
    // Precomputed combinations
    const std::size_t combinations[2][9][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 0, 2 },
            { 1, 0 },
            { 1, 1 },
            { 1, 2 },
            { 2, 0 },
            { 2, 1 },
            { 2, 2 } } };
    std::fill_n(values, num_points * 10 * num_derivatives, 0.0);
    const std::size_t reference_offsets[10] = {};
    const std::size_t physical_offsets[10] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[9][9];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 10; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[10 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[10 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void plas3d_finite_element_3::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[3] = {};
    double J[9];
    double detJ;
    double K[9];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
        compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[9] + coordinate_dofs[6] + coordinate_dofs[3] - coordinate_dofs[0];
        const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4] - coordinate_dofs[1];
        const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5] - coordinate_dofs[2];
        // Compute subdeterminants
        const double d[9] = { J[4] * J[8] - J[5] * J[7], J[5] * J[6] - J[3] * J[8], J[3] * J[7] - J[4] * J[6], J[2] * J[7] - J[1] * J[8], J[0] * J[8] - J[2] * J[6], J[1] * J[6] - J[0] * J[7], J[1] * J[5] - J[2] * J[4], J[2] * J[3] - J[0] * J[5], J[0] * J[4] - J[1] * J[3] };
        // Get coordinates and map to the reference (FIAT) element
        double Y[3] = { (d[0] * (2.0 * x[0] - C0) + d[3] * (2.0 * x[1] - C1) + d[6] * (2.0 * x[2] - C2)) / detJ, (d[1] * (2.0 * x[0] - C0) + d[4] * (2.0 * x[1] - C1) + d[7] * (2.0 * x[2] - C2)) / detJ, (d[2] * (2.0 * x[0] - C0) + d[5] * (2.0 * x[1] - C1) + d[8] * (2.0 * x[2] - C2)) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 3; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[10];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[10];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
}

void plas3d_finite_element_3::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 10; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
}

void plas3d_finite_element_3::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(3, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[9] + coordinate_dofs[6] + coordinate_dofs[3] - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4] - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5] - coordinate_dofs[2];
    // Compute subdeterminants
    const double d[9] = { J[4] * J[8] - J[5] * J[7], J[5] * J[6] - J[3] * J[8], J[3] * J[7] - J[4] * J[6], J[2] * J[7] - J[1] * J[8], J[0] * J[8] - J[2] * J[6], J[1] * J[6] - J[0] * J[7], J[1] * J[5] - J[2] * J[4], J[2] * J[3] - J[0] * J[5], J[0] * J[4] - J[1] * J[3] };
    // Get coordinates and map to the reference (FIAT) element
    double Y[3] = { (d[0] * (2.0 * x[0] - C0) + d[3] * (2.0 * x[1] - C1) + d[6] * (2.0 * x[2] - C2)) / detJ, (d[1] * (2.0 * x[0] - C0) + d[4] * (2.0 * x[1] - C1) + d[7] * (2.0 * x[2] - C2)) / detJ, (d[2] * (2.0 * x[0] - C0) + d[5] * (2.0 * x[1] - C1) + d[8] * (2.0 * x[2] - C2)) / detJ };
    // Precomputed combinations
    const std::size_t combinations[2][9][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 0, 2 },
            { 1, 0 },
            { 1, 1 },
            { 1, 2 },
            { 2, 0 },
            { 2, 1 },
            { 2, 2 } } };
    // Declare transformation matrix
    double transform[9][9] =
        { { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[3 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.057735026918962505, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.04114755998989117, 0.029095718698132315, 0.02375655483665995, 0.016798421022632327 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896254, 0.06085806194501846, -0.03513641844631533, -0.02484519974999768, 0.06506000486323553, -0.050395263067896955, -0.04114755998989117, 0.029095718698132312, 0.023756554836659945, 0.016798421022632324 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896254, 0.0, 0.07027283689263066, -0.024845199749997698, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.01679842102263232 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896259, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.2309401076758504, 0.12171612389003694, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, 0.10286889997472796, 0.0, -0.05939138709164987, -0.0671936840905293 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585033, 0.12171612389003691, 0.07027283689263064, -0.09938079899999064, 0.0, 0.10079052613579391, -0.02057377999494557, -0.08728715609439694, -0.01187827741832998, 0.016798421022632317 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585046, -0.12171612389003691, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164985, -0.06719368409052928 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585021, -0.12171612389003696, 0.07027283689263064, -0.09938079899999064, 0.0, -0.10079052613579395, 0.020573779994945588, -0.08728715609439693, -0.01187827741832997, 0.016798421022632324 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585038, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132305, 0.023756554836659945, 0.016798421022632314 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void plas3d_finite_element_3::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(3, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 10, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[9] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 10; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
}

double plas3d_finite_element_3::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 5:
        {
            y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 6:
        {
            y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
            y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
            y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 7:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 8:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 9:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
}

void plas3d_finite_element_3::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
    y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
    y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
}

void plas3d_finite_element_3::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
    vertex_values[3] = dof_values[3];
}

void plas3d_finite_element_3::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[3] = coordinate_dofs[3];
    dof_coordinates[3 + 1] = coordinate_dofs[4];
    dof_coordinates[3 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 2] = coordinate_dofs[6];
    dof_coordinates[3 * 2 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 2 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 3] = coordinate_dofs[9];
    dof_coordinates[3 * 3 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 3 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 4] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 4 + 1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 4 + 2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 5] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 5 + 1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 5 + 2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 6] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
    dof_coordinates[3 * 6 + 1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
    dof_coordinates[3 * 6 + 2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
    dof_coordinates[3 * 7] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 7 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 7 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 8] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
    dof_coordinates[3 * 8 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
    dof_coordinates[3 * 8 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
    dof_coordinates[3 * 9] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
    dof_coordinates[3 * 9 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
    dof_coordinates[3 * 9 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
}

void plas3d_finite_element_3::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[30] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0 };
    std::copy_n(dof_X, 30, reference_dof_coordinates);
}

std::size_t plas3d_finite_element_3::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * plas3d_finite_element_3::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * plas3d_finite_element_3::create() const
{
    return new plas3d_finite_element_3();
}


plas3d_finite_element_4::plas3d_finite_element_4() : ufc::finite_element()
{
    // Do nothing
}

plas3d_finite_element_4::~plas3d_finite_element_4()
{
    // Do nothing
}

const char * plas3d_finite_element_4::signature() const
{
    return "VectorElement(FiniteElement('Lagrange', tetrahedron, 2), dim=3)";
}

ufc::shape plas3d_finite_element_4::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t plas3d_finite_element_4::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_4::geometric_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_4::space_dimension() const
{
    return 30;
}

std::size_t plas3d_finite_element_4::value_rank() const
{
    return 1;
}

std::size_t plas3d_finite_element_4::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 3 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t plas3d_finite_element_4::value_size() const
{
    return 3;
}

std::size_t plas3d_finite_element_4::reference_value_rank() const
{
    return 1;
}

std::size_t plas3d_finite_element_4::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 3 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t plas3d_finite_element_4::reference_value_size() const
{
    return 3;
}

std::size_t plas3d_finite_element_4::degree() const
{
    return 2;
}

const char * plas3d_finite_element_4::family() const
{
    return "Lagrange";
}

void plas3d_finite_element_4::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][10] = { { -0.057735026918962505, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.04114755998989117, 0.029095718698132315, 0.02375655483665995, 0.016798421022632327 } };
    static const double coefficients1[1][10] = { { -0.05773502691896254, 0.06085806194501846, -0.03513641844631533, -0.02484519974999768, 0.06506000486323553, -0.050395263067896955, -0.04114755998989117, 0.029095718698132312, 0.023756554836659945, 0.016798421022632324 } };
    static const double coefficients2[1][10] = { { -0.05773502691896254, 0.0, 0.07027283689263066, -0.024845199749997698, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.01679842102263232 } };
    static const double coefficients3[1][10] = { { -0.05773502691896259, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 } };
    static const double coefficients4[1][10] = { { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 } };
    static const double coefficients5[1][10] = { { 0.2309401076758504, 0.12171612389003694, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, 0.10286889997472796, 0.0, -0.05939138709164987, -0.0671936840905293 } };
    static const double coefficients6[1][10] = { { 0.23094010767585033, 0.12171612389003691, 0.07027283689263064, -0.09938079899999064, 0.0, 0.10079052613579391, -0.02057377999494557, -0.08728715609439694, -0.01187827741832998, 0.016798421022632317 } };
    static const double coefficients7[1][10] = { { 0.23094010767585046, -0.12171612389003691, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164985, -0.06719368409052928 } };
    static const double coefficients8[1][10] = { { 0.23094010767585021, -0.12171612389003696, 0.07027283689263064, -0.09938079899999064, 0.0, -0.10079052613579395, 0.020573779994945588, -0.08728715609439693, -0.01187827741832997, 0.016798421022632324 } };
    static const double coefficients9[1][10] = { { 0.23094010767585038, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132305, 0.023756554836659945, 0.016798421022632314 } };
    for (std::size_t k = 0; k < num_points * 30 * 3; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues2[10] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
        basisvalues2[4] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp2_2 * basisvalues2[0];
        basisvalues2[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues2[0];
        basisvalues2[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues2[1];
        const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
        const double tmp4_2 = 0.5 * (1.0 - Y[2]);
        const double tmp5_2 = tmp4_2 * tmp4_2;
        basisvalues2[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues2[2] - 0.5555555555555556 * tmp5_2 * basisvalues2[0];
        basisvalues2[3] = (2.0 * Y[2] + 1.0) * basisvalues2[0];
        basisvalues2[8] = (3.0 * Y[2] + 2.0) * basisvalues2[2];
        basisvalues2[6] = (3.0 * Y[2] + 2.0) * basisvalues2[1];
        basisvalues2[9] = (0.3125 + 1.875 * Y[2]) * basisvalues2[3] - 0.5625 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.75);
        basisvalues2[3] *= std::sqrt(1.25);
        basisvalues2[9] *= std::sqrt(1.75);
        basisvalues2[2] *= std::sqrt(2.5);
        basisvalues2[8] *= std::sqrt(3.5);
        basisvalues2[7] *= std::sqrt(5.25);
        basisvalues2[1] *= std::sqrt(7.5);
        basisvalues2[6] *= std::sqrt(10.5);
        basisvalues2[5] *= std::sqrt(15.75);
        basisvalues2[4] *= std::sqrt(26.25);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip] += coefficients0[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3] += coefficients1[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 2] += coefficients2[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 3] += coefficients3[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 4] += coefficients4[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 5] += coefficients5[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 6] += coefficients6[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 7] += coefficients7[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 8] += coefficients8[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 9] += coefficients9[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 10 + 1] += coefficients0[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 11 + 1] += coefficients1[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 12 + 1] += coefficients2[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 13 + 1] += coefficients3[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 14 + 1] += coefficients4[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 15 + 1] += coefficients5[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 16 + 1] += coefficients6[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 17 + 1] += coefficients7[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 18 + 1] += coefficients8[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 19 + 1] += coefficients9[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 20 + 2] += coefficients0[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 21 + 2] += coefficients1[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 22 + 2] += coefficients2[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 23 + 2] += coefficients3[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 24 + 2] += coefficients4[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 25 + 2] += coefficients5[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 26 + 2] += coefficients6[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 27 + 2] += coefficients7[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 28 + 2] += coefficients8[0][r] * basisvalues2[r];
        for (std::size_t r = 0; r < 10; ++r)
            reference_values[30 * 3 * ip + 3 * 29 + 2] += coefficients9[0][r] * basisvalues2[r];
    }
}

void plas3d_finite_element_4::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(3, order);
    std::fill_n(reference_values, num_points * 30 * num_derivatives * 3, 0.0);
    if (order > 2)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[3][10][10] =
        { { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
            { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][10] = { { -0.057735026918962505, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.04114755998989117, 0.029095718698132315, 0.02375655483665995, 0.016798421022632327 } };
    static const double coefficients1[1][10] = { { -0.05773502691896254, 0.06085806194501846, -0.03513641844631533, -0.02484519974999768, 0.06506000486323553, -0.050395263067896955, -0.04114755998989117, 0.029095718698132312, 0.023756554836659945, 0.016798421022632324 } };
    static const double coefficients2[1][10] = { { -0.05773502691896254, 0.0, 0.07027283689263066, -0.024845199749997698, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.01679842102263232 } };
    static const double coefficients3[1][10] = { { -0.05773502691896259, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 } };
    static const double coefficients4[1][10] = { { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 } };
    static const double coefficients5[1][10] = { { 0.2309401076758504, 0.12171612389003694, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, 0.10286889997472796, 0.0, -0.05939138709164987, -0.0671936840905293 } };
    static const double coefficients6[1][10] = { { 0.23094010767585033, 0.12171612389003691, 0.07027283689263064, -0.09938079899999064, 0.0, 0.10079052613579391, -0.02057377999494557, -0.08728715609439694, -0.01187827741832998, 0.016798421022632317 } };
    static const double coefficients7[1][10] = { { 0.23094010767585046, -0.12171612389003691, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164985, -0.06719368409052928 } };
    static const double coefficients8[1][10] = { { 0.23094010767585021, -0.12171612389003696, 0.07027283689263064, -0.09938079899999064, 0.0, -0.10079052613579395, 0.020573779994945588, -0.08728715609439693, -0.01187827741832997, 0.016798421022632324 } };
    static const double coefficients9[1][10] = { { 0.23094010767585038, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132305, 0.023756554836659945, 0.016798421022632314 } };
    const std::size_t reference_offset[30] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
    const std::size_t num_components[30] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[2][9][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 0, 2 },
            { 1, 0 },
            { 1, 1 },
            { 1, 2 },
            { 2, 0 },
            { 2, 1 },
            { 2, 2 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues2[10] = {};
        basisvalues2[0] = 1.0;
        const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues2[1] = tmp1_2;
        const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
        basisvalues2[4] = 1.5 * tmp1_2 * basisvalues2[1] - 0.5 * tmp2_2 * basisvalues2[0];
        basisvalues2[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues2[0];
        basisvalues2[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues2[1];
        const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
        const double tmp4_2 = 0.5 * (1.0 - Y[2]);
        const double tmp5_2 = tmp4_2 * tmp4_2;
        basisvalues2[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues2[2] - 0.5555555555555556 * tmp5_2 * basisvalues2[0];
        basisvalues2[3] = (2.0 * Y[2] + 1.0) * basisvalues2[0];
        basisvalues2[8] = (3.0 * Y[2] + 2.0) * basisvalues2[2];
        basisvalues2[6] = (3.0 * Y[2] + 2.0) * basisvalues2[1];
        basisvalues2[9] = (0.3125 + 1.875 * Y[2]) * basisvalues2[3] - 0.5625 * basisvalues2[0];
        basisvalues2[0] *= std::sqrt(0.75);
        basisvalues2[3] *= std::sqrt(1.25);
        basisvalues2[9] *= std::sqrt(1.75);
        basisvalues2[2] *= std::sqrt(2.5);
        basisvalues2[8] *= std::sqrt(3.5);
        basisvalues2[7] *= std::sqrt(5.25);
        basisvalues2[1] *= std::sqrt(7.5);
        basisvalues2[6] *= std::sqrt(10.5);
        basisvalues2[5] *= std::sqrt(15.75);
        basisvalues2[4] *= std::sqrt(26.25);
        // Loop over all dofs
        for (std::size_t i = 0; i < 30; ++i)
        {
            double derivatives[9] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients4[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients5[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients6[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients7[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients8[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients9[0][s] * aux[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 12:
                // Compute reference derivatives for dof 12.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 13:
                // Compute reference derivatives for dof 13.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 14:
                // Compute reference derivatives for dof 14.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients4[0][s] * aux[s];
                }
                break;
            case 15:
                // Compute reference derivatives for dof 15.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients5[0][s] * aux[s];
                }
                break;
            case 16:
                // Compute reference derivatives for dof 16.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients6[0][s] * aux[s];
                }
                break;
            case 17:
                // Compute reference derivatives for dof 17.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients7[0][s] * aux[s];
                }
                break;
            case 18:
                // Compute reference derivatives for dof 18.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients8[0][s] * aux[s];
                }
                break;
            case 19:
                // Compute reference derivatives for dof 19.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients9[0][s] * aux[s];
                }
                break;
            case 20:
                // Compute reference derivatives for dof 20.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 21:
                // Compute reference derivatives for dof 21.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 22:
                // Compute reference derivatives for dof 22.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 23:
                // Compute reference derivatives for dof 23.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 24:
                // Compute reference derivatives for dof 24.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients4[0][s] * aux[s];
                }
                break;
            case 25:
                // Compute reference derivatives for dof 25.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients5[0][s] * aux[s];
                }
                break;
            case 26:
                // Compute reference derivatives for dof 26.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients6[0][s] * aux[s];
                }
                break;
            case 27:
                // Compute reference derivatives for dof 27.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients7[0][s] * aux[s];
                }
                break;
            case 28:
                // Compute reference derivatives for dof 28.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients8[0][s] * aux[s];
                }
                break;
            case 29:
                // Compute reference derivatives for dof 29.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[10] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[10][10] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 100, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[10][10];
                        std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 100, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 10; ++s)
                        for (std::size_t t = 0; t < 10; ++t)
                            aux[s] += dmats[s][t] * basisvalues2[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 10; ++s)
                        derivatives[r] += coefficients9[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[30 * (num_derivatives * 3) * ip + num_derivatives * 3 * i + 3 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void plas3d_finite_element_4::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(3, order);
    // Precomputed combinations
    const std::size_t combinations[2][9][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 0, 2 },
            { 1, 0 },
            { 1, 1 },
            { 1, 2 },
            { 2, 0 },
            { 2, 1 },
            { 2, 2 } } };
    std::fill_n(values, num_points * 30 * num_derivatives * 3, 0.0);
    const std::size_t reference_offsets[30] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
    const std::size_t physical_offsets[30] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[9][9];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 30; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[30 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[30 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void plas3d_finite_element_4::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[3] = {};
    double J[9];
    double detJ;
    double K[9];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
        compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[9] + coordinate_dofs[6] + coordinate_dofs[3] - coordinate_dofs[0];
        const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4] - coordinate_dofs[1];
        const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5] - coordinate_dofs[2];
        // Compute subdeterminants
        const double d[9] = { J[4] * J[8] - J[5] * J[7], J[5] * J[6] - J[3] * J[8], J[3] * J[7] - J[4] * J[6], J[2] * J[7] - J[1] * J[8], J[0] * J[8] - J[2] * J[6], J[1] * J[6] - J[0] * J[7], J[1] * J[5] - J[2] * J[4], J[2] * J[3] - J[0] * J[5], J[0] * J[4] - J[1] * J[3] };
        // Get coordinates and map to the reference (FIAT) element
        double Y[3] = { (d[0] * (2.0 * x[0] - C0) + d[3] * (2.0 * x[1] - C1) + d[6] * (2.0 * x[2] - C2)) / detJ, (d[1] * (2.0 * x[0] - C0) + d[4] * (2.0 * x[1] - C1) + d[7] * (2.0 * x[2] - C2)) / detJ, (d[2] * (2.0 * x[0] - C0) + d[5] * (2.0 * x[1] - C1) + d[8] * (2.0 * x[2] - C2)) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 3; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[90];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[90];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 3; ++k)
        values[k] = physical_values[3 * i + k];
}

void plas3d_finite_element_4::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 30; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 3; ++s)
            values[r * 3 + s] = dof_values[s];
    }
}

void plas3d_finite_element_4::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(3, n);
    std::fill_n(values, 3 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[9] + coordinate_dofs[6] + coordinate_dofs[3] - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4] - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5] - coordinate_dofs[2];
    // Compute subdeterminants
    const double d[9] = { J[4] * J[8] - J[5] * J[7], J[5] * J[6] - J[3] * J[8], J[3] * J[7] - J[4] * J[6], J[2] * J[7] - J[1] * J[8], J[0] * J[8] - J[2] * J[6], J[1] * J[6] - J[0] * J[7], J[1] * J[5] - J[2] * J[4], J[2] * J[3] - J[0] * J[5], J[0] * J[4] - J[1] * J[3] };
    // Get coordinates and map to the reference (FIAT) element
    double Y[3] = { (d[0] * (2.0 * x[0] - C0) + d[3] * (2.0 * x[1] - C1) + d[6] * (2.0 * x[2] - C2)) / detJ, (d[1] * (2.0 * x[0] - C0) + d[4] * (2.0 * x[1] - C1) + d[7] * (2.0 * x[2] - C2)) / detJ, (d[2] * (2.0 * x[0] - C0) + d[5] * (2.0 * x[1] - C1) + d[8] * (2.0 * x[2] - C2)) / detJ };
    // Precomputed combinations
    const std::size_t combinations[2][9][2] =
        { { { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 },
            { 0, 0 },
            { 1, 0 },
            { 2, 0 } },
          { { 0, 0 },
            { 0, 1 },
            { 0, 2 },
            { 1, 0 },
            { 1, 1 },
            { 1, 2 },
            { 2, 0 },
            { 2, 1 },
            { 2, 2 } } };
    // Declare transformation matrix
    double transform[9][9] =
        { { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[3 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.057735026918962505, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.04114755998989117, 0.029095718698132315, 0.02375655483665995, 0.016798421022632327 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896254, 0.06085806194501846, -0.03513641844631533, -0.02484519974999768, 0.06506000486323553, -0.050395263067896955, -0.04114755998989117, 0.029095718698132312, 0.023756554836659945, 0.016798421022632324 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896254, 0.0, 0.07027283689263066, -0.024845199749997698, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.01679842102263232 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896259, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.2309401076758504, 0.12171612389003694, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, 0.10286889997472796, 0.0, -0.05939138709164987, -0.0671936840905293 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585033, 0.12171612389003691, 0.07027283689263064, -0.09938079899999064, 0.0, 0.10079052613579391, -0.02057377999494557, -0.08728715609439694, -0.01187827741832998, 0.016798421022632317 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585046, -0.12171612389003691, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164985, -0.06719368409052928 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585021, -0.12171612389003696, 0.07027283689263064, -0.09938079899999064, 0.0, -0.10079052613579395, 0.020573779994945588, -0.08728715609439693, -0.01187827741832997, 0.016798421022632324 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585038, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132305, 0.023756554836659945, 0.016798421022632314 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 10:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.057735026918962505, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.04114755998989117, 0.029095718698132315, 0.02375655483665995, 0.016798421022632327 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 11:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896254, 0.06085806194501846, -0.03513641844631533, -0.02484519974999768, 0.06506000486323553, -0.050395263067896955, -0.04114755998989117, 0.029095718698132312, 0.023756554836659945, 0.016798421022632324 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 12:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896254, 0.0, 0.07027283689263066, -0.024845199749997698, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.01679842102263232 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 13:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896259, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 14:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 15:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.2309401076758504, 0.12171612389003694, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, 0.10286889997472796, 0.0, -0.05939138709164987, -0.0671936840905293 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 16:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585033, 0.12171612389003691, 0.07027283689263064, -0.09938079899999064, 0.0, 0.10079052613579391, -0.02057377999494557, -0.08728715609439694, -0.01187827741832998, 0.016798421022632317 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 17:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585046, -0.12171612389003691, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164985, -0.06719368409052928 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 18:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585021, -0.12171612389003696, 0.07027283689263064, -0.09938079899999064, 0.0, -0.10079052613579395, 0.020573779994945588, -0.08728715609439693, -0.01187827741832997, 0.016798421022632324 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 19:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585038, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132305, 0.023756554836659945, 0.016798421022632314 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 20:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.057735026918962505, -0.06085806194501846, -0.03513641844631533, -0.024845199749997673, 0.06506000486323554, 0.05039526306789696, 0.04114755998989117, 0.029095718698132315, 0.02375655483665995, 0.016798421022632327 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 21:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896254, 0.06085806194501846, -0.03513641844631533, -0.02484519974999768, 0.06506000486323553, -0.050395263067896955, -0.04114755998989117, 0.029095718698132312, 0.023756554836659945, 0.016798421022632324 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 22:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896254, 0.0, 0.07027283689263066, -0.024845199749997698, 0.0, 0.0, 0.0, 0.08728715609439693, -0.04751310967331989, 0.01679842102263232 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 23:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { -0.05773502691896259, 0.0, 0.0, 0.07453559924999299, 0.0, 0.0, 0.0, 0.0, 0.0, 0.10079052613579392 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 24:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585033, 0.0, 0.1405456737852613, 0.09938079899999064, 0.0, 0.0, 0.0, 0.0, 0.11878277418329974, -0.06719368409052928 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 25:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.2309401076758504, 0.12171612389003694, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, 0.10286889997472796, 0.0, -0.05939138709164987, -0.0671936840905293 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 26:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585033, 0.12171612389003691, 0.07027283689263064, -0.09938079899999064, 0.0, 0.10079052613579391, -0.02057377999494557, -0.08728715609439694, -0.01187827741832998, 0.016798421022632317 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 27:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585046, -0.12171612389003691, -0.07027283689263064, 0.09938079899999065, 0.0, 0.0, -0.10286889997472794, 0.0, -0.05939138709164985, -0.06719368409052928 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 28:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585021, -0.12171612389003696, 0.07027283689263064, -0.09938079899999064, 0.0, -0.10079052613579395, 0.020573779994945588, -0.08728715609439693, -0.01187827741832997, 0.016798421022632324 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 29:
        {
            double basisvalues[10] = {};
            basisvalues[0] = 1.0;
            const double tmp1_2 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_2;
            const double tmp2_2 = 0.25 * (Y[1] + Y[2]) * (Y[1] + Y[2]);
            basisvalues[4] = 1.5 * tmp1_2 * basisvalues[1] - 0.5 * tmp2_2 * basisvalues[0];
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[5] = (0.5 * (2.0 + 3.0 * Y[1] + Y[2]) + (1.0 + Y[1])) * basisvalues[1];
            const double tmp3_2 = 0.5 * (1.0 + 2.0 * Y[1] + Y[2]);
            const double tmp4_2 = 0.5 * (1.0 - Y[2]);
            const double tmp5_2 = tmp4_2 * tmp4_2;
            basisvalues[7] = (1.6666666666666667 * tmp3_2 + 0.1111111111111111 * tmp4_2) * basisvalues[2] - 0.5555555555555556 * tmp5_2 * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[8] = (3.0 * Y[2] + 2.0) * basisvalues[2];
            basisvalues[6] = (3.0 * Y[2] + 2.0) * basisvalues[1];
            basisvalues[9] = (0.3125 + 1.875 * Y[2]) * basisvalues[3] - 0.5625 * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[9] *= std::sqrt(1.75);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[8] *= std::sqrt(3.5);
            basisvalues[7] *= std::sqrt(5.25);
            basisvalues[1] *= std::sqrt(7.5);
            basisvalues[6] *= std::sqrt(10.5);
            basisvalues[5] *= std::sqrt(15.75);
            basisvalues[4] *= std::sqrt(26.25);
            // Table(s) of coefficients
            static const double coefficients0[10] = { 0.23094010767585038, 0.0, -0.14054567378526128, -0.09938079899999064, -0.1301200097264711, 0.0, 0.0, 0.029095718698132305, 0.023756554836659945, 0.016798421022632314 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336757, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 11.224972160321823, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 4.582575694955855, 0.0, 8.366600265340765, -1.183215956619928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.7416573867739538, 0.0, 0.0, 8.69482604771367, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.477225575051662, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.2912878474779608, 7.245688373094726, 4.1833001326703805, -0.5916079783099695, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933869769, 0.0, 0.0, 4.347413023856835, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -2.6457513110646236, 0.0, 9.660917830792958, 0.6831300510639817, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.240370349203942, 0.0, 0.0, 7.5299402388066845, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[10][10] =
                { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 3.1622776601683786, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8257418583505536, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 5.1639777949432215, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.95803989154981, 5.612486080160912, -1.080123449734643, -0.7637626158259727, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 2.291287847477916, 1.4491376746189433, 4.183300132670374, -0.5916079783099613, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.8708286933870129, 7.099295739719547, 0.0, 4.347413023856836, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.3228756555323067, 0.0, 3.864367132317191, -0.34156502553198986, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 1.0801234497346337, 0.0, 7.099295739719544, 2.5099800796022134, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { -3.8188130791299084, 0.0, 0.0, 8.874119674649432, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[9] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[10][10] =
                { { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 100, 0.0);
                for (std::size_t t = 0; t < 10; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 100, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 100, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 10; ++t)
                            for (std::size_t u = 0; u < 10; ++u)
                                for (std::size_t tu = 0; tu < 10; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 10; ++s)
                    for (std::size_t t = 0; t < 10; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void plas3d_finite_element_4::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(3, n);
    // Set values equal to zero.
    std::fill_n(values, 3 * num_derivatives * 30, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[27] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 30; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 3 * num_derivatives; ++s)
            values[3 * num_derivatives * r + s] = dof_values[s];
    }
}

double plas3d_finite_element_4::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[3];
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 5:
        {
            y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 6:
        {
            y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
            y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
            y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 7:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 8:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 9:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 10:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 11:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 12:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 13:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 14:
        {
            y[0] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 15:
        {
            y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 16:
        {
            y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
            y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
            y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 17:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 18:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 19:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 20:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 21:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 22:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 23:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 24:
        {
            y[0] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 25:
        {
            y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 26:
        {
            y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
            y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
            y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 27:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 28:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 29:
        {
            y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
            y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
            y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    }
    return 0.0;
}

void plas3d_finite_element_4::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[3];
    // Declare variable for physical coordinates
    double y[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
    y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
    y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[12] = vals[1];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[13] = vals[1];
    y[0] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[14] = vals[1];
    y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[15] = vals[1];
    y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
    y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
    y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[16] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[17] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[18] = vals[1];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[19] = vals[1];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[20] = vals[2];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[21] = vals[2];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[22] = vals[2];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[23] = vals[2];
    y[0] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[24] = vals[2];
    y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[25] = vals[2];
    y[0] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
    y[1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
    y[2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[26] = vals[2];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[27] = vals[2];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[28] = vals[2];
    y[0] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
    y[1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
    y[2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[29] = vals[2];
}

void plas3d_finite_element_4::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    vertex_values[9] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[10];
    vertex_values[4] = dof_values[11];
    vertex_values[7] = dof_values[12];
    vertex_values[10] = dof_values[13];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[20];
    vertex_values[5] = dof_values[21];
    vertex_values[8] = dof_values[22];
    vertex_values[11] = dof_values[23];
}

void plas3d_finite_element_4::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[3] = coordinate_dofs[3];
    dof_coordinates[3 + 1] = coordinate_dofs[4];
    dof_coordinates[3 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 2] = coordinate_dofs[6];
    dof_coordinates[3 * 2 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 2 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 3] = coordinate_dofs[9];
    dof_coordinates[3 * 3 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 3 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 4] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 4 + 1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 4 + 2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 5] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 5 + 1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 5 + 2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 6] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
    dof_coordinates[3 * 6 + 1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
    dof_coordinates[3 * 6 + 2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
    dof_coordinates[3 * 7] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 7 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 7 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 8] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
    dof_coordinates[3 * 8 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
    dof_coordinates[3 * 8 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
    dof_coordinates[3 * 9] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
    dof_coordinates[3 * 9 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
    dof_coordinates[3 * 9 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
    dof_coordinates[3 * 10] = coordinate_dofs[0];
    dof_coordinates[3 * 10 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 10 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 11] = coordinate_dofs[3];
    dof_coordinates[3 * 11 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 11 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 12] = coordinate_dofs[6];
    dof_coordinates[3 * 12 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 12 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 13] = coordinate_dofs[9];
    dof_coordinates[3 * 13 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 13 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 14] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 14 + 1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 14 + 2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 15] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 15 + 1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 15 + 2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 16] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
    dof_coordinates[3 * 16 + 1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
    dof_coordinates[3 * 16 + 2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
    dof_coordinates[3 * 17] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 17 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 17 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 18] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
    dof_coordinates[3 * 18 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
    dof_coordinates[3 * 18 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
    dof_coordinates[3 * 19] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
    dof_coordinates[3 * 19 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
    dof_coordinates[3 * 19 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
    dof_coordinates[3 * 20] = coordinate_dofs[0];
    dof_coordinates[3 * 20 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 20 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 21] = coordinate_dofs[3];
    dof_coordinates[3 * 21 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 21 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 22] = coordinate_dofs[6];
    dof_coordinates[3 * 22 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 22 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 23] = coordinate_dofs[9];
    dof_coordinates[3 * 23 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 23 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 24] = 0.5 * coordinate_dofs[6] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 24 + 1] = 0.5 * coordinate_dofs[7] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 24 + 2] = 0.5 * coordinate_dofs[8] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 25] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 25 + 1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 25 + 2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 26] = 0.5 * coordinate_dofs[3] + 0.5 * coordinate_dofs[6];
    dof_coordinates[3 * 26 + 1] = 0.5 * coordinate_dofs[4] + 0.5 * coordinate_dofs[7];
    dof_coordinates[3 * 26 + 2] = 0.5 * coordinate_dofs[5] + 0.5 * coordinate_dofs[8];
    dof_coordinates[3 * 27] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[9];
    dof_coordinates[3 * 27 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[10];
    dof_coordinates[3 * 27 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[11];
    dof_coordinates[3 * 28] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[6];
    dof_coordinates[3 * 28 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[7];
    dof_coordinates[3 * 28 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[8];
    dof_coordinates[3 * 29] = 0.5 * coordinate_dofs[0] + 0.5 * coordinate_dofs[3];
    dof_coordinates[3 * 29 + 1] = 0.5 * coordinate_dofs[1] + 0.5 * coordinate_dofs[4];
    dof_coordinates[3 * 29 + 2] = 0.5 * coordinate_dofs[2] + 0.5 * coordinate_dofs[5];
}

void plas3d_finite_element_4::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[90] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0 };
    std::copy_n(dof_X, 90, reference_dof_coordinates);
}

std::size_t plas3d_finite_element_4::num_sub_elements() const
{
    return 3;
}

ufc::finite_element * plas3d_finite_element_4::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_3();
    case 1:
        return new plas3d_finite_element_3();
    case 2:
        return new plas3d_finite_element_3();
    default:
        return nullptr;
    }
}

ufc::finite_element * plas3d_finite_element_4::create() const
{
    return new plas3d_finite_element_4();
}


plas3d_finite_element_5::plas3d_finite_element_5() : ufc::finite_element()
{
    // Do nothing
}

plas3d_finite_element_5::~plas3d_finite_element_5()
{
    // Do nothing
}

const char * plas3d_finite_element_5::signature() const
{
    return "FiniteElement('Lagrange', tetrahedron, 1)";
}

ufc::shape plas3d_finite_element_5::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t plas3d_finite_element_5::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_5::geometric_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_5::space_dimension() const
{
    return 4;
}

std::size_t plas3d_finite_element_5::value_rank() const
{
    return 0;
}

std::size_t plas3d_finite_element_5::value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t plas3d_finite_element_5::value_size() const
{
    return 1;
}

std::size_t plas3d_finite_element_5::reference_value_rank() const
{
    return 0;
}

std::size_t plas3d_finite_element_5::reference_value_dimension(std::size_t i) const
{
    return 1;
}

std::size_t plas3d_finite_element_5::reference_value_size() const
{
    return 1;
}

std::size_t plas3d_finite_element_5::degree() const
{
    return 1;
}

const char * plas3d_finite_element_5::family() const
{
    return "Lagrange";
}

void plas3d_finite_element_5::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
    static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
    static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
    static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
    for (std::size_t k = 0; k < num_points * 4; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[4] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
        basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.75);
        basisvalues1[3] *= std::sqrt(1.25);
        basisvalues1[2] *= std::sqrt(2.5);
        basisvalues1[1] *= std::sqrt(7.5);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[4 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[4 * ip + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[4 * ip + 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[4 * ip + 3] += coefficients3[0][r] * basisvalues1[r];
    }
}

void plas3d_finite_element_5::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(3, order);
    std::fill_n(reference_values, num_points * 4 * num_derivatives, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[3][4][4] =
        { { { 0.0, 0.0, 0.0, 0.0 },
            { 6.324555320336758, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0 },
            { 3.162277660168379, 0.0, 0.0, 0.0 },
            { 5.477225575051663, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0 },
            { 3.162277660168379, 0.0, 0.0, 0.0 },
            { 1.8257418583505545, 0.0, 0.0, 0.0 },
            { 5.163977794943224, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
    static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
    static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
    static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
    const std::size_t reference_offset[4] = {};
    const std::size_t num_components[4] = { 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[4] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
        basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.75);
        basisvalues1[3] *= std::sqrt(1.25);
        basisvalues1[2] *= std::sqrt(2.5);
        basisvalues1[1] *= std::sqrt(7.5);
        // Loop over all dofs
        for (std::size_t i = 0; i < 4; ++i)
        {
            double derivatives[3] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[4 * num_derivatives * ip + num_derivatives * i + r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void plas3d_finite_element_5::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(3, order);
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    std::fill_n(values, num_points * 4 * num_derivatives, 0.0);
    const std::size_t reference_offsets[4] = {};
    const std::size_t physical_offsets[4] = {};
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[3][3];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 4; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[4 * num_derivatives * ip + num_derivatives * d + s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[4 * num_derivatives * ip + num_derivatives * d + r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void plas3d_finite_element_5::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[3] = {};
    double J[9];
    double detJ;
    double K[9];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
        compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[9] + coordinate_dofs[6] + coordinate_dofs[3] - coordinate_dofs[0];
        const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4] - coordinate_dofs[1];
        const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5] - coordinate_dofs[2];
        // Compute subdeterminants
        const double d[9] = { J[4] * J[8] - J[5] * J[7], J[5] * J[6] - J[3] * J[8], J[3] * J[7] - J[4] * J[6], J[2] * J[7] - J[1] * J[8], J[0] * J[8] - J[2] * J[6], J[1] * J[6] - J[0] * J[7], J[1] * J[5] - J[2] * J[4], J[2] * J[3] - J[0] * J[5], J[0] * J[4] - J[1] * J[3] };
        // Get coordinates and map to the reference (FIAT) element
        double Y[3] = { (d[0] * (2.0 * x[0] - C0) + d[3] * (2.0 * x[1] - C1) + d[6] * (2.0 * x[2] - C2)) / detJ, (d[1] * (2.0 * x[0] - C0) + d[4] * (2.0 * x[1] - C1) + d[7] * (2.0 * x[2] - C2)) / detJ, (d[2] * (2.0 * x[0] - C0) + d[5] * (2.0 * x[1] - C1) + d[8] * (2.0 * x[2] - C2)) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 3; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[4];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[4];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 1; ++k)
        values[k] = physical_values[i + k];
}

void plas3d_finite_element_5::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold value of a single dof.
    double dof_values = 0.0;
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 4; ++r)
    {
        evaluate_basis(r, &dof_values, x, coordinate_dofs, cell_orientation);
        values[r] = dof_values;
    }
}

void plas3d_finite_element_5::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(3, n);
    std::fill_n(values, num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[9] + coordinate_dofs[6] + coordinate_dofs[3] - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4] - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5] - coordinate_dofs[2];
    // Compute subdeterminants
    const double d[9] = { J[4] * J[8] - J[5] * J[7], J[5] * J[6] - J[3] * J[8], J[3] * J[7] - J[4] * J[6], J[2] * J[7] - J[1] * J[8], J[0] * J[8] - J[2] * J[6], J[1] * J[6] - J[0] * J[7], J[1] * J[5] - J[2] * J[4], J[2] * J[3] - J[0] * J[5], J[0] * J[4] - J[1] * J[3] };
    // Get coordinates and map to the reference (FIAT) element
    double Y[3] = { (d[0] * (2.0 * x[0] - C0) + d[3] * (2.0 * x[1] - C1) + d[6] * (2.0 * x[2] - C2)) / detJ, (d[1] * (2.0 * x[0] - C0) + d[4] * (2.0 * x[1] - C1) + d[7] * (2.0 * x[2] - C2)) / detJ, (d[2] * (2.0 * x[0] - C0) + d[5] * (2.0 * x[1] - C1) + d[8] * (2.0 * x[2] - C2)) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    // Declare transformation matrix
    double transform[3][3] =
        { { 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[3 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void plas3d_finite_element_5::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(3, n);
    // Set values equal to zero.
    std::fill_n(values, num_derivatives * 4, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 4; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < num_derivatives; ++s)
            values[num_derivatives * r + s] = dof_values[s];
    }
}

double plas3d_finite_element_5::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    }
    return 0.0;
}

void plas3d_finite_element_5::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[1];
    // Declare variable for physical coordinates
    double y[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
}

void plas3d_finite_element_5::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
    vertex_values[3] = dof_values[3];
}

void plas3d_finite_element_5::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[3] = coordinate_dofs[3];
    dof_coordinates[3 + 1] = coordinate_dofs[4];
    dof_coordinates[3 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 2] = coordinate_dofs[6];
    dof_coordinates[3 * 2 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 2 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 3] = coordinate_dofs[9];
    dof_coordinates[3 * 3 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 3 + 2] = coordinate_dofs[11];
}

void plas3d_finite_element_5::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[12] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 12, reference_dof_coordinates);
}

std::size_t plas3d_finite_element_5::num_sub_elements() const
{
    return 0;
}

ufc::finite_element * plas3d_finite_element_5::create_sub_element(std::size_t i) const
{
    return nullptr;
}

ufc::finite_element * plas3d_finite_element_5::create() const
{
    return new plas3d_finite_element_5();
}


plas3d_finite_element_6::plas3d_finite_element_6() : ufc::finite_element()
{
    // Do nothing
}

plas3d_finite_element_6::~plas3d_finite_element_6()
{
    // Do nothing
}

const char * plas3d_finite_element_6::signature() const
{
    return "VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
}

ufc::shape plas3d_finite_element_6::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t plas3d_finite_element_6::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_6::geometric_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_6::space_dimension() const
{
    return 12;
}

std::size_t plas3d_finite_element_6::value_rank() const
{
    return 1;
}

std::size_t plas3d_finite_element_6::value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 3 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t plas3d_finite_element_6::value_size() const
{
    return 3;
}

std::size_t plas3d_finite_element_6::reference_value_rank() const
{
    return 1;
}

std::size_t plas3d_finite_element_6::reference_value_dimension(std::size_t i) const
{
    static const int return_values[1] = { 3 };
    if (i >= 1)
        return 1;
    return return_values[i];
}

std::size_t plas3d_finite_element_6::reference_value_size() const
{
    return 3;
}

std::size_t plas3d_finite_element_6::degree() const
{
    return 1;
}

const char * plas3d_finite_element_6::family() const
{
    return "Lagrange";
}

void plas3d_finite_element_6::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
    static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
    static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
    static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
    for (std::size_t k = 0; k < num_points * 12 * 3; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[4] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
        basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.75);
        basisvalues1[3] *= std::sqrt(1.25);
        basisvalues1[2] *= std::sqrt(2.5);
        basisvalues1[1] *= std::sqrt(7.5);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 3] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 4 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 5 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 6 + 1] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 7 + 1] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 8 + 2] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 9 + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 10 + 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[12 * 3 * ip + 3 * 11 + 2] += coefficients3[0][r] * basisvalues1[r];
    }
}

void plas3d_finite_element_6::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(3, order);
    std::fill_n(reference_values, num_points * 12 * num_derivatives * 3, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[3][4][4] =
        { { { 0.0, 0.0, 0.0, 0.0 },
            { 6.324555320336758, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0 },
            { 3.162277660168379, 0.0, 0.0, 0.0 },
            { 5.477225575051663, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0 },
            { 3.162277660168379, 0.0, 0.0, 0.0 },
            { 1.8257418583505545, 0.0, 0.0, 0.0 },
            { 5.163977794943224, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
    static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
    static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
    static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
    const std::size_t reference_offset[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
    const std::size_t num_components[12] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[4] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
        basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.75);
        basisvalues1[3] *= std::sqrt(1.25);
        basisvalues1[2] *= std::sqrt(2.5);
        basisvalues1[1] *= std::sqrt(7.5);
        // Loop over all dofs
        for (std::size_t i = 0; i < 12; ++i)
        {
            double derivatives[3] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[12 * (num_derivatives * 3) * ip + num_derivatives * 3 * i + 3 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void plas3d_finite_element_6::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(3, order);
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    std::fill_n(values, num_points * 12 * num_derivatives * 3, 0.0);
    const std::size_t reference_offsets[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
    const std::size_t physical_offsets[12] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[3][3];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 12; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[12 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[12 * (num_derivatives * 3) * ip + num_derivatives * 3 * d + 3 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void plas3d_finite_element_6::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[3] = {};
    double J[9];
    double detJ;
    double K[9];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
        compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[9] + coordinate_dofs[6] + coordinate_dofs[3] - coordinate_dofs[0];
        const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4] - coordinate_dofs[1];
        const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5] - coordinate_dofs[2];
        // Compute subdeterminants
        const double d[9] = { J[4] * J[8] - J[5] * J[7], J[5] * J[6] - J[3] * J[8], J[3] * J[7] - J[4] * J[6], J[2] * J[7] - J[1] * J[8], J[0] * J[8] - J[2] * J[6], J[1] * J[6] - J[0] * J[7], J[1] * J[5] - J[2] * J[4], J[2] * J[3] - J[0] * J[5], J[0] * J[4] - J[1] * J[3] };
        // Get coordinates and map to the reference (FIAT) element
        double Y[3] = { (d[0] * (2.0 * x[0] - C0) + d[3] * (2.0 * x[1] - C1) + d[6] * (2.0 * x[2] - C2)) / detJ, (d[1] * (2.0 * x[0] - C0) + d[4] * (2.0 * x[1] - C1) + d[7] * (2.0 * x[2] - C2)) / detJ, (d[2] * (2.0 * x[0] - C0) + d[5] * (2.0 * x[1] - C1) + d[8] * (2.0 * x[2] - C2)) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 3; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[36];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[36];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 3; ++k)
        values[k] = physical_values[3 * i + k];
}

void plas3d_finite_element_6::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 12; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 3; ++s)
            values[r * 3 + s] = dof_values[s];
    }
}

void plas3d_finite_element_6::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(3, n);
    std::fill_n(values, 3 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[9] + coordinate_dofs[6] + coordinate_dofs[3] - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4] - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5] - coordinate_dofs[2];
    // Compute subdeterminants
    const double d[9] = { J[4] * J[8] - J[5] * J[7], J[5] * J[6] - J[3] * J[8], J[3] * J[7] - J[4] * J[6], J[2] * J[7] - J[1] * J[8], J[0] * J[8] - J[2] * J[6], J[1] * J[6] - J[0] * J[7], J[1] * J[5] - J[2] * J[4], J[2] * J[3] - J[0] * J[5], J[0] * J[4] - J[1] * J[3] };
    // Get coordinates and map to the reference (FIAT) element
    double Y[3] = { (d[0] * (2.0 * x[0] - C0) + d[3] * (2.0 * x[1] - C1) + d[6] * (2.0 * x[2] - C2)) / detJ, (d[1] * (2.0 * x[0] - C0) + d[4] * (2.0 * x[1] - C1) + d[7] * (2.0 * x[2] - C2)) / detJ, (d[2] * (2.0 * x[0] - C0) + d[5] * (2.0 * x[1] - C1) + d[8] * (2.0 * x[2] - C2)) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    // Declare transformation matrix
    double transform[3][3] =
        { { 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[3 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 10:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 11:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void plas3d_finite_element_6::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(3, n);
    // Set values equal to zero.
    std::fill_n(values, 3 * num_derivatives * 12, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[9] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 12; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 3 * num_derivatives; ++s)
            values[3 * num_derivatives * r + s] = dof_values[s];
    }
}

double plas3d_finite_element_6::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[3];
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 6:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 7:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 8:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 9:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 10:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 11:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    }
    return 0.0;
}

void plas3d_finite_element_6::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[3];
    // Declare variable for physical coordinates
    double y[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[8] = vals[2];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[9] = vals[2];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[10] = vals[2];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[11] = vals[2];
}

void plas3d_finite_element_6::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    vertex_values[9] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[4];
    vertex_values[4] = dof_values[5];
    vertex_values[7] = dof_values[6];
    vertex_values[10] = dof_values[7];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[8];
    vertex_values[5] = dof_values[9];
    vertex_values[8] = dof_values[10];
    vertex_values[11] = dof_values[11];
}

void plas3d_finite_element_6::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[3] = coordinate_dofs[3];
    dof_coordinates[3 + 1] = coordinate_dofs[4];
    dof_coordinates[3 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 2] = coordinate_dofs[6];
    dof_coordinates[3 * 2 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 2 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 3] = coordinate_dofs[9];
    dof_coordinates[3 * 3 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 3 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 4] = coordinate_dofs[0];
    dof_coordinates[3 * 4 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 4 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 5] = coordinate_dofs[3];
    dof_coordinates[3 * 5 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 5 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 6] = coordinate_dofs[6];
    dof_coordinates[3 * 6 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 6 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 7] = coordinate_dofs[9];
    dof_coordinates[3 * 7 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 7 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 8] = coordinate_dofs[0];
    dof_coordinates[3 * 8 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 8 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 9] = coordinate_dofs[3];
    dof_coordinates[3 * 9 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 9 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 10] = coordinate_dofs[6];
    dof_coordinates[3 * 10 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 10 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 11] = coordinate_dofs[9];
    dof_coordinates[3 * 11 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 11 + 2] = coordinate_dofs[11];
}

void plas3d_finite_element_6::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[36] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 36, reference_dof_coordinates);
}

std::size_t plas3d_finite_element_6::num_sub_elements() const
{
    return 3;
}

ufc::finite_element * plas3d_finite_element_6::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_5();
    case 2:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::finite_element * plas3d_finite_element_6::create() const
{
    return new plas3d_finite_element_6();
}


plas3d_finite_element_7::plas3d_finite_element_7() : ufc::finite_element()
{
    // Do nothing
}

plas3d_finite_element_7::~plas3d_finite_element_7()
{
    // Do nothing
}

const char * plas3d_finite_element_7::signature() const
{
    return "TensorElement(FiniteElement('Lagrange', tetrahedron, 1), shape=(3, 3), symmetry={})";
}

ufc::shape plas3d_finite_element_7::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

std::size_t plas3d_finite_element_7::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_7::geometric_dimension() const
{
    return 3;
}

std::size_t plas3d_finite_element_7::space_dimension() const
{
    return 36;
}

std::size_t plas3d_finite_element_7::value_rank() const
{
    return 2;
}

std::size_t plas3d_finite_element_7::value_dimension(std::size_t i) const
{
    static const int return_values[2] = { 3, 3 };
    if (i >= 2)
        return 1;
    return return_values[i];
}

std::size_t plas3d_finite_element_7::value_size() const
{
    return 9;
}

std::size_t plas3d_finite_element_7::reference_value_rank() const
{
    return 2;
}

std::size_t plas3d_finite_element_7::reference_value_dimension(std::size_t i) const
{
    static const int return_values[2] = { 3, 3 };
    if (i >= 2)
        return 1;
    return return_values[i];
}

std::size_t plas3d_finite_element_7::reference_value_size() const
{
    return 9;
}

std::size_t plas3d_finite_element_7::degree() const
{
    return 1;
}

const char * plas3d_finite_element_7::family() const
{
    return "Lagrange";
}

void plas3d_finite_element_7::evaluate_reference_basis(double * reference_values,
                                             std::size_t num_points,
                                             const double * X) const
{
    static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
    static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
    static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
    static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
    for (std::size_t k = 0; k < num_points * 36 * 9; ++k)
        reference_values[k] = 0.0;
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[4] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
        basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.75);
        basisvalues1[3] *= std::sqrt(1.25);
        basisvalues1[2] *= std::sqrt(2.5);
        basisvalues1[1] *= std::sqrt(7.5);
        // Accumulate products of coefficients and basisvalues
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 3] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 4 + 1] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 5 + 1] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 6 + 1] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 7 + 1] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 8 + 2] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 9 + 2] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 10 + 2] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 11 + 2] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 12 + 3] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 13 + 3] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 14 + 3] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 15 + 3] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 16 + 4] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 17 + 4] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 18 + 4] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 19 + 4] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 20 + 5] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 21 + 5] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 22 + 5] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 23 + 5] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 24 + 6] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 25 + 6] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 26 + 6] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 27 + 6] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 28 + 7] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 29 + 7] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 30 + 7] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 31 + 7] += coefficients3[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 32 + 8] += coefficients0[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 33 + 8] += coefficients1[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 34 + 8] += coefficients2[0][r] * basisvalues1[r];
        for (std::size_t r = 0; r < 4; ++r)
            reference_values[36 * 9 * ip + 9 * 35 + 8] += coefficients3[0][r] * basisvalues1[r];
    }
}

void plas3d_finite_element_7::evaluate_reference_basis_derivatives(double * reference_values,
                                                         std::size_t order,
                                                         std::size_t num_points,
                                                         const double * X) const
{
    if (order == 0)
    {
        evaluate_reference_basis(reference_values, num_points, X);
        return;
    }
    const std::size_t num_derivatives = std::pow(3, order);
    std::fill_n(reference_values, num_points * 36 * num_derivatives * 9, 0.0);
    if (order > 1)
        return;
    // Tables of derivatives of the polynomial base (transpose).
    alignas(32) static const double dmats0[3][4][4] =
        { { { 0.0, 0.0, 0.0, 0.0 },
            { 6.324555320336758, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0 },
            { 3.162277660168379, 0.0, 0.0, 0.0 },
            { 5.477225575051663, 0.0, 0.0, 0.0 },
            { 0.0, 0.0, 0.0, 0.0 } },
          { { 0.0, 0.0, 0.0, 0.0 },
            { 3.162277660168379, 0.0, 0.0, 0.0 },
            { 1.8257418583505545, 0.0, 0.0, 0.0 },
            { 5.163977794943224, 0.0, 0.0, 0.0 } } };
    static const double coefficients0[1][4] = { { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 } };
    static const double coefficients1[1][4] = { { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 } };
    static const double coefficients2[1][4] = { { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 } };
    static const double coefficients3[1][4] = { { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 } };
    const std::size_t reference_offset[36] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8 };
    const std::size_t num_components[36] = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Map from UFC reference coordinate X to FIAT reference coordinate Y
        const double Y[3] = { 2.0 * X[ip * 3] - 1.0, 2.0 * X[ip * 3 + 1] - 1.0, 2.0 * X[ip * 3 + 2] - 1.0 };
        // Compute basisvalues for each relevant embedded degree
        double basisvalues1[4] = {};
        basisvalues1[0] = 1.0;
        const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
        basisvalues1[1] = tmp1_1;
        basisvalues1[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues1[0];
        basisvalues1[3] = (2.0 * Y[2] + 1.0) * basisvalues1[0];
        basisvalues1[0] *= std::sqrt(0.75);
        basisvalues1[3] *= std::sqrt(1.25);
        basisvalues1[2] *= std::sqrt(2.5);
        basisvalues1[1] *= std::sqrt(7.5);
        // Loop over all dofs
        for (std::size_t i = 0; i < 36; ++i)
        {
            double derivatives[3] = {};
            switch (i)
            {
            case 0:
                // Compute reference derivatives for dof 0.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 1:
                // Compute reference derivatives for dof 1.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 2:
                // Compute reference derivatives for dof 2.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 3:
                // Compute reference derivatives for dof 3.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 4:
                // Compute reference derivatives for dof 4.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 5:
                // Compute reference derivatives for dof 5.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 6:
                // Compute reference derivatives for dof 6.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 7:
                // Compute reference derivatives for dof 7.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 8:
                // Compute reference derivatives for dof 8.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 9:
                // Compute reference derivatives for dof 9.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 10:
                // Compute reference derivatives for dof 10.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 11:
                // Compute reference derivatives for dof 11.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 12:
                // Compute reference derivatives for dof 12.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 13:
                // Compute reference derivatives for dof 13.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 14:
                // Compute reference derivatives for dof 14.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 15:
                // Compute reference derivatives for dof 15.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 16:
                // Compute reference derivatives for dof 16.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 17:
                // Compute reference derivatives for dof 17.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 18:
                // Compute reference derivatives for dof 18.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 19:
                // Compute reference derivatives for dof 19.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 20:
                // Compute reference derivatives for dof 20.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 21:
                // Compute reference derivatives for dof 21.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 22:
                // Compute reference derivatives for dof 22.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 23:
                // Compute reference derivatives for dof 23.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 24:
                // Compute reference derivatives for dof 24.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 25:
                // Compute reference derivatives for dof 25.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 26:
                // Compute reference derivatives for dof 26.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 27:
                // Compute reference derivatives for dof 27.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 28:
                // Compute reference derivatives for dof 28.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 29:
                // Compute reference derivatives for dof 29.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 30:
                // Compute reference derivatives for dof 30.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 31:
                // Compute reference derivatives for dof 31.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            case 32:
                // Compute reference derivatives for dof 32.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients0[0][s] * aux[s];
                }
                break;
            case 33:
                // Compute reference derivatives for dof 33.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients1[0][s] * aux[s];
                }
                break;
            case 34:
                // Compute reference derivatives for dof 34.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients2[0][s] * aux[s];
                }
                break;
            case 35:
                // Compute reference derivatives for dof 35.
                for (std::size_t r = 0; r < num_derivatives; ++r)
                {
                    double aux[4] = {};
                    // Declare derivative matrix (of polynomial basis).
                    double dmats[4][4] = {};
                    // Initialize dmats.
                    std::size_t comb = combinations[order - 1][r][0];
                    std::copy_n(&dmats0[comb][0][0], 16, &dmats[0][0]);
                    // Looping derivative order to generate dmats.
                    for (std::size_t s = 1; s < order; ++s)
                    {
                        // Store previous dmats matrix.
                        double dmats_old[4][4];
                        std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                        // Resetting dmats.
                        std::fill_n(&dmats[0][0], 16, 0.0);
                        // Update dmats using an inner product.
                        comb = combinations[order - 1][r][s];
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats0[comb][t][tu] * dmats_old[tu][u];
                    }
                    for (std::size_t s = 0; s < 4; ++s)
                        for (std::size_t t = 0; t < 4; ++t)
                            aux[s] += dmats[s][t] * basisvalues1[t];
                    derivatives[r] = 0.0;
                    for (std::size_t s = 0; s < 4; ++s)
                        derivatives[r] += coefficients3[0][s] * aux[s];
                }
                break;
            }
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t c = 0; c < num_components[i]; ++c)
                    reference_values[36 * (num_derivatives * 9) * ip + num_derivatives * 9 * i + 9 * r + (reference_offset[i] + c)] = derivatives[num_derivatives * c + r];
        }
    }
}

void plas3d_finite_element_7::transform_reference_basis_derivatives(double * values,
                                                          std::size_t order,
                                                          std::size_t num_points,
                                                          const double * reference_values,
                                                          const double * X,
                                                          const double * J,
                                                          const double * detJ,
                                                          const double * K,
                                                          int cell_orientation) const
{
    const std::size_t num_derivatives = std::pow(3, order);
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    std::fill_n(values, num_points * 36 * num_derivatives * 9, 0.0);
    const std::size_t reference_offsets[36] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8 };
    const std::size_t physical_offsets[36] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8 };
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        double transform[3][3];
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                transform[r][s] = 1.0;
        for (std::size_t r = 0; r < num_derivatives; ++r)
            for (std::size_t s = 0; s < num_derivatives; ++s)
                for (std::size_t k = 0; k < order; ++k)
                    transform[r][s] *= K[3 * 3 * ip + 3 * combinations[order - 1][s][k] + combinations[order - 1][r][k]];
        for (std::size_t d = 0; d < 36; ++d)
        {
            for (std::size_t s = 0; s < num_derivatives; ++s)
            {
                for (std::size_t i = 0; i < 1; ++i)
                {
                    // Using affine transform to map values back to the physical element.
                    const double mapped_value = reference_values[36 * (num_derivatives * 9) * ip + num_derivatives * 9 * d + 9 * s + reference_offsets[d]];
                    // Mapping derivatives back to the physical element
                    for (std::size_t r = 0; r < num_derivatives; ++r)
                        values[36 * (num_derivatives * 9) * ip + num_derivatives * 9 * d + 9 * r + (physical_offsets[d] + i)] += transform[r][s] * mapped_value;
                }
            }
        }
    }
}

void plas3d_finite_element_7::evaluate_basis(std::size_t i,
                                   double * values,
                                   const double * x,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    double X[3] = {};
    double J[9];
    double detJ;
    double K[9];
    if (cm)
    {
        cm->compute_reference_geometry(X, J, &detJ, K, 1, x, coordinate_dofs, cell_orientation);
    }
    else
    {
        compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
        compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
        // Compute constants
        const double C0 = coordinate_dofs[9] + coordinate_dofs[6] + coordinate_dofs[3] - coordinate_dofs[0];
        const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4] - coordinate_dofs[1];
        const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5] - coordinate_dofs[2];
        // Compute subdeterminants
        const double d[9] = { J[4] * J[8] - J[5] * J[7], J[5] * J[6] - J[3] * J[8], J[3] * J[7] - J[4] * J[6], J[2] * J[7] - J[1] * J[8], J[0] * J[8] - J[2] * J[6], J[1] * J[6] - J[0] * J[7], J[1] * J[5] - J[2] * J[4], J[2] * J[3] - J[0] * J[5], J[0] * J[4] - J[1] * J[3] };
        // Get coordinates and map to the reference (FIAT) element
        double Y[3] = { (d[0] * (2.0 * x[0] - C0) + d[3] * (2.0 * x[1] - C1) + d[6] * (2.0 * x[2] - C2)) / detJ, (d[1] * (2.0 * x[0] - C0) + d[4] * (2.0 * x[1] - C1) + d[7] * (2.0 * x[2] - C2)) / detJ, (d[2] * (2.0 * x[0] - C0) + d[5] * (2.0 * x[1] - C1) + d[8] * (2.0 * x[2] - C2)) / detJ };
        // Map to FFC reference coordinate
        for (std::size_t k = 0; k < 3; ++k)
            X[k] = (Y[k] + 1.0) / 2.0;
    }
    // Evaluate basis on reference element
    double ref_values[324];
    evaluate_reference_basis(ref_values, 1, X);
    // Push forward
    double physical_values[324];
    transform_reference_basis_derivatives(physical_values, 0, 1, ref_values, X, J, &detJ, K, cell_orientation);
    for (std::size_t k = 0; k < 9; ++k)
        values[k] = physical_values[9 * i + k];
}

void plas3d_finite_element_7::evaluate_basis_all(double * values,
                                       const double * x,
                                       const double * coordinate_dofs,
                                       int cell_orientation,
                                       const ufc::coordinate_mapping * cm
                                       ) const
{
    // Helper variable to hold values of a single dof.
    double dof_values[9] = {};
    // Loop dofs and call evaluate_basis
    for (std::size_t r = 0; r < 36; ++r)
    {
        evaluate_basis(r, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 9; ++s)
            values[r * 9 + s] = dof_values[s];
    }
}

void plas3d_finite_element_7::evaluate_basis_derivatives(std::size_t i,
                                               std::size_t n,
                                               double * values,
                                               const double * x,
                                               const double * coordinate_dofs,
                                               int cell_orientation,
                                               const ufc::coordinate_mapping * cm
                                               ) const
{
    std::size_t num_derivatives = std::pow(3, n);
    std::fill_n(values, 9 * num_derivatives, 0.0);
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis(i, values, x, coordinate_dofs, cell_orientation);
        return;
    }
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    // Compute Inverse Jacobian and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    // Compute constants
    const double C0 = coordinate_dofs[9] + coordinate_dofs[6] + coordinate_dofs[3] - coordinate_dofs[0];
    const double C1 = coordinate_dofs[10] + coordinate_dofs[7] + coordinate_dofs[4] - coordinate_dofs[1];
    const double C2 = coordinate_dofs[11] + coordinate_dofs[8] + coordinate_dofs[5] - coordinate_dofs[2];
    // Compute subdeterminants
    const double d[9] = { J[4] * J[8] - J[5] * J[7], J[5] * J[6] - J[3] * J[8], J[3] * J[7] - J[4] * J[6], J[2] * J[7] - J[1] * J[8], J[0] * J[8] - J[2] * J[6], J[1] * J[6] - J[0] * J[7], J[1] * J[5] - J[2] * J[4], J[2] * J[3] - J[0] * J[5], J[0] * J[4] - J[1] * J[3] };
    // Get coordinates and map to the reference (FIAT) element
    double Y[3] = { (d[0] * (2.0 * x[0] - C0) + d[3] * (2.0 * x[1] - C1) + d[6] * (2.0 * x[2] - C2)) / detJ, (d[1] * (2.0 * x[0] - C0) + d[4] * (2.0 * x[1] - C1) + d[7] * (2.0 * x[2] - C2)) / detJ, (d[2] * (2.0 * x[0] - C0) + d[5] * (2.0 * x[1] - C1) + d[8] * (2.0 * x[2] - C2)) / detJ };
    // Precomputed combinations
    const std::size_t combinations[1][3][1] =
        { { { 0 },
            { 1 },
            { 2 } } };
    // Declare transformation matrix
    double transform[3][3] =
        { { 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0 },
          { 1.0, 1.0, 1.0 } };
    // Construct transformation matrix
    for (std::size_t row = 0; row < num_derivatives; ++row)
        for (std::size_t col = 0; col < num_derivatives; ++col)
            for (std::size_t k = 0; k < n; ++k)
                transform[row][col] *= K[3 * combinations[n - 1][col][k] + combinations[n - 1][row][k]];
    switch (i)
    {
    case 0:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 1:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 2:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 3:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[r] += transform[r][s] * derivatives[s];
        }
        break;
    case 4:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 5:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 6:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 7:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 8:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 9:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 10:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 11:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[2 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 12:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 13:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 14:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 15:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[3 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 16:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 17:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 18:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 19:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[4 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 20:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 21:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 22:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 23:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[5 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 24:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 25:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 26:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 27:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[6 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 28:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[7 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 29:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[7 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 30:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[7 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 31:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[7 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 32:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.288675134594813, -0.18257418583505536, -0.10540925533894598, -0.07453559924999298 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[8 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 33:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.28867513459481287, 0.18257418583505536, -0.10540925533894596, -0.07453559924999296 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[8 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 34:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.21081851067789195, -0.07453559924999299 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[8 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    case 35:
        {
            double basisvalues[4] = {};
            basisvalues[0] = 1.0;
            const double tmp1_1 = 0.5 * (2.0 + 2.0 * Y[0] + Y[1] + Y[2]);
            basisvalues[1] = tmp1_1;
            basisvalues[2] = 0.5 * (2.0 + 3.0 * Y[1] + Y[2]) * basisvalues[0];
            basisvalues[3] = (2.0 * Y[2] + 1.0) * basisvalues[0];
            basisvalues[0] *= std::sqrt(0.75);
            basisvalues[3] *= std::sqrt(1.25);
            basisvalues[2] *= std::sqrt(2.5);
            basisvalues[1] *= std::sqrt(7.5);
            // Table(s) of coefficients
            static const double coefficients0[4] = { 0.2886751345948129, 0.0, 0.0, 0.22360679774997896 };
            // Tables of derivatives of the polynomial base (transpose).
            static const double dmats0[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 6.324555320336758, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats1[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 5.477225575051663, 0.0, 0.0, 0.0 },
                  { 0.0, 0.0, 0.0, 0.0 } };
            static const double dmats2[4][4] =
                { { 0.0, 0.0, 0.0, 0.0 },
                  { 3.162277660168379, 0.0, 0.0, 0.0 },
                  { 1.8257418583505545, 0.0, 0.0, 0.0 },
                  { 5.163977794943224, 0.0, 0.0, 0.0 } };
            // Compute reference derivatives.
            // Declare array of derivatives on FIAT element.
            double derivatives[3] = {};
            // Declare derivative matrix (of polynomial basis).
            double dmats[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Declare (auxiliary) derivative matrix (of polynomial basis).
            double dmats_old[4][4] =
                { { 1.0, 0.0, 0.0, 0.0 },
                  { 0.0, 1.0, 0.0, 0.0 },
                  { 0.0, 0.0, 1.0, 0.0 },
                  { 0.0, 0.0, 0.0, 1.0 } };
            // Loop possible derivatives.
            for (std::size_t r = 0; r < num_derivatives; ++r)
            {
                // Reset dmats to identity
                std::fill_n(&dmats[0][0], 16, 0.0);
                for (std::size_t t = 0; t < 4; ++t)
                    dmats[t][t] = 1.0;
                // Looping derivative order to generate dmats.
                for (std::size_t s = 0; s < n; ++s)
                {
                    std::copy_n(&dmats[0][0], 16, &dmats_old[0][0]);
                    std::fill_n(&dmats[0][0], 16, 0.0);
                    // Update dmats using an inner product.
                    // _dmats_product(shape_dmats, comb[r][s], 0)
                    if (combinations[n - 1][r][s] == 0)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats0[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 1)
                    if (combinations[n - 1][r][s] == 1)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats1[t][tu];
                    }
                    // _dmats_product(shape_dmats, comb[r][s], 2)
                    if (combinations[n - 1][r][s] == 2)
                    {
                        for (std::size_t t = 0; t < 4; ++t)
                            for (std::size_t u = 0; u < 4; ++u)
                                for (std::size_t tu = 0; tu < 4; ++tu)
                                    dmats[t][u] += dmats_old[tu][u] * dmats2[t][tu];
                    }
                }
                for (std::size_t s = 0; s < 4; ++s)
                    for (std::size_t t = 0; t < 4; ++t)
                        derivatives[r] += coefficients0[s] * dmats[s][t] * basisvalues[t];
            }
            // Transform derivatives back to physical element
            for (std::size_t r = 0; r < num_derivatives; ++r)
                for (std::size_t s = 0; s < num_derivatives; ++s)
                    values[8 * num_derivatives + r] += transform[r][s] * derivatives[s];
        }
        break;
    }
}

void plas3d_finite_element_7::evaluate_basis_derivatives_all(std::size_t n,
                                                   double * values,
                                                   const double * x,
                                                   const double * coordinate_dofs,
                                                   int cell_orientation,
                                                   const ufc::coordinate_mapping * cm
                                                   ) const
{
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
        evaluate_basis_all(values, x, coordinate_dofs, cell_orientation);
        return;
    }
    unsigned int num_derivatives = std::pow(3, n);
    // Set values equal to zero.
    std::fill_n(values, 9 * num_derivatives * 36, 0.0);
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
        return;
    // Helper variable to hold values of a single dof.
    double dof_values[27] = {};
    // Loop dofs and call evaluate_basis_derivatives.
    for (std::size_t r = 0; r < 36; ++r)
    {
        evaluate_basis_derivatives(r, n, dof_values, x, coordinate_dofs, cell_orientation);
        for (std::size_t s = 0; s < 9 * num_derivatives; ++s)
            values[9 * num_derivatives * r + s] = dof_values[s];
    }
}

double plas3d_finite_element_7::evaluate_dof(std::size_t i,
                                   const ufc::function& f,
                                   const double * coordinate_dofs,
                                   int cell_orientation,
                                   const ufc::cell& c,
                                   const ufc::coordinate_mapping * cm
                                   ) const
{
    // Declare variables for result of evaluation
    double vals[9];
    // Declare variable for physical coordinates
    double y[3];
    switch (i)
    {
    case 0:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 1:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 2:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 3:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[0];
        }
        break;
    case 4:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 5:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 6:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 7:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[1];
        }
        break;
    case 8:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 9:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 10:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 11:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[2];
        }
        break;
    case 12:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 13:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 14:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 15:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[3];
        }
        break;
    case 16:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 17:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 18:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 19:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[4];
        }
        break;
    case 20:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 21:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 22:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 23:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[5];
        }
        break;
    case 24:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 25:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 26:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 27:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[6];
        }
        break;
    case 28:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 29:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 30:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 31:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[7];
        }
        break;
    case 32:
        {
            y[0] = coordinate_dofs[0];
            y[1] = coordinate_dofs[1];
            y[2] = coordinate_dofs[2];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 33:
        {
            y[0] = coordinate_dofs[3];
            y[1] = coordinate_dofs[4];
            y[2] = coordinate_dofs[5];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 34:
        {
            y[0] = coordinate_dofs[6];
            y[1] = coordinate_dofs[7];
            y[2] = coordinate_dofs[8];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    case 35:
        {
            y[0] = coordinate_dofs[9];
            y[1] = coordinate_dofs[10];
            y[2] = coordinate_dofs[11];
            f.evaluate(vals, y, c);
            return vals[8];
        }
        break;
    }
    return 0.0;
}

void plas3d_finite_element_7::evaluate_dofs(double * values,
                                  const ufc::function& f,
                                  const double * coordinate_dofs,
                                  int cell_orientation,
                                  const ufc::cell& c,
                                  const ufc::coordinate_mapping * cm
                                  ) const
{
    // Declare variables for result of evaluation
    double vals[9];
    // Declare variable for physical coordinates
    double y[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[4] = vals[1];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[5] = vals[1];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[8] = vals[2];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[9] = vals[2];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[10] = vals[2];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[11] = vals[2];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[12] = vals[3];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[13] = vals[3];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[14] = vals[3];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[15] = vals[3];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[16] = vals[4];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[17] = vals[4];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[18] = vals[4];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[19] = vals[4];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[20] = vals[5];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[21] = vals[5];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[22] = vals[5];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[23] = vals[5];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[24] = vals[6];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[25] = vals[6];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[26] = vals[6];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[27] = vals[6];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[28] = vals[7];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[29] = vals[7];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[30] = vals[7];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[31] = vals[7];
    y[0] = coordinate_dofs[0];
    y[1] = coordinate_dofs[1];
    y[2] = coordinate_dofs[2];
    f.evaluate(vals, y, c);
    values[32] = vals[8];
    y[0] = coordinate_dofs[3];
    y[1] = coordinate_dofs[4];
    y[2] = coordinate_dofs[5];
    f.evaluate(vals, y, c);
    values[33] = vals[8];
    y[0] = coordinate_dofs[6];
    y[1] = coordinate_dofs[7];
    y[2] = coordinate_dofs[8];
    f.evaluate(vals, y, c);
    values[34] = vals[8];
    y[0] = coordinate_dofs[9];
    y[1] = coordinate_dofs[10];
    y[2] = coordinate_dofs[11];
    f.evaluate(vals, y, c);
    values[35] = vals[8];
}

void plas3d_finite_element_7::interpolate_vertex_values(double * vertex_values,
                                              const double * dof_values,
                                              const double * coordinate_dofs,
                                              int cell_orientation,
                                              const ufc::coordinate_mapping * cm
                                              ) const
{
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[9] = dof_values[1];
    vertex_values[18] = dof_values[2];
    vertex_values[27] = dof_values[3];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[4];
    vertex_values[10] = dof_values[5];
    vertex_values[19] = dof_values[6];
    vertex_values[28] = dof_values[7];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[8];
    vertex_values[11] = dof_values[9];
    vertex_values[20] = dof_values[10];
    vertex_values[29] = dof_values[11];
    // Evaluate function and change variables
    vertex_values[3] = dof_values[12];
    vertex_values[12] = dof_values[13];
    vertex_values[21] = dof_values[14];
    vertex_values[30] = dof_values[15];
    // Evaluate function and change variables
    vertex_values[4] = dof_values[16];
    vertex_values[13] = dof_values[17];
    vertex_values[22] = dof_values[18];
    vertex_values[31] = dof_values[19];
    // Evaluate function and change variables
    vertex_values[5] = dof_values[20];
    vertex_values[14] = dof_values[21];
    vertex_values[23] = dof_values[22];
    vertex_values[32] = dof_values[23];
    // Evaluate function and change variables
    vertex_values[6] = dof_values[24];
    vertex_values[15] = dof_values[25];
    vertex_values[24] = dof_values[26];
    vertex_values[33] = dof_values[27];
    // Evaluate function and change variables
    vertex_values[7] = dof_values[28];
    vertex_values[16] = dof_values[29];
    vertex_values[25] = dof_values[30];
    vertex_values[34] = dof_values[31];
    // Evaluate function and change variables
    vertex_values[8] = dof_values[32];
    vertex_values[17] = dof_values[33];
    vertex_values[26] = dof_values[34];
    vertex_values[35] = dof_values[35];
}

void plas3d_finite_element_7::tabulate_dof_coordinates(double * dof_coordinates,
                                             const double * coordinate_dofs,
                                             const ufc::coordinate_mapping * cm
                                             ) const
{
    dof_coordinates[0] = coordinate_dofs[0];
    dof_coordinates[1] = coordinate_dofs[1];
    dof_coordinates[2] = coordinate_dofs[2];
    dof_coordinates[3] = coordinate_dofs[3];
    dof_coordinates[3 + 1] = coordinate_dofs[4];
    dof_coordinates[3 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 2] = coordinate_dofs[6];
    dof_coordinates[3 * 2 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 2 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 3] = coordinate_dofs[9];
    dof_coordinates[3 * 3 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 3 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 4] = coordinate_dofs[0];
    dof_coordinates[3 * 4 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 4 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 5] = coordinate_dofs[3];
    dof_coordinates[3 * 5 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 5 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 6] = coordinate_dofs[6];
    dof_coordinates[3 * 6 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 6 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 7] = coordinate_dofs[9];
    dof_coordinates[3 * 7 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 7 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 8] = coordinate_dofs[0];
    dof_coordinates[3 * 8 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 8 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 9] = coordinate_dofs[3];
    dof_coordinates[3 * 9 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 9 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 10] = coordinate_dofs[6];
    dof_coordinates[3 * 10 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 10 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 11] = coordinate_dofs[9];
    dof_coordinates[3 * 11 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 11 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 12] = coordinate_dofs[0];
    dof_coordinates[3 * 12 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 12 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 13] = coordinate_dofs[3];
    dof_coordinates[3 * 13 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 13 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 14] = coordinate_dofs[6];
    dof_coordinates[3 * 14 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 14 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 15] = coordinate_dofs[9];
    dof_coordinates[3 * 15 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 15 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 16] = coordinate_dofs[0];
    dof_coordinates[3 * 16 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 16 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 17] = coordinate_dofs[3];
    dof_coordinates[3 * 17 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 17 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 18] = coordinate_dofs[6];
    dof_coordinates[3 * 18 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 18 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 19] = coordinate_dofs[9];
    dof_coordinates[3 * 19 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 19 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 20] = coordinate_dofs[0];
    dof_coordinates[3 * 20 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 20 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 21] = coordinate_dofs[3];
    dof_coordinates[3 * 21 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 21 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 22] = coordinate_dofs[6];
    dof_coordinates[3 * 22 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 22 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 23] = coordinate_dofs[9];
    dof_coordinates[3 * 23 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 23 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 24] = coordinate_dofs[0];
    dof_coordinates[3 * 24 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 24 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 25] = coordinate_dofs[3];
    dof_coordinates[3 * 25 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 25 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 26] = coordinate_dofs[6];
    dof_coordinates[3 * 26 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 26 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 27] = coordinate_dofs[9];
    dof_coordinates[3 * 27 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 27 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 28] = coordinate_dofs[0];
    dof_coordinates[3 * 28 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 28 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 29] = coordinate_dofs[3];
    dof_coordinates[3 * 29 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 29 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 30] = coordinate_dofs[6];
    dof_coordinates[3 * 30 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 30 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 31] = coordinate_dofs[9];
    dof_coordinates[3 * 31 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 31 + 2] = coordinate_dofs[11];
    dof_coordinates[3 * 32] = coordinate_dofs[0];
    dof_coordinates[3 * 32 + 1] = coordinate_dofs[1];
    dof_coordinates[3 * 32 + 2] = coordinate_dofs[2];
    dof_coordinates[3 * 33] = coordinate_dofs[3];
    dof_coordinates[3 * 33 + 1] = coordinate_dofs[4];
    dof_coordinates[3 * 33 + 2] = coordinate_dofs[5];
    dof_coordinates[3 * 34] = coordinate_dofs[6];
    dof_coordinates[3 * 34 + 1] = coordinate_dofs[7];
    dof_coordinates[3 * 34 + 2] = coordinate_dofs[8];
    dof_coordinates[3 * 35] = coordinate_dofs[9];
    dof_coordinates[3 * 35 + 1] = coordinate_dofs[10];
    dof_coordinates[3 * 35 + 2] = coordinate_dofs[11];
}

void plas3d_finite_element_7::tabulate_reference_dof_coordinates(double * reference_dof_coordinates) const
{
    static const double dof_X[108] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 };
    std::copy_n(dof_X, 108, reference_dof_coordinates);
}

std::size_t plas3d_finite_element_7::num_sub_elements() const
{
    return 9;
}

ufc::finite_element * plas3d_finite_element_7::create_sub_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_5();
    case 2:
        return new plas3d_finite_element_5();
    case 3:
        return new plas3d_finite_element_5();
    case 4:
        return new plas3d_finite_element_5();
    case 5:
        return new plas3d_finite_element_5();
    case 6:
        return new plas3d_finite_element_5();
    case 7:
        return new plas3d_finite_element_5();
    case 8:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::finite_element * plas3d_finite_element_7::create() const
{
    return new plas3d_finite_element_7();
}


plas3d_dofmap_0::plas3d_dofmap_0() : ufc::dofmap()
{
    // Do nothing
}

plas3d_dofmap_0::~plas3d_dofmap_0()
{
    // Do nothing
}

const char * plas3d_dofmap_0::signature() const
{
    return "FFC dofmap for FiniteElement('Quadrature', tetrahedron, 3, quad_scheme='default')";
}

bool plas3d_dofmap_0::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { false, false, false, true };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t plas3d_dofmap_0::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_dofmap_0::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 5 * num_global_entities[3];
}

std::size_t plas3d_dofmap_0::num_global_support_dofs() const
{
    return 0;
}

std::size_t plas3d_dofmap_0::num_element_support_dofs() const
{
    return 5;
}

std::size_t plas3d_dofmap_0::num_element_dofs() const
{
    return 5;
}

std::size_t plas3d_dofmap_0::num_facet_dofs() const
{
    return 0;
}

std::size_t plas3d_dofmap_0::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 5 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t plas3d_dofmap_0::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 5 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void plas3d_dofmap_0::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = 5 * entity_indices[3][0];
    dofs[1] = 5 * entity_indices[3][0] + 1;
    dofs[2] = 5 * entity_indices[3][0] + 2;
    dofs[3] = 5 * entity_indices[3][0] + 3;
    dofs[4] = 5 * entity_indices[3][0] + 4;
}

void plas3d_dofmap_0::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    // Do nothing
}

void plas3d_dofmap_0::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            break;
        }
        break;
    }
}

void plas3d_dofmap_0::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        case 4:
            break;
        case 5:
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            break;
        }
        break;
    }
}

std::size_t plas3d_dofmap_0::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * plas3d_dofmap_0::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * plas3d_dofmap_0::create() const
{
    return new plas3d_dofmap_0();
}


plas3d_dofmap_1::plas3d_dofmap_1() : ufc::dofmap()
{
    // Do nothing
}

plas3d_dofmap_1::~plas3d_dofmap_1()
{
    // Do nothing
}

const char * plas3d_dofmap_1::signature() const
{
    return "FFC dofmap for VectorElement(FiniteElement('Quadrature', tetrahedron, 3, quad_scheme='default'), dim=6)";
}

bool plas3d_dofmap_1::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { false, false, false, true };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t plas3d_dofmap_1::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_dofmap_1::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 30 * num_global_entities[3];
}

std::size_t plas3d_dofmap_1::num_global_support_dofs() const
{
    return 0;
}

std::size_t plas3d_dofmap_1::num_element_support_dofs() const
{
    return 30;
}

std::size_t plas3d_dofmap_1::num_element_dofs() const
{
    return 30;
}

std::size_t plas3d_dofmap_1::num_facet_dofs() const
{
    return 0;
}

std::size_t plas3d_dofmap_1::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 30 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t plas3d_dofmap_1::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 30 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void plas3d_dofmap_1::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + 5 * entity_indices[3][0];
    dofs[1] = offset + 5 * entity_indices[3][0] + 1;
    dofs[2] = offset + 5 * entity_indices[3][0] + 2;
    dofs[3] = offset + 5 * entity_indices[3][0] + 3;
    dofs[4] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[5] = offset + 5 * entity_indices[3][0];
    dofs[6] = offset + 5 * entity_indices[3][0] + 1;
    dofs[7] = offset + 5 * entity_indices[3][0] + 2;
    dofs[8] = offset + 5 * entity_indices[3][0] + 3;
    dofs[9] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[10] = offset + 5 * entity_indices[3][0];
    dofs[11] = offset + 5 * entity_indices[3][0] + 1;
    dofs[12] = offset + 5 * entity_indices[3][0] + 2;
    dofs[13] = offset + 5 * entity_indices[3][0] + 3;
    dofs[14] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[15] = offset + 5 * entity_indices[3][0];
    dofs[16] = offset + 5 * entity_indices[3][0] + 1;
    dofs[17] = offset + 5 * entity_indices[3][0] + 2;
    dofs[18] = offset + 5 * entity_indices[3][0] + 3;
    dofs[19] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[20] = offset + 5 * entity_indices[3][0];
    dofs[21] = offset + 5 * entity_indices[3][0] + 1;
    dofs[22] = offset + 5 * entity_indices[3][0] + 2;
    dofs[23] = offset + 5 * entity_indices[3][0] + 3;
    dofs[24] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[25] = offset + 5 * entity_indices[3][0];
    dofs[26] = offset + 5 * entity_indices[3][0] + 1;
    dofs[27] = offset + 5 * entity_indices[3][0] + 2;
    dofs[28] = offset + 5 * entity_indices[3][0] + 3;
    dofs[29] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
}

void plas3d_dofmap_1::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    // Do nothing
}

void plas3d_dofmap_1::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            dofs[19] = 19;
            dofs[20] = 20;
            dofs[21] = 21;
            dofs[22] = 22;
            dofs[23] = 23;
            dofs[24] = 24;
            dofs[25] = 25;
            dofs[26] = 26;
            dofs[27] = 27;
            dofs[28] = 28;
            dofs[29] = 29;
            break;
        }
        break;
    }
}

void plas3d_dofmap_1::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        case 4:
            break;
        case 5:
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            dofs[19] = 19;
            dofs[20] = 20;
            dofs[21] = 21;
            dofs[22] = 22;
            dofs[23] = 23;
            dofs[24] = 24;
            dofs[25] = 25;
            dofs[26] = 26;
            dofs[27] = 27;
            dofs[28] = 28;
            dofs[29] = 29;
            break;
        }
        break;
    }
}

std::size_t plas3d_dofmap_1::num_sub_dofmaps() const
{
    return 6;
}

ufc::dofmap * plas3d_dofmap_1::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_0();
    case 1:
        return new plas3d_dofmap_0();
    case 2:
        return new plas3d_dofmap_0();
    case 3:
        return new plas3d_dofmap_0();
    case 4:
        return new plas3d_dofmap_0();
    case 5:
        return new plas3d_dofmap_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_dofmap_1::create() const
{
    return new plas3d_dofmap_1();
}


plas3d_dofmap_2::plas3d_dofmap_2() : ufc::dofmap()
{
    // Do nothing
}

plas3d_dofmap_2::~plas3d_dofmap_2()
{
    // Do nothing
}

const char * plas3d_dofmap_2::signature() const
{
    return "FFC dofmap for VectorElement(FiniteElement('Quadrature', tetrahedron, 3, quad_scheme='default'), dim=36)";
}

bool plas3d_dofmap_2::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { false, false, false, true };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t plas3d_dofmap_2::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_dofmap_2::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 180 * num_global_entities[3];
}

std::size_t plas3d_dofmap_2::num_global_support_dofs() const
{
    return 0;
}

std::size_t plas3d_dofmap_2::num_element_support_dofs() const
{
    return 180;
}

std::size_t plas3d_dofmap_2::num_element_dofs() const
{
    return 180;
}

std::size_t plas3d_dofmap_2::num_facet_dofs() const
{
    return 0;
}

std::size_t plas3d_dofmap_2::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 180 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t plas3d_dofmap_2::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 0, 0, 0, 180 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void plas3d_dofmap_2::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + 5 * entity_indices[3][0];
    dofs[1] = offset + 5 * entity_indices[3][0] + 1;
    dofs[2] = offset + 5 * entity_indices[3][0] + 2;
    dofs[3] = offset + 5 * entity_indices[3][0] + 3;
    dofs[4] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[5] = offset + 5 * entity_indices[3][0];
    dofs[6] = offset + 5 * entity_indices[3][0] + 1;
    dofs[7] = offset + 5 * entity_indices[3][0] + 2;
    dofs[8] = offset + 5 * entity_indices[3][0] + 3;
    dofs[9] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[10] = offset + 5 * entity_indices[3][0];
    dofs[11] = offset + 5 * entity_indices[3][0] + 1;
    dofs[12] = offset + 5 * entity_indices[3][0] + 2;
    dofs[13] = offset + 5 * entity_indices[3][0] + 3;
    dofs[14] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[15] = offset + 5 * entity_indices[3][0];
    dofs[16] = offset + 5 * entity_indices[3][0] + 1;
    dofs[17] = offset + 5 * entity_indices[3][0] + 2;
    dofs[18] = offset + 5 * entity_indices[3][0] + 3;
    dofs[19] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[20] = offset + 5 * entity_indices[3][0];
    dofs[21] = offset + 5 * entity_indices[3][0] + 1;
    dofs[22] = offset + 5 * entity_indices[3][0] + 2;
    dofs[23] = offset + 5 * entity_indices[3][0] + 3;
    dofs[24] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[25] = offset + 5 * entity_indices[3][0];
    dofs[26] = offset + 5 * entity_indices[3][0] + 1;
    dofs[27] = offset + 5 * entity_indices[3][0] + 2;
    dofs[28] = offset + 5 * entity_indices[3][0] + 3;
    dofs[29] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[30] = offset + 5 * entity_indices[3][0];
    dofs[31] = offset + 5 * entity_indices[3][0] + 1;
    dofs[32] = offset + 5 * entity_indices[3][0] + 2;
    dofs[33] = offset + 5 * entity_indices[3][0] + 3;
    dofs[34] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[35] = offset + 5 * entity_indices[3][0];
    dofs[36] = offset + 5 * entity_indices[3][0] + 1;
    dofs[37] = offset + 5 * entity_indices[3][0] + 2;
    dofs[38] = offset + 5 * entity_indices[3][0] + 3;
    dofs[39] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[40] = offset + 5 * entity_indices[3][0];
    dofs[41] = offset + 5 * entity_indices[3][0] + 1;
    dofs[42] = offset + 5 * entity_indices[3][0] + 2;
    dofs[43] = offset + 5 * entity_indices[3][0] + 3;
    dofs[44] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[45] = offset + 5 * entity_indices[3][0];
    dofs[46] = offset + 5 * entity_indices[3][0] + 1;
    dofs[47] = offset + 5 * entity_indices[3][0] + 2;
    dofs[48] = offset + 5 * entity_indices[3][0] + 3;
    dofs[49] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[50] = offset + 5 * entity_indices[3][0];
    dofs[51] = offset + 5 * entity_indices[3][0] + 1;
    dofs[52] = offset + 5 * entity_indices[3][0] + 2;
    dofs[53] = offset + 5 * entity_indices[3][0] + 3;
    dofs[54] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[55] = offset + 5 * entity_indices[3][0];
    dofs[56] = offset + 5 * entity_indices[3][0] + 1;
    dofs[57] = offset + 5 * entity_indices[3][0] + 2;
    dofs[58] = offset + 5 * entity_indices[3][0] + 3;
    dofs[59] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[60] = offset + 5 * entity_indices[3][0];
    dofs[61] = offset + 5 * entity_indices[3][0] + 1;
    dofs[62] = offset + 5 * entity_indices[3][0] + 2;
    dofs[63] = offset + 5 * entity_indices[3][0] + 3;
    dofs[64] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[65] = offset + 5 * entity_indices[3][0];
    dofs[66] = offset + 5 * entity_indices[3][0] + 1;
    dofs[67] = offset + 5 * entity_indices[3][0] + 2;
    dofs[68] = offset + 5 * entity_indices[3][0] + 3;
    dofs[69] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[70] = offset + 5 * entity_indices[3][0];
    dofs[71] = offset + 5 * entity_indices[3][0] + 1;
    dofs[72] = offset + 5 * entity_indices[3][0] + 2;
    dofs[73] = offset + 5 * entity_indices[3][0] + 3;
    dofs[74] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[75] = offset + 5 * entity_indices[3][0];
    dofs[76] = offset + 5 * entity_indices[3][0] + 1;
    dofs[77] = offset + 5 * entity_indices[3][0] + 2;
    dofs[78] = offset + 5 * entity_indices[3][0] + 3;
    dofs[79] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[80] = offset + 5 * entity_indices[3][0];
    dofs[81] = offset + 5 * entity_indices[3][0] + 1;
    dofs[82] = offset + 5 * entity_indices[3][0] + 2;
    dofs[83] = offset + 5 * entity_indices[3][0] + 3;
    dofs[84] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[85] = offset + 5 * entity_indices[3][0];
    dofs[86] = offset + 5 * entity_indices[3][0] + 1;
    dofs[87] = offset + 5 * entity_indices[3][0] + 2;
    dofs[88] = offset + 5 * entity_indices[3][0] + 3;
    dofs[89] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[90] = offset + 5 * entity_indices[3][0];
    dofs[91] = offset + 5 * entity_indices[3][0] + 1;
    dofs[92] = offset + 5 * entity_indices[3][0] + 2;
    dofs[93] = offset + 5 * entity_indices[3][0] + 3;
    dofs[94] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[95] = offset + 5 * entity_indices[3][0];
    dofs[96] = offset + 5 * entity_indices[3][0] + 1;
    dofs[97] = offset + 5 * entity_indices[3][0] + 2;
    dofs[98] = offset + 5 * entity_indices[3][0] + 3;
    dofs[99] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[100] = offset + 5 * entity_indices[3][0];
    dofs[101] = offset + 5 * entity_indices[3][0] + 1;
    dofs[102] = offset + 5 * entity_indices[3][0] + 2;
    dofs[103] = offset + 5 * entity_indices[3][0] + 3;
    dofs[104] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[105] = offset + 5 * entity_indices[3][0];
    dofs[106] = offset + 5 * entity_indices[3][0] + 1;
    dofs[107] = offset + 5 * entity_indices[3][0] + 2;
    dofs[108] = offset + 5 * entity_indices[3][0] + 3;
    dofs[109] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[110] = offset + 5 * entity_indices[3][0];
    dofs[111] = offset + 5 * entity_indices[3][0] + 1;
    dofs[112] = offset + 5 * entity_indices[3][0] + 2;
    dofs[113] = offset + 5 * entity_indices[3][0] + 3;
    dofs[114] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[115] = offset + 5 * entity_indices[3][0];
    dofs[116] = offset + 5 * entity_indices[3][0] + 1;
    dofs[117] = offset + 5 * entity_indices[3][0] + 2;
    dofs[118] = offset + 5 * entity_indices[3][0] + 3;
    dofs[119] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[120] = offset + 5 * entity_indices[3][0];
    dofs[121] = offset + 5 * entity_indices[3][0] + 1;
    dofs[122] = offset + 5 * entity_indices[3][0] + 2;
    dofs[123] = offset + 5 * entity_indices[3][0] + 3;
    dofs[124] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[125] = offset + 5 * entity_indices[3][0];
    dofs[126] = offset + 5 * entity_indices[3][0] + 1;
    dofs[127] = offset + 5 * entity_indices[3][0] + 2;
    dofs[128] = offset + 5 * entity_indices[3][0] + 3;
    dofs[129] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[130] = offset + 5 * entity_indices[3][0];
    dofs[131] = offset + 5 * entity_indices[3][0] + 1;
    dofs[132] = offset + 5 * entity_indices[3][0] + 2;
    dofs[133] = offset + 5 * entity_indices[3][0] + 3;
    dofs[134] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[135] = offset + 5 * entity_indices[3][0];
    dofs[136] = offset + 5 * entity_indices[3][0] + 1;
    dofs[137] = offset + 5 * entity_indices[3][0] + 2;
    dofs[138] = offset + 5 * entity_indices[3][0] + 3;
    dofs[139] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[140] = offset + 5 * entity_indices[3][0];
    dofs[141] = offset + 5 * entity_indices[3][0] + 1;
    dofs[142] = offset + 5 * entity_indices[3][0] + 2;
    dofs[143] = offset + 5 * entity_indices[3][0] + 3;
    dofs[144] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[145] = offset + 5 * entity_indices[3][0];
    dofs[146] = offset + 5 * entity_indices[3][0] + 1;
    dofs[147] = offset + 5 * entity_indices[3][0] + 2;
    dofs[148] = offset + 5 * entity_indices[3][0] + 3;
    dofs[149] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[150] = offset + 5 * entity_indices[3][0];
    dofs[151] = offset + 5 * entity_indices[3][0] + 1;
    dofs[152] = offset + 5 * entity_indices[3][0] + 2;
    dofs[153] = offset + 5 * entity_indices[3][0] + 3;
    dofs[154] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[155] = offset + 5 * entity_indices[3][0];
    dofs[156] = offset + 5 * entity_indices[3][0] + 1;
    dofs[157] = offset + 5 * entity_indices[3][0] + 2;
    dofs[158] = offset + 5 * entity_indices[3][0] + 3;
    dofs[159] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[160] = offset + 5 * entity_indices[3][0];
    dofs[161] = offset + 5 * entity_indices[3][0] + 1;
    dofs[162] = offset + 5 * entity_indices[3][0] + 2;
    dofs[163] = offset + 5 * entity_indices[3][0] + 3;
    dofs[164] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[165] = offset + 5 * entity_indices[3][0];
    dofs[166] = offset + 5 * entity_indices[3][0] + 1;
    dofs[167] = offset + 5 * entity_indices[3][0] + 2;
    dofs[168] = offset + 5 * entity_indices[3][0] + 3;
    dofs[169] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[170] = offset + 5 * entity_indices[3][0];
    dofs[171] = offset + 5 * entity_indices[3][0] + 1;
    dofs[172] = offset + 5 * entity_indices[3][0] + 2;
    dofs[173] = offset + 5 * entity_indices[3][0] + 3;
    dofs[174] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
    dofs[175] = offset + 5 * entity_indices[3][0];
    dofs[176] = offset + 5 * entity_indices[3][0] + 1;
    dofs[177] = offset + 5 * entity_indices[3][0] + 2;
    dofs[178] = offset + 5 * entity_indices[3][0] + 3;
    dofs[179] = offset + 5 * entity_indices[3][0] + 4;
    offset += 5 * num_global_entities[3];
}

void plas3d_dofmap_2::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    // Do nothing
}

void plas3d_dofmap_2::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            dofs[19] = 19;
            dofs[20] = 20;
            dofs[21] = 21;
            dofs[22] = 22;
            dofs[23] = 23;
            dofs[24] = 24;
            dofs[25] = 25;
            dofs[26] = 26;
            dofs[27] = 27;
            dofs[28] = 28;
            dofs[29] = 29;
            dofs[30] = 30;
            dofs[31] = 31;
            dofs[32] = 32;
            dofs[33] = 33;
            dofs[34] = 34;
            dofs[35] = 35;
            dofs[36] = 36;
            dofs[37] = 37;
            dofs[38] = 38;
            dofs[39] = 39;
            dofs[40] = 40;
            dofs[41] = 41;
            dofs[42] = 42;
            dofs[43] = 43;
            dofs[44] = 44;
            dofs[45] = 45;
            dofs[46] = 46;
            dofs[47] = 47;
            dofs[48] = 48;
            dofs[49] = 49;
            dofs[50] = 50;
            dofs[51] = 51;
            dofs[52] = 52;
            dofs[53] = 53;
            dofs[54] = 54;
            dofs[55] = 55;
            dofs[56] = 56;
            dofs[57] = 57;
            dofs[58] = 58;
            dofs[59] = 59;
            dofs[60] = 60;
            dofs[61] = 61;
            dofs[62] = 62;
            dofs[63] = 63;
            dofs[64] = 64;
            dofs[65] = 65;
            dofs[66] = 66;
            dofs[67] = 67;
            dofs[68] = 68;
            dofs[69] = 69;
            dofs[70] = 70;
            dofs[71] = 71;
            dofs[72] = 72;
            dofs[73] = 73;
            dofs[74] = 74;
            dofs[75] = 75;
            dofs[76] = 76;
            dofs[77] = 77;
            dofs[78] = 78;
            dofs[79] = 79;
            dofs[80] = 80;
            dofs[81] = 81;
            dofs[82] = 82;
            dofs[83] = 83;
            dofs[84] = 84;
            dofs[85] = 85;
            dofs[86] = 86;
            dofs[87] = 87;
            dofs[88] = 88;
            dofs[89] = 89;
            dofs[90] = 90;
            dofs[91] = 91;
            dofs[92] = 92;
            dofs[93] = 93;
            dofs[94] = 94;
            dofs[95] = 95;
            dofs[96] = 96;
            dofs[97] = 97;
            dofs[98] = 98;
            dofs[99] = 99;
            dofs[100] = 100;
            dofs[101] = 101;
            dofs[102] = 102;
            dofs[103] = 103;
            dofs[104] = 104;
            dofs[105] = 105;
            dofs[106] = 106;
            dofs[107] = 107;
            dofs[108] = 108;
            dofs[109] = 109;
            dofs[110] = 110;
            dofs[111] = 111;
            dofs[112] = 112;
            dofs[113] = 113;
            dofs[114] = 114;
            dofs[115] = 115;
            dofs[116] = 116;
            dofs[117] = 117;
            dofs[118] = 118;
            dofs[119] = 119;
            dofs[120] = 120;
            dofs[121] = 121;
            dofs[122] = 122;
            dofs[123] = 123;
            dofs[124] = 124;
            dofs[125] = 125;
            dofs[126] = 126;
            dofs[127] = 127;
            dofs[128] = 128;
            dofs[129] = 129;
            dofs[130] = 130;
            dofs[131] = 131;
            dofs[132] = 132;
            dofs[133] = 133;
            dofs[134] = 134;
            dofs[135] = 135;
            dofs[136] = 136;
            dofs[137] = 137;
            dofs[138] = 138;
            dofs[139] = 139;
            dofs[140] = 140;
            dofs[141] = 141;
            dofs[142] = 142;
            dofs[143] = 143;
            dofs[144] = 144;
            dofs[145] = 145;
            dofs[146] = 146;
            dofs[147] = 147;
            dofs[148] = 148;
            dofs[149] = 149;
            dofs[150] = 150;
            dofs[151] = 151;
            dofs[152] = 152;
            dofs[153] = 153;
            dofs[154] = 154;
            dofs[155] = 155;
            dofs[156] = 156;
            dofs[157] = 157;
            dofs[158] = 158;
            dofs[159] = 159;
            dofs[160] = 160;
            dofs[161] = 161;
            dofs[162] = 162;
            dofs[163] = 163;
            dofs[164] = 164;
            dofs[165] = 165;
            dofs[166] = 166;
            dofs[167] = 167;
            dofs[168] = 168;
            dofs[169] = 169;
            dofs[170] = 170;
            dofs[171] = 171;
            dofs[172] = 172;
            dofs[173] = 173;
            dofs[174] = 174;
            dofs[175] = 175;
            dofs[176] = 176;
            dofs[177] = 177;
            dofs[178] = 178;
            dofs[179] = 179;
            break;
        }
        break;
    }
}

void plas3d_dofmap_2::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        case 4:
            break;
        case 5:
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            dofs[19] = 19;
            dofs[20] = 20;
            dofs[21] = 21;
            dofs[22] = 22;
            dofs[23] = 23;
            dofs[24] = 24;
            dofs[25] = 25;
            dofs[26] = 26;
            dofs[27] = 27;
            dofs[28] = 28;
            dofs[29] = 29;
            dofs[30] = 30;
            dofs[31] = 31;
            dofs[32] = 32;
            dofs[33] = 33;
            dofs[34] = 34;
            dofs[35] = 35;
            dofs[36] = 36;
            dofs[37] = 37;
            dofs[38] = 38;
            dofs[39] = 39;
            dofs[40] = 40;
            dofs[41] = 41;
            dofs[42] = 42;
            dofs[43] = 43;
            dofs[44] = 44;
            dofs[45] = 45;
            dofs[46] = 46;
            dofs[47] = 47;
            dofs[48] = 48;
            dofs[49] = 49;
            dofs[50] = 50;
            dofs[51] = 51;
            dofs[52] = 52;
            dofs[53] = 53;
            dofs[54] = 54;
            dofs[55] = 55;
            dofs[56] = 56;
            dofs[57] = 57;
            dofs[58] = 58;
            dofs[59] = 59;
            dofs[60] = 60;
            dofs[61] = 61;
            dofs[62] = 62;
            dofs[63] = 63;
            dofs[64] = 64;
            dofs[65] = 65;
            dofs[66] = 66;
            dofs[67] = 67;
            dofs[68] = 68;
            dofs[69] = 69;
            dofs[70] = 70;
            dofs[71] = 71;
            dofs[72] = 72;
            dofs[73] = 73;
            dofs[74] = 74;
            dofs[75] = 75;
            dofs[76] = 76;
            dofs[77] = 77;
            dofs[78] = 78;
            dofs[79] = 79;
            dofs[80] = 80;
            dofs[81] = 81;
            dofs[82] = 82;
            dofs[83] = 83;
            dofs[84] = 84;
            dofs[85] = 85;
            dofs[86] = 86;
            dofs[87] = 87;
            dofs[88] = 88;
            dofs[89] = 89;
            dofs[90] = 90;
            dofs[91] = 91;
            dofs[92] = 92;
            dofs[93] = 93;
            dofs[94] = 94;
            dofs[95] = 95;
            dofs[96] = 96;
            dofs[97] = 97;
            dofs[98] = 98;
            dofs[99] = 99;
            dofs[100] = 100;
            dofs[101] = 101;
            dofs[102] = 102;
            dofs[103] = 103;
            dofs[104] = 104;
            dofs[105] = 105;
            dofs[106] = 106;
            dofs[107] = 107;
            dofs[108] = 108;
            dofs[109] = 109;
            dofs[110] = 110;
            dofs[111] = 111;
            dofs[112] = 112;
            dofs[113] = 113;
            dofs[114] = 114;
            dofs[115] = 115;
            dofs[116] = 116;
            dofs[117] = 117;
            dofs[118] = 118;
            dofs[119] = 119;
            dofs[120] = 120;
            dofs[121] = 121;
            dofs[122] = 122;
            dofs[123] = 123;
            dofs[124] = 124;
            dofs[125] = 125;
            dofs[126] = 126;
            dofs[127] = 127;
            dofs[128] = 128;
            dofs[129] = 129;
            dofs[130] = 130;
            dofs[131] = 131;
            dofs[132] = 132;
            dofs[133] = 133;
            dofs[134] = 134;
            dofs[135] = 135;
            dofs[136] = 136;
            dofs[137] = 137;
            dofs[138] = 138;
            dofs[139] = 139;
            dofs[140] = 140;
            dofs[141] = 141;
            dofs[142] = 142;
            dofs[143] = 143;
            dofs[144] = 144;
            dofs[145] = 145;
            dofs[146] = 146;
            dofs[147] = 147;
            dofs[148] = 148;
            dofs[149] = 149;
            dofs[150] = 150;
            dofs[151] = 151;
            dofs[152] = 152;
            dofs[153] = 153;
            dofs[154] = 154;
            dofs[155] = 155;
            dofs[156] = 156;
            dofs[157] = 157;
            dofs[158] = 158;
            dofs[159] = 159;
            dofs[160] = 160;
            dofs[161] = 161;
            dofs[162] = 162;
            dofs[163] = 163;
            dofs[164] = 164;
            dofs[165] = 165;
            dofs[166] = 166;
            dofs[167] = 167;
            dofs[168] = 168;
            dofs[169] = 169;
            dofs[170] = 170;
            dofs[171] = 171;
            dofs[172] = 172;
            dofs[173] = 173;
            dofs[174] = 174;
            dofs[175] = 175;
            dofs[176] = 176;
            dofs[177] = 177;
            dofs[178] = 178;
            dofs[179] = 179;
            break;
        }
        break;
    }
}

std::size_t plas3d_dofmap_2::num_sub_dofmaps() const
{
    return 36;
}

ufc::dofmap * plas3d_dofmap_2::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_0();
    case 1:
        return new plas3d_dofmap_0();
    case 2:
        return new plas3d_dofmap_0();
    case 3:
        return new plas3d_dofmap_0();
    case 4:
        return new plas3d_dofmap_0();
    case 5:
        return new plas3d_dofmap_0();
    case 6:
        return new plas3d_dofmap_0();
    case 7:
        return new plas3d_dofmap_0();
    case 8:
        return new plas3d_dofmap_0();
    case 9:
        return new plas3d_dofmap_0();
    case 10:
        return new plas3d_dofmap_0();
    case 11:
        return new plas3d_dofmap_0();
    case 12:
        return new plas3d_dofmap_0();
    case 13:
        return new plas3d_dofmap_0();
    case 14:
        return new plas3d_dofmap_0();
    case 15:
        return new plas3d_dofmap_0();
    case 16:
        return new plas3d_dofmap_0();
    case 17:
        return new plas3d_dofmap_0();
    case 18:
        return new plas3d_dofmap_0();
    case 19:
        return new plas3d_dofmap_0();
    case 20:
        return new plas3d_dofmap_0();
    case 21:
        return new plas3d_dofmap_0();
    case 22:
        return new plas3d_dofmap_0();
    case 23:
        return new plas3d_dofmap_0();
    case 24:
        return new plas3d_dofmap_0();
    case 25:
        return new plas3d_dofmap_0();
    case 26:
        return new plas3d_dofmap_0();
    case 27:
        return new plas3d_dofmap_0();
    case 28:
        return new plas3d_dofmap_0();
    case 29:
        return new plas3d_dofmap_0();
    case 30:
        return new plas3d_dofmap_0();
    case 31:
        return new plas3d_dofmap_0();
    case 32:
        return new plas3d_dofmap_0();
    case 33:
        return new plas3d_dofmap_0();
    case 34:
        return new plas3d_dofmap_0();
    case 35:
        return new plas3d_dofmap_0();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_dofmap_2::create() const
{
    return new plas3d_dofmap_2();
}


plas3d_dofmap_3::plas3d_dofmap_3() : ufc::dofmap()
{
    // Do nothing
}

plas3d_dofmap_3::~plas3d_dofmap_3()
{
    // Do nothing
}

const char * plas3d_dofmap_3::signature() const
{
    return "FFC dofmap for FiniteElement('Lagrange', tetrahedron, 2)";
}

bool plas3d_dofmap_3::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { true, true, false, false };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t plas3d_dofmap_3::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_dofmap_3::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return num_global_entities[0] + num_global_entities[1];
}

std::size_t plas3d_dofmap_3::num_global_support_dofs() const
{
    return 0;
}

std::size_t plas3d_dofmap_3::num_element_support_dofs() const
{
    return 10;
}

std::size_t plas3d_dofmap_3::num_element_dofs() const
{
    return 10;
}

std::size_t plas3d_dofmap_3::num_facet_dofs() const
{
    return 6;
}

std::size_t plas3d_dofmap_3::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 1, 1, 0, 0 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t plas3d_dofmap_3::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 1, 3, 6, 10 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void plas3d_dofmap_3::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    dofs[3] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[4] = offset + entity_indices[1][0];
    dofs[5] = offset + entity_indices[1][1];
    dofs[6] = offset + entity_indices[1][2];
    dofs[7] = offset + entity_indices[1][3];
    dofs[8] = offset + entity_indices[1][4];
    dofs[9] = offset + entity_indices[1][5];
    offset += num_global_entities[1];
}

void plas3d_dofmap_3::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 5;
        dofs[5] = 6;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 7;
        dofs[5] = 8;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 5;
        dofs[4] = 7;
        dofs[5] = 9;
        break;
    case 3:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 2;
        dofs[3] = 6;
        dofs[4] = 8;
        dofs[5] = 9;
        break;
    }
}

void plas3d_dofmap_3::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        case 3:
            dofs[0] = 3;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 4;
            break;
        case 1:
            dofs[0] = 5;
            break;
        case 2:
            dofs[0] = 6;
            break;
        case 3:
            dofs[0] = 7;
            break;
        case 4:
            dofs[0] = 8;
            break;
        case 5:
            dofs[0] = 9;
            break;
        }
        break;
    }
}

void plas3d_dofmap_3::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        case 3:
            dofs[0] = 3;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 2;
            dofs[1] = 3;
            dofs[2] = 4;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 3;
            dofs[2] = 5;
            break;
        case 2:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 6;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 7;
            break;
        case 4:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 8;
            break;
        case 5:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 9;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 5;
            dofs[5] = 6;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 7;
            dofs[5] = 8;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 5;
            dofs[4] = 7;
            dofs[5] = 9;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 6;
            dofs[4] = 8;
            dofs[5] = 9;
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            break;
        }
        break;
    }
}

std::size_t plas3d_dofmap_3::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * plas3d_dofmap_3::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * plas3d_dofmap_3::create() const
{
    return new plas3d_dofmap_3();
}


plas3d_dofmap_4::plas3d_dofmap_4() : ufc::dofmap()
{
    // Do nothing
}

plas3d_dofmap_4::~plas3d_dofmap_4()
{
    // Do nothing
}

const char * plas3d_dofmap_4::signature() const
{
    return "FFC dofmap for VectorElement(FiniteElement('Lagrange', tetrahedron, 2), dim=3)";
}

bool plas3d_dofmap_4::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { true, true, false, false };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t plas3d_dofmap_4::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_dofmap_4::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 3 * num_global_entities[0] + 3 * num_global_entities[1];
}

std::size_t plas3d_dofmap_4::num_global_support_dofs() const
{
    return 0;
}

std::size_t plas3d_dofmap_4::num_element_support_dofs() const
{
    return 30;
}

std::size_t plas3d_dofmap_4::num_element_dofs() const
{
    return 30;
}

std::size_t plas3d_dofmap_4::num_facet_dofs() const
{
    return 18;
}

std::size_t plas3d_dofmap_4::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 3, 3, 0, 0 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t plas3d_dofmap_4::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 3, 9, 18, 30 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void plas3d_dofmap_4::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    dofs[3] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[4] = offset + entity_indices[1][0];
    dofs[5] = offset + entity_indices[1][1];
    dofs[6] = offset + entity_indices[1][2];
    dofs[7] = offset + entity_indices[1][3];
    dofs[8] = offset + entity_indices[1][4];
    dofs[9] = offset + entity_indices[1][5];
    offset += num_global_entities[1];
    dofs[10] = offset + entity_indices[0][0];
    dofs[11] = offset + entity_indices[0][1];
    dofs[12] = offset + entity_indices[0][2];
    dofs[13] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[14] = offset + entity_indices[1][0];
    dofs[15] = offset + entity_indices[1][1];
    dofs[16] = offset + entity_indices[1][2];
    dofs[17] = offset + entity_indices[1][3];
    dofs[18] = offset + entity_indices[1][4];
    dofs[19] = offset + entity_indices[1][5];
    offset += num_global_entities[1];
    dofs[20] = offset + entity_indices[0][0];
    dofs[21] = offset + entity_indices[0][1];
    dofs[22] = offset + entity_indices[0][2];
    dofs[23] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[24] = offset + entity_indices[1][0];
    dofs[25] = offset + entity_indices[1][1];
    dofs[26] = offset + entity_indices[1][2];
    dofs[27] = offset + entity_indices[1][3];
    dofs[28] = offset + entity_indices[1][4];
    dofs[29] = offset + entity_indices[1][5];
    offset += num_global_entities[1];
}

void plas3d_dofmap_4::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 5;
        dofs[5] = 6;
        dofs[6] = 11;
        dofs[7] = 12;
        dofs[8] = 13;
        dofs[9] = 14;
        dofs[10] = 15;
        dofs[11] = 16;
        dofs[12] = 21;
        dofs[13] = 22;
        dofs[14] = 23;
        dofs[15] = 24;
        dofs[16] = 25;
        dofs[17] = 26;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 7;
        dofs[5] = 8;
        dofs[6] = 10;
        dofs[7] = 12;
        dofs[8] = 13;
        dofs[9] = 14;
        dofs[10] = 17;
        dofs[11] = 18;
        dofs[12] = 20;
        dofs[13] = 22;
        dofs[14] = 23;
        dofs[15] = 24;
        dofs[16] = 27;
        dofs[17] = 28;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 5;
        dofs[4] = 7;
        dofs[5] = 9;
        dofs[6] = 10;
        dofs[7] = 11;
        dofs[8] = 13;
        dofs[9] = 15;
        dofs[10] = 17;
        dofs[11] = 19;
        dofs[12] = 20;
        dofs[13] = 21;
        dofs[14] = 23;
        dofs[15] = 25;
        dofs[16] = 27;
        dofs[17] = 29;
        break;
    case 3:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 2;
        dofs[3] = 6;
        dofs[4] = 8;
        dofs[5] = 9;
        dofs[6] = 10;
        dofs[7] = 11;
        dofs[8] = 12;
        dofs[9] = 16;
        dofs[10] = 18;
        dofs[11] = 19;
        dofs[12] = 20;
        dofs[13] = 21;
        dofs[14] = 22;
        dofs[15] = 26;
        dofs[16] = 28;
        dofs[17] = 29;
        break;
    }
}

void plas3d_dofmap_4::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 10;
            dofs[2] = 20;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 11;
            dofs[2] = 21;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 12;
            dofs[2] = 22;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 13;
            dofs[2] = 23;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 4;
            dofs[1] = 14;
            dofs[2] = 24;
            break;
        case 1:
            dofs[0] = 5;
            dofs[1] = 15;
            dofs[2] = 25;
            break;
        case 2:
            dofs[0] = 6;
            dofs[1] = 16;
            dofs[2] = 26;
            break;
        case 3:
            dofs[0] = 7;
            dofs[1] = 17;
            dofs[2] = 27;
            break;
        case 4:
            dofs[0] = 8;
            dofs[1] = 18;
            dofs[2] = 28;
            break;
        case 5:
            dofs[0] = 9;
            dofs[1] = 19;
            dofs[2] = 29;
            break;
        }
        break;
    }
}

void plas3d_dofmap_4::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 10;
            dofs[2] = 20;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 11;
            dofs[2] = 21;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 12;
            dofs[2] = 22;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 13;
            dofs[2] = 23;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 2;
            dofs[1] = 3;
            dofs[2] = 4;
            dofs[3] = 12;
            dofs[4] = 13;
            dofs[5] = 14;
            dofs[6] = 22;
            dofs[7] = 23;
            dofs[8] = 24;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 3;
            dofs[2] = 5;
            dofs[3] = 11;
            dofs[4] = 13;
            dofs[5] = 15;
            dofs[6] = 21;
            dofs[7] = 23;
            dofs[8] = 25;
            break;
        case 2:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 6;
            dofs[3] = 11;
            dofs[4] = 12;
            dofs[5] = 16;
            dofs[6] = 21;
            dofs[7] = 22;
            dofs[8] = 26;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 7;
            dofs[3] = 10;
            dofs[4] = 13;
            dofs[5] = 17;
            dofs[6] = 20;
            dofs[7] = 23;
            dofs[8] = 27;
            break;
        case 4:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 8;
            dofs[3] = 10;
            dofs[4] = 12;
            dofs[5] = 18;
            dofs[6] = 20;
            dofs[7] = 22;
            dofs[8] = 28;
            break;
        case 5:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 9;
            dofs[3] = 10;
            dofs[4] = 11;
            dofs[5] = 19;
            dofs[6] = 20;
            dofs[7] = 21;
            dofs[8] = 29;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 5;
            dofs[5] = 6;
            dofs[6] = 11;
            dofs[7] = 12;
            dofs[8] = 13;
            dofs[9] = 14;
            dofs[10] = 15;
            dofs[11] = 16;
            dofs[12] = 21;
            dofs[13] = 22;
            dofs[14] = 23;
            dofs[15] = 24;
            dofs[16] = 25;
            dofs[17] = 26;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 7;
            dofs[5] = 8;
            dofs[6] = 10;
            dofs[7] = 12;
            dofs[8] = 13;
            dofs[9] = 14;
            dofs[10] = 17;
            dofs[11] = 18;
            dofs[12] = 20;
            dofs[13] = 22;
            dofs[14] = 23;
            dofs[15] = 24;
            dofs[16] = 27;
            dofs[17] = 28;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 5;
            dofs[4] = 7;
            dofs[5] = 9;
            dofs[6] = 10;
            dofs[7] = 11;
            dofs[8] = 13;
            dofs[9] = 15;
            dofs[10] = 17;
            dofs[11] = 19;
            dofs[12] = 20;
            dofs[13] = 21;
            dofs[14] = 23;
            dofs[15] = 25;
            dofs[16] = 27;
            dofs[17] = 29;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 6;
            dofs[4] = 8;
            dofs[5] = 9;
            dofs[6] = 10;
            dofs[7] = 11;
            dofs[8] = 12;
            dofs[9] = 16;
            dofs[10] = 18;
            dofs[11] = 19;
            dofs[12] = 20;
            dofs[13] = 21;
            dofs[14] = 22;
            dofs[15] = 26;
            dofs[16] = 28;
            dofs[17] = 29;
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            dofs[19] = 19;
            dofs[20] = 20;
            dofs[21] = 21;
            dofs[22] = 22;
            dofs[23] = 23;
            dofs[24] = 24;
            dofs[25] = 25;
            dofs[26] = 26;
            dofs[27] = 27;
            dofs[28] = 28;
            dofs[29] = 29;
            break;
        }
        break;
    }
}

std::size_t plas3d_dofmap_4::num_sub_dofmaps() const
{
    return 3;
}

ufc::dofmap * plas3d_dofmap_4::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_3();
    case 1:
        return new plas3d_dofmap_3();
    case 2:
        return new plas3d_dofmap_3();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_dofmap_4::create() const
{
    return new plas3d_dofmap_4();
}


plas3d_dofmap_5::plas3d_dofmap_5() : ufc::dofmap()
{
    // Do nothing
}

plas3d_dofmap_5::~plas3d_dofmap_5()
{
    // Do nothing
}

const char * plas3d_dofmap_5::signature() const
{
    return "FFC dofmap for FiniteElement('Lagrange', tetrahedron, 1)";
}

bool plas3d_dofmap_5::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { true, false, false, false };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t plas3d_dofmap_5::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_dofmap_5::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return num_global_entities[0];
}

std::size_t plas3d_dofmap_5::num_global_support_dofs() const
{
    return 0;
}

std::size_t plas3d_dofmap_5::num_element_support_dofs() const
{
    return 4;
}

std::size_t plas3d_dofmap_5::num_element_dofs() const
{
    return 4;
}

std::size_t plas3d_dofmap_5::num_facet_dofs() const
{
    return 3;
}

std::size_t plas3d_dofmap_5::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 1, 0, 0, 0 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t plas3d_dofmap_5::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 1, 2, 3, 4 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void plas3d_dofmap_5::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    dofs[0] = entity_indices[0][0];
    dofs[1] = entity_indices[0][1];
    dofs[2] = entity_indices[0][2];
    dofs[3] = entity_indices[0][3];
}

void plas3d_dofmap_5::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 3;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        break;
    case 3:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 2;
        break;
    }
}

void plas3d_dofmap_5::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        case 3:
            dofs[0] = 3;
            break;
        }
        break;
    }
}

void plas3d_dofmap_5::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            break;
        case 1:
            dofs[0] = 1;
            break;
        case 2:
            dofs[0] = 2;
            break;
        case 3:
            dofs[0] = 3;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 2;
            dofs[1] = 3;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 3;
            break;
        case 2:
            dofs[0] = 1;
            dofs[1] = 2;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 3;
            break;
        case 4:
            dofs[0] = 0;
            dofs[1] = 2;
            break;
        case 5:
            dofs[0] = 0;
            dofs[1] = 1;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 3;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            break;
        }
        break;
    }
}

std::size_t plas3d_dofmap_5::num_sub_dofmaps() const
{
    return 0;
}

ufc::dofmap * plas3d_dofmap_5::create_sub_dofmap(std::size_t i) const
{
    return nullptr;
}

ufc::dofmap * plas3d_dofmap_5::create() const
{
    return new plas3d_dofmap_5();
}


plas3d_dofmap_6::plas3d_dofmap_6() : ufc::dofmap()
{
    // Do nothing
}

plas3d_dofmap_6::~plas3d_dofmap_6()
{
    // Do nothing
}

const char * plas3d_dofmap_6::signature() const
{
    return "FFC dofmap for VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
}

bool plas3d_dofmap_6::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { true, false, false, false };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t plas3d_dofmap_6::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_dofmap_6::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 3 * num_global_entities[0];
}

std::size_t plas3d_dofmap_6::num_global_support_dofs() const
{
    return 0;
}

std::size_t plas3d_dofmap_6::num_element_support_dofs() const
{
    return 12;
}

std::size_t plas3d_dofmap_6::num_element_dofs() const
{
    return 12;
}

std::size_t plas3d_dofmap_6::num_facet_dofs() const
{
    return 9;
}

std::size_t plas3d_dofmap_6::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 3, 0, 0, 0 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t plas3d_dofmap_6::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 3, 6, 9, 12 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void plas3d_dofmap_6::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    dofs[3] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[4] = offset + entity_indices[0][0];
    dofs[5] = offset + entity_indices[0][1];
    dofs[6] = offset + entity_indices[0][2];
    dofs[7] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[8] = offset + entity_indices[0][0];
    dofs[9] = offset + entity_indices[0][1];
    dofs[10] = offset + entity_indices[0][2];
    dofs[11] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
}

void plas3d_dofmap_6::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        dofs[4] = 6;
        dofs[5] = 7;
        dofs[6] = 9;
        dofs[7] = 10;
        dofs[8] = 11;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 6;
        dofs[5] = 7;
        dofs[6] = 8;
        dofs[7] = 10;
        dofs[8] = 11;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 5;
        dofs[5] = 7;
        dofs[6] = 8;
        dofs[7] = 9;
        dofs[8] = 11;
        break;
    case 3:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 2;
        dofs[3] = 4;
        dofs[4] = 5;
        dofs[5] = 6;
        dofs[6] = 8;
        dofs[7] = 9;
        dofs[8] = 10;
        break;
    }
}

void plas3d_dofmap_6::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 4;
            dofs[2] = 8;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 5;
            dofs[2] = 9;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 6;
            dofs[2] = 10;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 7;
            dofs[2] = 11;
            break;
        }
        break;
    }
}

void plas3d_dofmap_6::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 4;
            dofs[2] = 8;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 5;
            dofs[2] = 9;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 6;
            dofs[2] = 10;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 7;
            dofs[2] = 11;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 2;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 7;
            dofs[4] = 10;
            dofs[5] = 11;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 3;
            dofs[2] = 5;
            dofs[3] = 7;
            dofs[4] = 9;
            dofs[5] = 11;
            break;
        case 2:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 5;
            dofs[3] = 6;
            dofs[4] = 9;
            dofs[5] = 10;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 4;
            dofs[3] = 7;
            dofs[4] = 8;
            dofs[5] = 11;
            break;
        case 4:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 6;
            dofs[4] = 8;
            dofs[5] = 10;
            break;
        case 5:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 4;
            dofs[3] = 5;
            dofs[4] = 8;
            dofs[5] = 9;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            dofs[4] = 6;
            dofs[5] = 7;
            dofs[6] = 9;
            dofs[7] = 10;
            dofs[8] = 11;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 6;
            dofs[5] = 7;
            dofs[6] = 8;
            dofs[7] = 10;
            dofs[8] = 11;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 5;
            dofs[5] = 7;
            dofs[6] = 8;
            dofs[7] = 9;
            dofs[8] = 11;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 4;
            dofs[4] = 5;
            dofs[5] = 6;
            dofs[6] = 8;
            dofs[7] = 9;
            dofs[8] = 10;
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            break;
        }
        break;
    }
}

std::size_t plas3d_dofmap_6::num_sub_dofmaps() const
{
    return 3;
}

ufc::dofmap * plas3d_dofmap_6::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_5();
    case 2:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_dofmap_6::create() const
{
    return new plas3d_dofmap_6();
}


plas3d_dofmap_7::plas3d_dofmap_7() : ufc::dofmap()
{
    // Do nothing
}

plas3d_dofmap_7::~plas3d_dofmap_7()
{
    // Do nothing
}

const char * plas3d_dofmap_7::signature() const
{
    return "FFC dofmap for TensorElement(FiniteElement('Lagrange', tetrahedron, 1), shape=(3, 3), symmetry={})";
}

bool plas3d_dofmap_7::needs_mesh_entities(std::size_t d) const
{
    static const bool return_values[4] = { true, false, false, false };
    if (d >= 4)
        return false;
    return return_values[d];
}

std::size_t plas3d_dofmap_7::topological_dimension() const
{
    return 3;
}

std::size_t plas3d_dofmap_7::global_dimension(const std::vector<std::size_t>&
                                            num_global_entities) const
{
    return 9 * num_global_entities[0];
}

std::size_t plas3d_dofmap_7::num_global_support_dofs() const
{
    return 0;
}

std::size_t plas3d_dofmap_7::num_element_support_dofs() const
{
    return 36;
}

std::size_t plas3d_dofmap_7::num_element_dofs() const
{
    return 36;
}

std::size_t plas3d_dofmap_7::num_facet_dofs() const
{
    return 27;
}

std::size_t plas3d_dofmap_7::num_entity_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 9, 0, 0, 0 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

std::size_t plas3d_dofmap_7::num_entity_closure_dofs(std::size_t d) const
{
    static const std::size_t return_values[4] = { 9, 18, 27, 36 };
    if (d >= 4)
        return 0;
    return return_values[d];
}

void plas3d_dofmap_7::tabulate_dofs(std::size_t * dofs,
                                  const std::vector<std::size_t>& num_global_entities,
                                  const std::vector<std::vector<std::size_t>>& entity_indices) const
{
    std::size_t offset = 0;
    dofs[0] = offset + entity_indices[0][0];
    dofs[1] = offset + entity_indices[0][1];
    dofs[2] = offset + entity_indices[0][2];
    dofs[3] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[4] = offset + entity_indices[0][0];
    dofs[5] = offset + entity_indices[0][1];
    dofs[6] = offset + entity_indices[0][2];
    dofs[7] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[8] = offset + entity_indices[0][0];
    dofs[9] = offset + entity_indices[0][1];
    dofs[10] = offset + entity_indices[0][2];
    dofs[11] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[12] = offset + entity_indices[0][0];
    dofs[13] = offset + entity_indices[0][1];
    dofs[14] = offset + entity_indices[0][2];
    dofs[15] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[16] = offset + entity_indices[0][0];
    dofs[17] = offset + entity_indices[0][1];
    dofs[18] = offset + entity_indices[0][2];
    dofs[19] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[20] = offset + entity_indices[0][0];
    dofs[21] = offset + entity_indices[0][1];
    dofs[22] = offset + entity_indices[0][2];
    dofs[23] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[24] = offset + entity_indices[0][0];
    dofs[25] = offset + entity_indices[0][1];
    dofs[26] = offset + entity_indices[0][2];
    dofs[27] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[28] = offset + entity_indices[0][0];
    dofs[29] = offset + entity_indices[0][1];
    dofs[30] = offset + entity_indices[0][2];
    dofs[31] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
    dofs[32] = offset + entity_indices[0][0];
    dofs[33] = offset + entity_indices[0][1];
    dofs[34] = offset + entity_indices[0][2];
    dofs[35] = offset + entity_indices[0][3];
    offset += num_global_entities[0];
}

void plas3d_dofmap_7::tabulate_facet_dofs(std::size_t * dofs,
                                        std::size_t facet) const
{
    switch (facet)
    {
    case 0:
        dofs[0] = 1;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 5;
        dofs[4] = 6;
        dofs[5] = 7;
        dofs[6] = 9;
        dofs[7] = 10;
        dofs[8] = 11;
        dofs[9] = 13;
        dofs[10] = 14;
        dofs[11] = 15;
        dofs[12] = 17;
        dofs[13] = 18;
        dofs[14] = 19;
        dofs[15] = 21;
        dofs[16] = 22;
        dofs[17] = 23;
        dofs[18] = 25;
        dofs[19] = 26;
        dofs[20] = 27;
        dofs[21] = 29;
        dofs[22] = 30;
        dofs[23] = 31;
        dofs[24] = 33;
        dofs[25] = 34;
        dofs[26] = 35;
        break;
    case 1:
        dofs[0] = 0;
        dofs[1] = 2;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 6;
        dofs[5] = 7;
        dofs[6] = 8;
        dofs[7] = 10;
        dofs[8] = 11;
        dofs[9] = 12;
        dofs[10] = 14;
        dofs[11] = 15;
        dofs[12] = 16;
        dofs[13] = 18;
        dofs[14] = 19;
        dofs[15] = 20;
        dofs[16] = 22;
        dofs[17] = 23;
        dofs[18] = 24;
        dofs[19] = 26;
        dofs[20] = 27;
        dofs[21] = 28;
        dofs[22] = 30;
        dofs[23] = 31;
        dofs[24] = 32;
        dofs[25] = 34;
        dofs[26] = 35;
        break;
    case 2:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 3;
        dofs[3] = 4;
        dofs[4] = 5;
        dofs[5] = 7;
        dofs[6] = 8;
        dofs[7] = 9;
        dofs[8] = 11;
        dofs[9] = 12;
        dofs[10] = 13;
        dofs[11] = 15;
        dofs[12] = 16;
        dofs[13] = 17;
        dofs[14] = 19;
        dofs[15] = 20;
        dofs[16] = 21;
        dofs[17] = 23;
        dofs[18] = 24;
        dofs[19] = 25;
        dofs[20] = 27;
        dofs[21] = 28;
        dofs[22] = 29;
        dofs[23] = 31;
        dofs[24] = 32;
        dofs[25] = 33;
        dofs[26] = 35;
        break;
    case 3:
        dofs[0] = 0;
        dofs[1] = 1;
        dofs[2] = 2;
        dofs[3] = 4;
        dofs[4] = 5;
        dofs[5] = 6;
        dofs[6] = 8;
        dofs[7] = 9;
        dofs[8] = 10;
        dofs[9] = 12;
        dofs[10] = 13;
        dofs[11] = 14;
        dofs[12] = 16;
        dofs[13] = 17;
        dofs[14] = 18;
        dofs[15] = 20;
        dofs[16] = 21;
        dofs[17] = 22;
        dofs[18] = 24;
        dofs[19] = 25;
        dofs[20] = 26;
        dofs[21] = 28;
        dofs[22] = 29;
        dofs[23] = 30;
        dofs[24] = 32;
        dofs[25] = 33;
        dofs[26] = 34;
        break;
    }
}

void plas3d_dofmap_7::tabulate_entity_dofs(std::size_t * dofs,
                                         std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 4;
            dofs[2] = 8;
            dofs[3] = 12;
            dofs[4] = 16;
            dofs[5] = 20;
            dofs[6] = 24;
            dofs[7] = 28;
            dofs[8] = 32;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 5;
            dofs[2] = 9;
            dofs[3] = 13;
            dofs[4] = 17;
            dofs[5] = 21;
            dofs[6] = 25;
            dofs[7] = 29;
            dofs[8] = 33;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 6;
            dofs[2] = 10;
            dofs[3] = 14;
            dofs[4] = 18;
            dofs[5] = 22;
            dofs[6] = 26;
            dofs[7] = 30;
            dofs[8] = 34;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 7;
            dofs[2] = 11;
            dofs[3] = 15;
            dofs[4] = 19;
            dofs[5] = 23;
            dofs[6] = 27;
            dofs[7] = 31;
            dofs[8] = 35;
            break;
        }
        break;
    }
}

void plas3d_dofmap_7::tabulate_entity_closure_dofs(std::size_t * dofs,
                                             std::size_t d, std::size_t i) const
{
    switch (d)
    {
    case 0:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 4;
            dofs[2] = 8;
            dofs[3] = 12;
            dofs[4] = 16;
            dofs[5] = 20;
            dofs[6] = 24;
            dofs[7] = 28;
            dofs[8] = 32;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 5;
            dofs[2] = 9;
            dofs[3] = 13;
            dofs[4] = 17;
            dofs[5] = 21;
            dofs[6] = 25;
            dofs[7] = 29;
            dofs[8] = 33;
            break;
        case 2:
            dofs[0] = 2;
            dofs[1] = 6;
            dofs[2] = 10;
            dofs[3] = 14;
            dofs[4] = 18;
            dofs[5] = 22;
            dofs[6] = 26;
            dofs[7] = 30;
            dofs[8] = 34;
            break;
        case 3:
            dofs[0] = 3;
            dofs[1] = 7;
            dofs[2] = 11;
            dofs[3] = 15;
            dofs[4] = 19;
            dofs[5] = 23;
            dofs[6] = 27;
            dofs[7] = 31;
            dofs[8] = 35;
            break;
        }
        break;
    case 1:
        switch (i)
        {
        case 0:
            dofs[0] = 2;
            dofs[1] = 3;
            dofs[2] = 6;
            dofs[3] = 7;
            dofs[4] = 10;
            dofs[5] = 11;
            dofs[6] = 14;
            dofs[7] = 15;
            dofs[8] = 18;
            dofs[9] = 19;
            dofs[10] = 22;
            dofs[11] = 23;
            dofs[12] = 26;
            dofs[13] = 27;
            dofs[14] = 30;
            dofs[15] = 31;
            dofs[16] = 34;
            dofs[17] = 35;
            break;
        case 1:
            dofs[0] = 1;
            dofs[1] = 3;
            dofs[2] = 5;
            dofs[3] = 7;
            dofs[4] = 9;
            dofs[5] = 11;
            dofs[6] = 13;
            dofs[7] = 15;
            dofs[8] = 17;
            dofs[9] = 19;
            dofs[10] = 21;
            dofs[11] = 23;
            dofs[12] = 25;
            dofs[13] = 27;
            dofs[14] = 29;
            dofs[15] = 31;
            dofs[16] = 33;
            dofs[17] = 35;
            break;
        case 2:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 5;
            dofs[3] = 6;
            dofs[4] = 9;
            dofs[5] = 10;
            dofs[6] = 13;
            dofs[7] = 14;
            dofs[8] = 17;
            dofs[9] = 18;
            dofs[10] = 21;
            dofs[11] = 22;
            dofs[12] = 25;
            dofs[13] = 26;
            dofs[14] = 29;
            dofs[15] = 30;
            dofs[16] = 33;
            dofs[17] = 34;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 3;
            dofs[2] = 4;
            dofs[3] = 7;
            dofs[4] = 8;
            dofs[5] = 11;
            dofs[6] = 12;
            dofs[7] = 15;
            dofs[8] = 16;
            dofs[9] = 19;
            dofs[10] = 20;
            dofs[11] = 23;
            dofs[12] = 24;
            dofs[13] = 27;
            dofs[14] = 28;
            dofs[15] = 31;
            dofs[16] = 32;
            dofs[17] = 35;
            break;
        case 4:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 4;
            dofs[3] = 6;
            dofs[4] = 8;
            dofs[5] = 10;
            dofs[6] = 12;
            dofs[7] = 14;
            dofs[8] = 16;
            dofs[9] = 18;
            dofs[10] = 20;
            dofs[11] = 22;
            dofs[12] = 24;
            dofs[13] = 26;
            dofs[14] = 28;
            dofs[15] = 30;
            dofs[16] = 32;
            dofs[17] = 34;
            break;
        case 5:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 4;
            dofs[3] = 5;
            dofs[4] = 8;
            dofs[5] = 9;
            dofs[6] = 12;
            dofs[7] = 13;
            dofs[8] = 16;
            dofs[9] = 17;
            dofs[10] = 20;
            dofs[11] = 21;
            dofs[12] = 24;
            dofs[13] = 25;
            dofs[14] = 28;
            dofs[15] = 29;
            dofs[16] = 32;
            dofs[17] = 33;
            break;
        }
        break;
    case 2:
        switch (i)
        {
        case 0:
            dofs[0] = 1;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 5;
            dofs[4] = 6;
            dofs[5] = 7;
            dofs[6] = 9;
            dofs[7] = 10;
            dofs[8] = 11;
            dofs[9] = 13;
            dofs[10] = 14;
            dofs[11] = 15;
            dofs[12] = 17;
            dofs[13] = 18;
            dofs[14] = 19;
            dofs[15] = 21;
            dofs[16] = 22;
            dofs[17] = 23;
            dofs[18] = 25;
            dofs[19] = 26;
            dofs[20] = 27;
            dofs[21] = 29;
            dofs[22] = 30;
            dofs[23] = 31;
            dofs[24] = 33;
            dofs[25] = 34;
            dofs[26] = 35;
            break;
        case 1:
            dofs[0] = 0;
            dofs[1] = 2;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 6;
            dofs[5] = 7;
            dofs[6] = 8;
            dofs[7] = 10;
            dofs[8] = 11;
            dofs[9] = 12;
            dofs[10] = 14;
            dofs[11] = 15;
            dofs[12] = 16;
            dofs[13] = 18;
            dofs[14] = 19;
            dofs[15] = 20;
            dofs[16] = 22;
            dofs[17] = 23;
            dofs[18] = 24;
            dofs[19] = 26;
            dofs[20] = 27;
            dofs[21] = 28;
            dofs[22] = 30;
            dofs[23] = 31;
            dofs[24] = 32;
            dofs[25] = 34;
            dofs[26] = 35;
            break;
        case 2:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 3;
            dofs[3] = 4;
            dofs[4] = 5;
            dofs[5] = 7;
            dofs[6] = 8;
            dofs[7] = 9;
            dofs[8] = 11;
            dofs[9] = 12;
            dofs[10] = 13;
            dofs[11] = 15;
            dofs[12] = 16;
            dofs[13] = 17;
            dofs[14] = 19;
            dofs[15] = 20;
            dofs[16] = 21;
            dofs[17] = 23;
            dofs[18] = 24;
            dofs[19] = 25;
            dofs[20] = 27;
            dofs[21] = 28;
            dofs[22] = 29;
            dofs[23] = 31;
            dofs[24] = 32;
            dofs[25] = 33;
            dofs[26] = 35;
            break;
        case 3:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 4;
            dofs[4] = 5;
            dofs[5] = 6;
            dofs[6] = 8;
            dofs[7] = 9;
            dofs[8] = 10;
            dofs[9] = 12;
            dofs[10] = 13;
            dofs[11] = 14;
            dofs[12] = 16;
            dofs[13] = 17;
            dofs[14] = 18;
            dofs[15] = 20;
            dofs[16] = 21;
            dofs[17] = 22;
            dofs[18] = 24;
            dofs[19] = 25;
            dofs[20] = 26;
            dofs[21] = 28;
            dofs[22] = 29;
            dofs[23] = 30;
            dofs[24] = 32;
            dofs[25] = 33;
            dofs[26] = 34;
            break;
        }
        break;
    case 3:
        switch (i)
        {
        case 0:
            dofs[0] = 0;
            dofs[1] = 1;
            dofs[2] = 2;
            dofs[3] = 3;
            dofs[4] = 4;
            dofs[5] = 5;
            dofs[6] = 6;
            dofs[7] = 7;
            dofs[8] = 8;
            dofs[9] = 9;
            dofs[10] = 10;
            dofs[11] = 11;
            dofs[12] = 12;
            dofs[13] = 13;
            dofs[14] = 14;
            dofs[15] = 15;
            dofs[16] = 16;
            dofs[17] = 17;
            dofs[18] = 18;
            dofs[19] = 19;
            dofs[20] = 20;
            dofs[21] = 21;
            dofs[22] = 22;
            dofs[23] = 23;
            dofs[24] = 24;
            dofs[25] = 25;
            dofs[26] = 26;
            dofs[27] = 27;
            dofs[28] = 28;
            dofs[29] = 29;
            dofs[30] = 30;
            dofs[31] = 31;
            dofs[32] = 32;
            dofs[33] = 33;
            dofs[34] = 34;
            dofs[35] = 35;
            break;
        }
        break;
    }
}

std::size_t plas3d_dofmap_7::num_sub_dofmaps() const
{
    return 9;
}

ufc::dofmap * plas3d_dofmap_7::create_sub_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_5();
    case 2:
        return new plas3d_dofmap_5();
    case 3:
        return new plas3d_dofmap_5();
    case 4:
        return new plas3d_dofmap_5();
    case 5:
        return new plas3d_dofmap_5();
    case 6:
        return new plas3d_dofmap_5();
    case 7:
        return new plas3d_dofmap_5();
    case 8:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_dofmap_7::create() const
{
    return new plas3d_dofmap_7();
}


plas3d_coordinate_mapping_6::plas3d_coordinate_mapping_6() : ufc::coordinate_mapping()
{
    // Do nothing
}

plas3d_coordinate_mapping_6::~plas3d_coordinate_mapping_6()
{
    // Do nothing
}

const char * plas3d_coordinate_mapping_6::signature() const
{
    return "FFC coordinate_mapping from VectorElement(FiniteElement('Lagrange', tetrahedron, 1), dim=3)";
}

ufc::coordinate_mapping * plas3d_coordinate_mapping_6::create() const
{
    return new plas3d_coordinate_mapping_6();
}

std::size_t plas3d_coordinate_mapping_6::geometric_dimension() const
{
    return 3;
}

std::size_t plas3d_coordinate_mapping_6::topological_dimension() const
{
    return 3;
}

ufc::shape plas3d_coordinate_mapping_6::cell_shape() const
{
    return ufc::shape::tetrahedron;
}

ufc::finite_element * plas3d_coordinate_mapping_6::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_coordinate_mapping_6::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

void plas3d_coordinate_mapping_6::compute_physical_coordinates(
    double * x, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    plas3d_finite_element_5 xelement;
    double phi[4];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis values of coordinate element
        xelement.evaluate_reference_basis(phi, 1, &X[3 * ip]);
        // Compute x
        for (std::size_t i = 0; i < 3; ++i)
            for (std::size_t d = 0; d < 4; ++d)
                x[3 * ip + i] += coordinate_dofs[3 * d + i] * phi[d];
    }
}

void plas3d_coordinate_mapping_6::compute_reference_coordinates(
    double * X, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[4] = { 1.0, 0.0, 0.0, 0.0 };
    const double dphi_X0[3][4] =
        { { -1.0, 1.0, 0.0, 0.0 },
          { -1.0, 0.0, 1.0, 0.0 },
          { -1.0, 0.0, 0.0, 1.0 } };
    double J[9];
    double detJ[1];
    double K[9];
    double x0[3] = {};
    for (std::size_t i = 0; i < 3; ++i)
        for (std::size_t k = 0; k < 4; ++k)
            x0[i] += coordinate_dofs[3 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 3; ++i)
    {
        for (std::size_t j = 0; j < 3; ++j)
        {
            J[3 * i + j] = 0.0;
            for (std::size_t k = 0; k < 4; ++k)
                J[3 * i + j] += coordinate_dofs[3 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 3; ++j)
            for (std::size_t i = 0; i < 3; ++i)
                X[3 * ip + j] += K[3 * j + i] * (x[3 * ip + i] - x0[i]);
}

void plas3d_coordinate_mapping_6::compute_reference_geometry(
    double * X, double * J, double * detJ, double * K, std::size_t num_points,
    const double * x,
    const double * coordinate_dofs, int cell_orientation) const
{
    const double phi_X0[4] = { 1.0, 0.0, 0.0, 0.0 };
    const double dphi_X0[3][4] =
        { { -1.0, 1.0, 0.0, 0.0 },
          { -1.0, 0.0, 1.0, 0.0 },
          { -1.0, 0.0, 0.0, 1.0 } };
    double x0[3] = {};
    for (std::size_t i = 0; i < 3; ++i)
        for (std::size_t k = 0; k < 4; ++k)
            x0[i] += coordinate_dofs[3 * k + i] * phi_X0[k];
    for (std::size_t i = 0; i < 3; ++i)
    {
        for (std::size_t j = 0; j < 3; ++j)
        {
            J[3 * i + j] = 0.0;
            for (std::size_t k = 0; k < 4; ++k)
                J[3 * i + j] += coordinate_dofs[3 * k + i] * dphi_X0[j][k];
        }
    }
    compute_jacobian_determinants(detJ, 1, J, cell_orientation);
    compute_jacobian_inverses(K, 1, J, detJ);
    for (std::size_t ip = 0; ip < num_points; ++ip)
        for (std::size_t j = 0; j < 3; ++j)
            for (std::size_t i = 0; i < 3; ++i)
                X[3 * ip + j] += K[3 * j + i] * (x[3 * ip + i] - x0[i]);
}

void plas3d_coordinate_mapping_6::compute_jacobians(
    double * J, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs) const
{
    plas3d_finite_element_5 xelement;
    double dphi[12];
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        // Compute basis derivatives of coordinate element
        xelement.evaluate_reference_basis_derivatives(dphi, 1, 1, &X[3 * ip]);
        // Compute J
        for (std::size_t i = 0; i < 3; ++i)
            for (std::size_t j = 0; j < 3; ++j)
                for (std::size_t d = 0; d < 4; ++d)
                    J[3 * 3 * ip + 3 * i + j] += coordinate_dofs[3 * d + i] * dphi[3 * d + j];
    }
}

void plas3d_coordinate_mapping_6::compute_jacobian_determinants(
    double * detJ, std::size_t num_points,
    const double * J,
    int cell_orientation) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
        detJ[ip] = J[3 * 3 * ip] * (J[3 * 3 * ip + 3 + 1] * J[3 * 3 * ip + 3 * 2 + 2] - J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2 + 1]) + J[3 * 3 * ip + 1] * (J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2] - J[3 * 3 * ip + 3] * J[3 * 3 * ip + 3 * 2 + 2]) + J[3 * 3 * ip + 2] * (J[3 * 3 * ip + 3] * J[3 * 3 * ip + 3 * 2 + 1] - J[3 * 3 * ip + 3 + 1] * J[3 * 3 * ip + 3 * 2]);
}

void plas3d_coordinate_mapping_6::compute_jacobian_inverses(
    double * K, std::size_t num_points,
    const double * J, const double * detJ) const
{
    for (std::size_t ip = 0; ip < num_points; ++ip)
    {
        K[3 * 3 * ip] = (J[3 * 3 * ip + 3 * 2 + 2] * J[3 * 3 * ip + 3 + 1] - J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2 + 1]) / detJ[ip];
        K[3 * 3 * ip + 1] = (J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3 * 2 + 1] - J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3 * 2 + 2]) / detJ[ip];
        K[3 * 3 * ip + 2] = (J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3 + 2] - J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3 + 1]) / detJ[ip];
        K[3 * 3 * ip + 3] = (J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip + 3 * 2] - J[3 * 3 * ip + 3 * 2 + 2] * J[3 * 3 * ip + 3]) / detJ[ip];
        K[3 * 3 * ip + 3 + 1] = (J[3 * 3 * ip + 3 * 2 + 2] * J[3 * 3 * ip] - J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3 * 2]) / detJ[ip];
        K[3 * 3 * ip + 3 + 2] = (J[3 * 3 * ip + 2] * J[3 * 3 * ip + 3] - J[3 * 3 * ip + 3 + 2] * J[3 * 3 * ip]) / detJ[ip];
        K[3 * 3 * ip + 3 * 2] = (J[3 * 3 * ip + 3] * J[3 * 3 * ip + 3 * 2 + 1] - J[3 * 3 * ip + 3 * 2] * J[3 * 3 * ip + 3 + 1]) / detJ[ip];
        K[3 * 3 * ip + 3 * 2 + 1] = (J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3 * 2] - J[3 * 3 * ip] * J[3 * 3 * ip + 3 * 2 + 1]) / detJ[ip];
        K[3 * 3 * ip + 3 * 2 + 2] = (J[3 * 3 * ip] * J[3 * 3 * ip + 3 + 1] - J[3 * 3 * ip + 1] * J[3 * 3 * ip + 3]) / detJ[ip];
    }
}

void plas3d_coordinate_mapping_6::compute_geometry(
    double * x, double * J, double * detJ, double * K, std::size_t num_points,
    const double * X,
    const double * coordinate_dofs, int cell_orientation) const
{
    compute_physical_coordinates(x, num_points, X, coordinate_dofs);
    compute_jacobians(J, num_points, X, coordinate_dofs);
    compute_jacobian_determinants(detJ, num_points, J, cell_orientation);
    compute_jacobian_inverses(K, num_points, J, detJ);
}

void plas3d_coordinate_mapping_6::compute_midpoint_geometry(
    double * x, double * J,
    const double * coordinate_dofs) const
{
    const double phi_Xm[4] = { 0.25000000000000006, 0.24999999999999997, 0.25, 0.25 };
    const double dphi_Xm[3][4] =
        { { -1.0, 1.0, 0.0, 0.0 },
          { -1.0, 0.0, 1.0, 0.0 },
          { -1.0, 0.0, 0.0, 1.0 } };
    // Compute x
    for (std::size_t i = 0; i < 3; ++i)
        for (std::size_t d = 0; d < 4; ++d)
            x[i] += coordinate_dofs[3 * d + i] * phi_Xm[d];
    // Compute J
    for (std::size_t i = 0; i < 3; ++i)
        for (std::size_t j = 0; j < 3; ++j)
            for (std::size_t d = 0; d < 4; ++d)
                J[3 * i + j] += coordinate_dofs[3 * d + i] * dphi_Xm[j][d];
}


plas3d_cell_integral_0_otherwise::plas3d_cell_integral_0_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_0_otherwise::~plas3d_cell_integral_0_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_0_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true});
return enabled;
}

void plas3d_cell_integral_0_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 4
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    const double volume = std::abs(detJ)/6.0;
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE1_C0_D001[5][10] = \
    {{0.0, -1.885229172310387e-15, 0.0, -3.679135974939942e-15, 1.000000000000001, 1.000000000000006, -2.243920102470784e-15, 0.0, -1.0, -1},
    {0.3333333333333342, -2.316362320731295e-15, 0.0, -0.3333333333333372, 0.666666666666668, 2.000000000000008, -2.187199124775406e-15, -1.095906633075524e-15, -0.6666666666666665, -2.0},
    {0.3333333333333339, -1.011850266796735e-15, 0.0, -0.3333333333333374, 2.000000000000002, 0.6666666666666718, -3.672122420211553e-15, 0.0, -2.0, -0.6666666666666663},
    {0.333333333333334, -2.28491983960103e-15, 1.11994551437464e-15, 0.9999999999999971, 0.6666666666666652, 0.6666666666666737, -1.747949220781824e-15, -1.333333333333334, -0.666666666666666, -0.6666666666666671},
    {-0.9999999999999999, -1.859437530302942e-15, 0.0, -0.3333333333333374, 0.6666666666666682, 0.6666666666666721, -1.93844115146427e-15, 1.333333333333334, -0.6666666666666669, -0.6666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc13[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc17[10] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc21[10] = {20, 21, 22, 23, 24, 25, 26, 27, 28, 29};
    
    static const double FE1_C0_D010[5][8] = \
    {{1.149928286731703e-15, -2.523543805893162e-15, -2.835495863052288e-15, 1.000000000000001, 1.000000000000006, -1.000000000000001, 0.0, -1.000000000000001},
    {0.3333333333333348, -2.93011074809286e-15, -0.3333333333333359, 0.6666666666666674, 2.000000000000006, -0.6666666666666673, -1.535291929935322e-15, -2.000000000000001},
    {0.3333333333333344, -2.980558178472686e-15, 0.9999999999999967, 0.6666666666666674, 0.6666666666666731, -0.6666666666666671, -1.333333333333334, -0.6666666666666673},
    {0.3333333333333347, -1.885325904241424e-15, -0.3333333333333356, 2.000000000000002, 0.6666666666666701, -2.000000000000002, 0.0, -0.6666666666666667},
    {-0.9999999999999993, -2.428597000849257e-15, -0.3333333333333363, 0.6666666666666674, 0.6666666666666716, -0.6666666666666673, 1.333333333333333, -0.6666666666666671}};
    
    // Array of non-zero columns
    static const unsigned int nzc14[8] = {0, 1, 2, 4, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc18[8] = {10, 11, 12, 14, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc22[8] = {20, 21, 22, 24, 26, 27, 28, 29};
    
    static const double FE1_C0_D100[5][7] = \
    {{1.023181226563178e-15, -1.106447953410065e-15, 1.000000000000001, 1.000000000000001, -1.000000000000001, -1.000000000000001, 0.0},
    {0.3333333333333342, 0.999999999999999, 0.6666666666666671, 0.6666666666666671, -0.6666666666666669, -0.6666666666666674, -1.333333333333333},
    {0.3333333333333345, -0.333333333333335, 0.6666666666666672, 2.000000000000001, -0.6666666666666671, -2.000000000000002, 0.0},
    {0.3333333333333345, -0.3333333333333345, 2.000000000000002, 0.6666666666666667, -2.000000000000002, -0.666666666666667, 0.0},
    {-0.9999999999999991, -0.333333333333334, 0.6666666666666673, 0.6666666666666671, -0.6666666666666671, -0.6666666666666674, 1.333333333333333}};
    
    // Array of non-zero columns
    static const unsigned int nzc15[7] = {0, 1, 5, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc19[7] = {10, 11, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc23[7] = {20, 21, 25, 26, 27, 28, 29};
    
    static const double FE2_C0[5][5] = \
    {{1.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc24[5] = {0, 1, 2, 3, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc25[5] = {5, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc26[5] = {10, 11, 12, 13, 14};
    
    // Array of non-zero columns
    static const unsigned int nzc27[5] = {15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc28[5] = {20, 21, 22, 23, 24};
    
    // Array of non-zero columns
    static const unsigned int nzc29[5] = {25, 26, 27, 28, 29};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 30; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 18.
    double G[9];
    G[0] = K[0]*det/volume;
    G[1] = K[3]*det/volume;
    G[2] = K[6]*det/volume;
    G[3] = K[1]*det/volume;
    G[4] = K[4]*det/volume;
    G[5] = K[7]*det/volume;
    G[6] = K[2]*det/volume;
    G[7] = K[5]*det/volume;
    G[8] = K[8]*det/volume;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 1320
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      
      // Total number of operations to compute function values = 42
      for (unsigned int r = 0; r < 7; r++)
      {
        F0 += FE1_C0_D100[ip][r]*w[0][nzc15[r]];
        F3 += FE1_C0_D100[ip][r]*w[0][nzc19[r]];
        F6 += FE1_C0_D100[ip][r]*w[0][nzc23[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 48
      for (unsigned int r = 0; r < 8; r++)
      {
        F1 += FE1_C0_D010[ip][r]*w[0][nzc14[r]];
        F4 += FE1_C0_D010[ip][r]*w[0][nzc18[r]];
        F7 += FE1_C0_D010[ip][r]*w[0][nzc22[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 60
      for (unsigned int r = 0; r < 10; r++)
      {
        F2 += FE1_C0_D001[ip][r]*w[0][nzc13[r]];
        F5 += FE1_C0_D001[ip][r]*w[0][nzc17[r]];
        F8 += FE1_C0_D001[ip][r]*w[0][nzc21[r]];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 54
      double I[6];
      // Number of operations: 6
      I[0] = W5[ip]*(F0*G[0] + F1*G[1] + F2*G[2]);
      
      // Number of operations: 6
      I[1] = W5[ip]*(F3*G[3] + F4*G[4] + F5*G[5]);
      
      // Number of operations: 6
      I[2] = W5[ip]*(F6*G[6] + F7*G[7] + F8*G[8]);
      
      // Number of operations: 12
      I[3] = W5[ip]*(F0*G[3] + F1*G[4] + F2*G[5] + F3*G[0] + F4*G[1] + F5*G[2]);
      
      // Number of operations: 12
      I[4] = W5[ip]*(F0*G[6] + F1*G[7] + F2*G[8] + F6*G[0] + F7*G[1] + F8*G[2]);
      
      // Number of operations: 12
      I[5] = W5[ip]*(F3*G[6] + F4*G[7] + F5*G[8] + F6*G[3] + F7*G[4] + F8*G[5]);
      
      
      // Number of operations for primary indices: 60
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc24[j]] += FE2_C0[ip][j]*I[0];
        // Number of operations to compute entry: 2
        A[nzc25[j]] += FE2_C0[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc26[j]] += FE2_C0[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc27[j]] += FE2_C0[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc28[j]] += FE2_C0[ip][j]*I[4];
        // Number of operations to compute entry: 2
        A[nzc29[j]] += FE2_C0[ip][j]*I[5];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_1_otherwise::plas3d_cell_integral_1_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_1_otherwise::~plas3d_cell_integral_1_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_1_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void plas3d_cell_integral_1_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 3
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    const double volume = std::abs(detJ)/6.0;
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE1_C0[5][5] = \
    {{1.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc12[5] = {0, 1, 2, 3, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc13[5] = {5, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc14[5] = {10, 11, 12, 13, 14};
    
    // Array of non-zero columns
    static const unsigned int nzc15[5] = {15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc16[5] = {20, 21, 22, 23, 24};
    
    // Array of non-zero columns
    static const unsigned int nzc17[5] = {25, 26, 27, 28, 29};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 30; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 1.
    double G[1];
    G[0] = det/volume;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 305
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1
      double I[1];
      // Number of operations: 1
      I[0] = G[0]*W5[ip];
      
      
      // Number of operations for primary indices: 60
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc12[j]] += FE1_C0[ip][j]*I[0];
        // Number of operations to compute entry: 2
        A[nzc13[j]] += FE1_C0[ip][j]*I[0];
        // Number of operations to compute entry: 2
        A[nzc14[j]] += FE1_C0[ip][j]*I[0];
        // Number of operations to compute entry: 2
        A[nzc15[j]] += FE1_C0[ip][j]*I[0];
        // Number of operations to compute entry: 2
        A[nzc16[j]] += FE1_C0[ip][j]*I[0];
        // Number of operations to compute entry: 2
        A[nzc17[j]] += FE1_C0[ip][j]*I[0];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_2_otherwise::plas3d_cell_integral_2_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_2_otherwise::~plas3d_cell_integral_2_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_2_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true});
return enabled;
}

void plas3d_cell_integral_2_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 5
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE1_C0_D001[5][10] = \
    {{0.0, -1.885229172310387e-15, 0.0, -3.679135974939942e-15, 1.000000000000001, 1.000000000000006, -2.243920102470784e-15, 0.0, -1.0, -1},
    {0.3333333333333342, -2.316362320731295e-15, 0.0, -0.3333333333333372, 0.666666666666668, 2.000000000000008, -2.187199124775406e-15, -1.095906633075524e-15, -0.6666666666666665, -2.0},
    {0.3333333333333339, -1.011850266796735e-15, 0.0, -0.3333333333333374, 2.000000000000002, 0.6666666666666718, -3.672122420211553e-15, 0.0, -2.0, -0.6666666666666663},
    {0.333333333333334, -2.28491983960103e-15, 1.11994551437464e-15, 0.9999999999999971, 0.6666666666666652, 0.6666666666666737, -1.747949220781824e-15, -1.333333333333334, -0.666666666666666, -0.6666666666666671},
    {-0.9999999999999999, -1.859437530302942e-15, 0.0, -0.3333333333333374, 0.6666666666666682, 0.6666666666666721, -1.93844115146427e-15, 1.333333333333334, -0.6666666666666669, -0.6666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc13[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc17[10] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc21[10] = {20, 21, 22, 23, 24, 25, 26, 27, 28, 29};
    
    static const double FE1_C0_D010[5][8] = \
    {{1.149928286731703e-15, -2.523543805893162e-15, -2.835495863052288e-15, 1.000000000000001, 1.000000000000006, -1.000000000000001, 0.0, -1.000000000000001},
    {0.3333333333333348, -2.93011074809286e-15, -0.3333333333333359, 0.6666666666666674, 2.000000000000006, -0.6666666666666673, -1.535291929935322e-15, -2.000000000000001},
    {0.3333333333333344, -2.980558178472686e-15, 0.9999999999999967, 0.6666666666666674, 0.6666666666666731, -0.6666666666666671, -1.333333333333334, -0.6666666666666673},
    {0.3333333333333347, -1.885325904241424e-15, -0.3333333333333356, 2.000000000000002, 0.6666666666666701, -2.000000000000002, 0.0, -0.6666666666666667},
    {-0.9999999999999993, -2.428597000849257e-15, -0.3333333333333363, 0.6666666666666674, 0.6666666666666716, -0.6666666666666673, 1.333333333333333, -0.6666666666666671}};
    
    // Array of non-zero columns
    static const unsigned int nzc14[8] = {0, 1, 2, 4, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc18[8] = {10, 11, 12, 14, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc22[8] = {20, 21, 22, 24, 26, 27, 28, 29};
    
    static const double FE1_C0_D100[5][7] = \
    {{1.023181226563178e-15, -1.106447953410065e-15, 1.000000000000001, 1.000000000000001, -1.000000000000001, -1.000000000000001, 0.0},
    {0.3333333333333342, 0.999999999999999, 0.6666666666666671, 0.6666666666666671, -0.6666666666666669, -0.6666666666666674, -1.333333333333333},
    {0.3333333333333345, -0.333333333333335, 0.6666666666666672, 2.000000000000001, -0.6666666666666671, -2.000000000000002, 0.0},
    {0.3333333333333345, -0.3333333333333345, 2.000000000000002, 0.6666666666666667, -2.000000000000002, -0.666666666666667, 0.0},
    {-0.9999999999999991, -0.333333333333334, 0.6666666666666673, 0.6666666666666671, -0.6666666666666671, -0.6666666666666674, 1.333333333333333}};
    
    // Array of non-zero columns
    static const unsigned int nzc15[7] = {0, 1, 5, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc19[7] = {10, 11, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc23[7] = {20, 21, 25, 26, 27, 28, 29};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 900; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 90.
    double G[45];
    G[0] = K[1]*K[1]*det;
    G[1] = K[1]*K[2]*det;
    G[2] = K[0]*K[2]*det;
    G[3] = K[2]*K[2]*det;
    G[4] = K[0]*K[1]*det;
    G[5] = K[0]*K[0]*det;
    G[6] = K[1]*K[4]*det;
    G[7] = K[1]*K[5]*det;
    G[8] = K[2]*K[3]*det;
    G[9] = K[2]*K[4]*det;
    G[10] = K[2]*K[5]*det;
    G[11] = K[0]*K[4]*det;
    G[12] = K[0]*K[5]*det;
    G[13] = K[1]*K[3]*det;
    G[14] = K[0]*K[3]*det;
    G[15] = K[1]*K[7]*det;
    G[16] = K[1]*K[8]*det;
    G[17] = K[2]*K[6]*det;
    G[18] = K[2]*K[7]*det;
    G[19] = K[2]*K[8]*det;
    G[20] = K[0]*K[7]*det;
    G[21] = K[0]*K[8]*det;
    G[22] = K[1]*K[6]*det;
    G[23] = K[0]*K[6]*det;
    G[24] = K[4]*K[4]*det;
    G[25] = K[4]*K[5]*det;
    G[26] = K[3]*K[5]*det;
    G[27] = K[5]*K[5]*det;
    G[28] = K[3]*K[4]*det;
    G[29] = K[3]*K[3]*det;
    G[30] = K[4]*K[7]*det;
    G[31] = K[4]*K[8]*det;
    G[32] = K[5]*K[6]*det;
    G[33] = K[5]*K[7]*det;
    G[34] = K[5]*K[8]*det;
    G[35] = K[3]*K[7]*det;
    G[36] = K[3]*K[8]*det;
    G[37] = K[4]*K[6]*det;
    G[38] = K[3]*K[6]*det;
    G[39] = K[7]*K[7]*det;
    G[40] = K[7]*K[8]*det;
    G[41] = K[6]*K[8]*det;
    G[42] = K[8]*K[8]*det;
    G[43] = K[6]*K[7]*det;
    G[44] = K[6]*K[6]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 91260
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1377
      double I[81];
      // Number of operations: 15
      I[0] = W5[ip]*(G[0]*w[0][ip + 105] + G[1]*(w[0][ip + 110] + w[0][ip + 135]) + G[2]*(w[0][ip + 120] + w[0][ip + 20]) + G[3]*w[0][ip + 140] + G[4]*(w[0][ip + 15] + w[0][ip + 90]) + G[5]*w[0][ip]);
      
      // Number of operations: 15
      I[1] = W5[ip]*(G[0]*w[0][ip + 95] + G[1]*(w[0][ip + 115] + w[0][ip + 125]) + G[2]*(w[0][ip + 135] + w[0][ip + 25]) + G[3]*w[0][ip + 145] + G[4]*(w[0][ip + 105] + w[0][ip + 5]) + G[5]*w[0][ip + 15]);
      
      // Number of operations: 15
      I[2] = W5[ip]*(G[0]*w[0][ip + 115] + G[1]*(w[0][ip + 100] + w[0][ip + 145]) + G[2]*(w[0][ip + 10] + w[0][ip + 140]) + G[3]*w[0][ip + 130] + G[4]*(w[0][ip + 110] + w[0][ip + 25]) + G[5]*w[0][ip + 20]);
      
      // Number of operations: 15
      I[3] = W5[ip]*(G[0]*w[0][ip + 45] + G[1]*(w[0][ip + 165] + w[0][ip + 50]) + G[2]*(w[0][ip + 110] + w[0][ip + 150]) + G[3]*w[0][ip + 170] + G[4]*(w[0][ip + 105] + w[0][ip + 30]) + G[5]*w[0][ip + 90]);
      
      // Number of operations: 15
      I[4] = W5[ip]*(G[0]*w[0][ip + 35] + G[1]*(w[0][ip + 155] + w[0][ip + 55]) + G[2]*(w[0][ip + 115] + w[0][ip + 165]) + G[3]*w[0][ip + 175] + G[4]*(w[0][ip + 45] + w[0][ip + 95]) + G[5]*w[0][ip + 105]);
      
      // Number of operations: 15
      I[5] = W5[ip]*(G[0]*w[0][ip + 55] + G[1]*(w[0][ip + 175] + w[0][ip + 40]) + G[2]*(w[0][ip + 100] + w[0][ip + 170]) + G[3]*w[0][ip + 160] + G[4]*(w[0][ip + 115] + w[0][ip + 50]) + G[5]*w[0][ip + 110]);
      
      // Number of operations: 15
      I[6] = W5[ip]*(G[0]*w[0][ip + 165] + G[1]*(w[0][ip + 170] + w[0][ip + 75]) + G[2]*(w[0][ip + 140] + w[0][ip + 60]) + G[3]*w[0][ip + 80] + G[4]*(w[0][ip + 135] + w[0][ip + 150]) + G[5]*w[0][ip + 120]);
      
      // Number of operations: 15
      I[7] = W5[ip]*(G[0]*w[0][ip + 155] + G[1]*(w[0][ip + 175] + w[0][ip + 65]) + G[2]*(w[0][ip + 145] + w[0][ip + 75]) + G[3]*w[0][ip + 85] + G[4]*(w[0][ip + 125] + w[0][ip + 165]) + G[5]*w[0][ip + 135]);
      
      // Number of operations: 15
      I[8] = W5[ip]*(G[0]*w[0][ip + 175] + G[1]*(w[0][ip + 160] + w[0][ip + 85]) + G[2]*(w[0][ip + 130] + w[0][ip + 80]) + G[3]*w[0][ip + 70] + G[4]*(w[0][ip + 145] + w[0][ip + 170]) + G[5]*w[0][ip + 140]);
      
      // Number of operations: 18
      I[9] = W5[ip]*(G[10]*w[0][ip + 140] + G[11]*w[0][ip + 15] + G[12]*w[0][ip + 20] + G[13]*w[0][ip + 90] + G[14]*w[0][ip] + G[6]*w[0][ip + 105] + G[7]*w[0][ip + 110] + G[8]*w[0][ip + 120] + G[9]*w[0][ip + 135]);
      
      // Number of operations: 18
      I[10] = W5[ip]*(G[10]*w[0][ip + 145] + G[11]*w[0][ip + 5] + G[12]*w[0][ip + 25] + G[13]*w[0][ip + 105] + G[14]*w[0][ip + 15] + G[6]*w[0][ip + 95] + G[7]*w[0][ip + 115] + G[8]*w[0][ip + 135] + G[9]*w[0][ip + 125]);
      
      // Number of operations: 18
      I[11] = W5[ip]*(G[10]*w[0][ip + 130] + G[11]*w[0][ip + 25] + G[12]*w[0][ip + 10] + G[13]*w[0][ip + 110] + G[14]*w[0][ip + 20] + G[6]*w[0][ip + 115] + G[7]*w[0][ip + 100] + G[8]*w[0][ip + 140] + G[9]*w[0][ip + 145]);
      
      // Number of operations: 18
      I[12] = W5[ip]*(G[10]*w[0][ip + 170] + G[11]*w[0][ip + 105] + G[12]*w[0][ip + 110] + G[13]*w[0][ip + 30] + G[14]*w[0][ip + 90] + G[6]*w[0][ip + 45] + G[7]*w[0][ip + 50] + G[8]*w[0][ip + 150] + G[9]*w[0][ip + 165]);
      
      // Number of operations: 18
      I[13] = W5[ip]*(G[10]*w[0][ip + 175] + G[11]*w[0][ip + 95] + G[12]*w[0][ip + 115] + G[13]*w[0][ip + 45] + G[14]*w[0][ip + 105] + G[6]*w[0][ip + 35] + G[7]*w[0][ip + 55] + G[8]*w[0][ip + 165] + G[9]*w[0][ip + 155]);
      
      // Number of operations: 18
      I[14] = W5[ip]*(G[10]*w[0][ip + 160] + G[11]*w[0][ip + 115] + G[12]*w[0][ip + 100] + G[13]*w[0][ip + 50] + G[14]*w[0][ip + 110] + G[6]*w[0][ip + 55] + G[7]*w[0][ip + 40] + G[8]*w[0][ip + 170] + G[9]*w[0][ip + 175]);
      
      // Number of operations: 18
      I[15] = W5[ip]*(G[10]*w[0][ip + 80] + G[11]*w[0][ip + 135] + G[12]*w[0][ip + 140] + G[13]*w[0][ip + 150] + G[14]*w[0][ip + 120] + G[6]*w[0][ip + 165] + G[7]*w[0][ip + 170] + G[8]*w[0][ip + 60] + G[9]*w[0][ip + 75]);
      
      // Number of operations: 18
      I[16] = W5[ip]*(G[10]*w[0][ip + 85] + G[11]*w[0][ip + 125] + G[12]*w[0][ip + 145] + G[13]*w[0][ip + 165] + G[14]*w[0][ip + 135] + G[6]*w[0][ip + 155] + G[7]*w[0][ip + 175] + G[8]*w[0][ip + 75] + G[9]*w[0][ip + 65]);
      
      // Number of operations: 18
      I[17] = W5[ip]*(G[10]*w[0][ip + 70] + G[11]*w[0][ip + 145] + G[12]*w[0][ip + 130] + G[13]*w[0][ip + 170] + G[14]*w[0][ip + 140] + G[6]*w[0][ip + 175] + G[7]*w[0][ip + 160] + G[8]*w[0][ip + 80] + G[9]*w[0][ip + 85]);
      
      // Number of operations: 18
      I[18] = W5[ip]*(G[15]*w[0][ip + 105] + G[16]*w[0][ip + 110] + G[17]*w[0][ip + 120] + G[18]*w[0][ip + 135] + G[19]*w[0][ip + 140] + G[20]*w[0][ip + 15] + G[21]*w[0][ip + 20] + G[22]*w[0][ip + 90] + G[23]*w[0][ip]);
      
      // Number of operations: 18
      I[19] = W5[ip]*(G[15]*w[0][ip + 95] + G[16]*w[0][ip + 115] + G[17]*w[0][ip + 135] + G[18]*w[0][ip + 125] + G[19]*w[0][ip + 145] + G[20]*w[0][ip + 5] + G[21]*w[0][ip + 25] + G[22]*w[0][ip + 105] + G[23]*w[0][ip + 15]);
      
      // Number of operations: 18
      I[20] = W5[ip]*(G[15]*w[0][ip + 115] + G[16]*w[0][ip + 100] + G[17]*w[0][ip + 140] + G[18]*w[0][ip + 145] + G[19]*w[0][ip + 130] + G[20]*w[0][ip + 25] + G[21]*w[0][ip + 10] + G[22]*w[0][ip + 110] + G[23]*w[0][ip + 20]);
      
      // Number of operations: 18
      I[21] = W5[ip]*(G[15]*w[0][ip + 45] + G[16]*w[0][ip + 50] + G[17]*w[0][ip + 150] + G[18]*w[0][ip + 165] + G[19]*w[0][ip + 170] + G[20]*w[0][ip + 105] + G[21]*w[0][ip + 110] + G[22]*w[0][ip + 30] + G[23]*w[0][ip + 90]);
      
      // Number of operations: 18
      I[22] = W5[ip]*(G[15]*w[0][ip + 35] + G[16]*w[0][ip + 55] + G[17]*w[0][ip + 165] + G[18]*w[0][ip + 155] + G[19]*w[0][ip + 175] + G[20]*w[0][ip + 95] + G[21]*w[0][ip + 115] + G[22]*w[0][ip + 45] + G[23]*w[0][ip + 105]);
      
      // Number of operations: 18
      I[23] = W5[ip]*(G[15]*w[0][ip + 55] + G[16]*w[0][ip + 40] + G[17]*w[0][ip + 170] + G[18]*w[0][ip + 175] + G[19]*w[0][ip + 160] + G[20]*w[0][ip + 115] + G[21]*w[0][ip + 100] + G[22]*w[0][ip + 50] + G[23]*w[0][ip + 110]);
      
      // Number of operations: 18
      I[24] = W5[ip]*(G[15]*w[0][ip + 165] + G[16]*w[0][ip + 170] + G[17]*w[0][ip + 60] + G[18]*w[0][ip + 75] + G[19]*w[0][ip + 80] + G[20]*w[0][ip + 135] + G[21]*w[0][ip + 140] + G[22]*w[0][ip + 150] + G[23]*w[0][ip + 120]);
      
      // Number of operations: 18
      I[25] = W5[ip]*(G[15]*w[0][ip + 155] + G[16]*w[0][ip + 175] + G[17]*w[0][ip + 75] + G[18]*w[0][ip + 65] + G[19]*w[0][ip + 85] + G[20]*w[0][ip + 125] + G[21]*w[0][ip + 145] + G[22]*w[0][ip + 165] + G[23]*w[0][ip + 135]);
      
      // Number of operations: 18
      I[26] = W5[ip]*(G[15]*w[0][ip + 175] + G[16]*w[0][ip + 160] + G[17]*w[0][ip + 80] + G[18]*w[0][ip + 85] + G[19]*w[0][ip + 70] + G[20]*w[0][ip + 145] + G[21]*w[0][ip + 130] + G[22]*w[0][ip + 170] + G[23]*w[0][ip + 140]);
      
      // Number of operations: 18
      I[27] = W5[ip]*(G[10]*w[0][ip + 140] + G[11]*w[0][ip + 90] + G[12]*w[0][ip + 120] + G[13]*w[0][ip + 15] + G[14]*w[0][ip] + G[6]*w[0][ip + 105] + G[7]*w[0][ip + 135] + G[8]*w[0][ip + 20] + G[9]*w[0][ip + 110]);
      
      // Number of operations: 18
      I[28] = W5[ip]*(G[10]*w[0][ip + 145] + G[11]*w[0][ip + 105] + G[12]*w[0][ip + 135] + G[13]*w[0][ip + 5] + G[14]*w[0][ip + 15] + G[6]*w[0][ip + 95] + G[7]*w[0][ip + 125] + G[8]*w[0][ip + 25] + G[9]*w[0][ip + 115]);
      
      // Number of operations: 18
      I[29] = W5[ip]*(G[10]*w[0][ip + 130] + G[11]*w[0][ip + 110] + G[12]*w[0][ip + 140] + G[13]*w[0][ip + 25] + G[14]*w[0][ip + 20] + G[6]*w[0][ip + 115] + G[7]*w[0][ip + 145] + G[8]*w[0][ip + 10] + G[9]*w[0][ip + 100]);
      
      // Number of operations: 18
      I[30] = W5[ip]*(G[10]*w[0][ip + 170] + G[11]*w[0][ip + 30] + G[12]*w[0][ip + 150] + G[13]*w[0][ip + 105] + G[14]*w[0][ip + 90] + G[6]*w[0][ip + 45] + G[7]*w[0][ip + 165] + G[8]*w[0][ip + 110] + G[9]*w[0][ip + 50]);
      
      // Number of operations: 18
      I[31] = W5[ip]*(G[10]*w[0][ip + 175] + G[11]*w[0][ip + 45] + G[12]*w[0][ip + 165] + G[13]*w[0][ip + 95] + G[14]*w[0][ip + 105] + G[6]*w[0][ip + 35] + G[7]*w[0][ip + 155] + G[8]*w[0][ip + 115] + G[9]*w[0][ip + 55]);
      
      // Number of operations: 18
      I[32] = W5[ip]*(G[10]*w[0][ip + 160] + G[11]*w[0][ip + 50] + G[12]*w[0][ip + 170] + G[13]*w[0][ip + 115] + G[14]*w[0][ip + 110] + G[6]*w[0][ip + 55] + G[7]*w[0][ip + 175] + G[8]*w[0][ip + 100] + G[9]*w[0][ip + 40]);
      
      // Number of operations: 18
      I[33] = W5[ip]*(G[10]*w[0][ip + 80] + G[11]*w[0][ip + 150] + G[12]*w[0][ip + 60] + G[13]*w[0][ip + 135] + G[14]*w[0][ip + 120] + G[6]*w[0][ip + 165] + G[7]*w[0][ip + 75] + G[8]*w[0][ip + 140] + G[9]*w[0][ip + 170]);
      
      // Number of operations: 18
      I[34] = W5[ip]*(G[10]*w[0][ip + 85] + G[11]*w[0][ip + 165] + G[12]*w[0][ip + 75] + G[13]*w[0][ip + 125] + G[14]*w[0][ip + 135] + G[6]*w[0][ip + 155] + G[7]*w[0][ip + 65] + G[8]*w[0][ip + 145] + G[9]*w[0][ip + 175]);
      
      // Number of operations: 18
      I[35] = W5[ip]*(G[10]*w[0][ip + 70] + G[11]*w[0][ip + 170] + G[12]*w[0][ip + 80] + G[13]*w[0][ip + 145] + G[14]*w[0][ip + 140] + G[6]*w[0][ip + 175] + G[7]*w[0][ip + 85] + G[8]*w[0][ip + 130] + G[9]*w[0][ip + 160]);
      
      // Number of operations: 15
      I[36] = W5[ip]*(G[24]*w[0][ip + 105] + G[25]*(w[0][ip + 110] + w[0][ip + 135]) + G[26]*(w[0][ip + 120] + w[0][ip + 20]) + G[27]*w[0][ip + 140] + G[28]*(w[0][ip + 15] + w[0][ip + 90]) + G[29]*w[0][ip]);
      
      // Number of operations: 15
      I[37] = W5[ip]*(G[24]*w[0][ip + 95] + G[25]*(w[0][ip + 115] + w[0][ip + 125]) + G[26]*(w[0][ip + 135] + w[0][ip + 25]) + G[27]*w[0][ip + 145] + G[28]*(w[0][ip + 105] + w[0][ip + 5]) + G[29]*w[0][ip + 15]);
      
      // Number of operations: 15
      I[38] = W5[ip]*(G[24]*w[0][ip + 115] + G[25]*(w[0][ip + 100] + w[0][ip + 145]) + G[26]*(w[0][ip + 10] + w[0][ip + 140]) + G[27]*w[0][ip + 130] + G[28]*(w[0][ip + 110] + w[0][ip + 25]) + G[29]*w[0][ip + 20]);
      
      // Number of operations: 15
      I[39] = W5[ip]*(G[24]*w[0][ip + 45] + G[25]*(w[0][ip + 165] + w[0][ip + 50]) + G[26]*(w[0][ip + 110] + w[0][ip + 150]) + G[27]*w[0][ip + 170] + G[28]*(w[0][ip + 105] + w[0][ip + 30]) + G[29]*w[0][ip + 90]);
      
      // Number of operations: 15
      I[40] = W5[ip]*(G[24]*w[0][ip + 35] + G[25]*(w[0][ip + 155] + w[0][ip + 55]) + G[26]*(w[0][ip + 115] + w[0][ip + 165]) + G[27]*w[0][ip + 175] + G[28]*(w[0][ip + 45] + w[0][ip + 95]) + G[29]*w[0][ip + 105]);
      
      // Number of operations: 15
      I[41] = W5[ip]*(G[24]*w[0][ip + 55] + G[25]*(w[0][ip + 175] + w[0][ip + 40]) + G[26]*(w[0][ip + 100] + w[0][ip + 170]) + G[27]*w[0][ip + 160] + G[28]*(w[0][ip + 115] + w[0][ip + 50]) + G[29]*w[0][ip + 110]);
      
      // Number of operations: 15
      I[42] = W5[ip]*(G[24]*w[0][ip + 165] + G[25]*(w[0][ip + 170] + w[0][ip + 75]) + G[26]*(w[0][ip + 140] + w[0][ip + 60]) + G[27]*w[0][ip + 80] + G[28]*(w[0][ip + 135] + w[0][ip + 150]) + G[29]*w[0][ip + 120]);
      
      // Number of operations: 15
      I[43] = W5[ip]*(G[24]*w[0][ip + 155] + G[25]*(w[0][ip + 175] + w[0][ip + 65]) + G[26]*(w[0][ip + 145] + w[0][ip + 75]) + G[27]*w[0][ip + 85] + G[28]*(w[0][ip + 125] + w[0][ip + 165]) + G[29]*w[0][ip + 135]);
      
      // Number of operations: 15
      I[44] = W5[ip]*(G[24]*w[0][ip + 175] + G[25]*(w[0][ip + 160] + w[0][ip + 85]) + G[26]*(w[0][ip + 130] + w[0][ip + 80]) + G[27]*w[0][ip + 70] + G[28]*(w[0][ip + 145] + w[0][ip + 170]) + G[29]*w[0][ip + 140]);
      
      // Number of operations: 18
      I[45] = W5[ip]*(G[30]*w[0][ip + 105] + G[31]*w[0][ip + 110] + G[32]*w[0][ip + 120] + G[33]*w[0][ip + 135] + G[34]*w[0][ip + 140] + G[35]*w[0][ip + 15] + G[36]*w[0][ip + 20] + G[37]*w[0][ip + 90] + G[38]*w[0][ip]);
      
      // Number of operations: 18
      I[46] = W5[ip]*(G[30]*w[0][ip + 95] + G[31]*w[0][ip + 115] + G[32]*w[0][ip + 135] + G[33]*w[0][ip + 125] + G[34]*w[0][ip + 145] + G[35]*w[0][ip + 5] + G[36]*w[0][ip + 25] + G[37]*w[0][ip + 105] + G[38]*w[0][ip + 15]);
      
      // Number of operations: 18
      I[47] = W5[ip]*(G[30]*w[0][ip + 115] + G[31]*w[0][ip + 100] + G[32]*w[0][ip + 140] + G[33]*w[0][ip + 145] + G[34]*w[0][ip + 130] + G[35]*w[0][ip + 25] + G[36]*w[0][ip + 10] + G[37]*w[0][ip + 110] + G[38]*w[0][ip + 20]);
      
      // Number of operations: 18
      I[48] = W5[ip]*(G[30]*w[0][ip + 45] + G[31]*w[0][ip + 50] + G[32]*w[0][ip + 150] + G[33]*w[0][ip + 165] + G[34]*w[0][ip + 170] + G[35]*w[0][ip + 105] + G[36]*w[0][ip + 110] + G[37]*w[0][ip + 30] + G[38]*w[0][ip + 90]);
      
      // Number of operations: 18
      I[49] = W5[ip]*(G[30]*w[0][ip + 35] + G[31]*w[0][ip + 55] + G[32]*w[0][ip + 165] + G[33]*w[0][ip + 155] + G[34]*w[0][ip + 175] + G[35]*w[0][ip + 95] + G[36]*w[0][ip + 115] + G[37]*w[0][ip + 45] + G[38]*w[0][ip + 105]);
      
      // Number of operations: 18
      I[50] = W5[ip]*(G[30]*w[0][ip + 55] + G[31]*w[0][ip + 40] + G[32]*w[0][ip + 170] + G[33]*w[0][ip + 175] + G[34]*w[0][ip + 160] + G[35]*w[0][ip + 115] + G[36]*w[0][ip + 100] + G[37]*w[0][ip + 50] + G[38]*w[0][ip + 110]);
      
      // Number of operations: 18
      I[51] = W5[ip]*(G[30]*w[0][ip + 165] + G[31]*w[0][ip + 170] + G[32]*w[0][ip + 60] + G[33]*w[0][ip + 75] + G[34]*w[0][ip + 80] + G[35]*w[0][ip + 135] + G[36]*w[0][ip + 140] + G[37]*w[0][ip + 150] + G[38]*w[0][ip + 120]);
      
      // Number of operations: 18
      I[52] = W5[ip]*(G[30]*w[0][ip + 155] + G[31]*w[0][ip + 175] + G[32]*w[0][ip + 75] + G[33]*w[0][ip + 65] + G[34]*w[0][ip + 85] + G[35]*w[0][ip + 125] + G[36]*w[0][ip + 145] + G[37]*w[0][ip + 165] + G[38]*w[0][ip + 135]);
      
      // Number of operations: 18
      I[53] = W5[ip]*(G[30]*w[0][ip + 175] + G[31]*w[0][ip + 160] + G[32]*w[0][ip + 80] + G[33]*w[0][ip + 85] + G[34]*w[0][ip + 70] + G[35]*w[0][ip + 145] + G[36]*w[0][ip + 130] + G[37]*w[0][ip + 170] + G[38]*w[0][ip + 140]);
      
      // Number of operations: 18
      I[54] = W5[ip]*(G[15]*w[0][ip + 105] + G[16]*w[0][ip + 135] + G[17]*w[0][ip + 20] + G[18]*w[0][ip + 110] + G[19]*w[0][ip + 140] + G[20]*w[0][ip + 90] + G[21]*w[0][ip + 120] + G[22]*w[0][ip + 15] + G[23]*w[0][ip]);
      
      // Number of operations: 18
      I[55] = W5[ip]*(G[15]*w[0][ip + 95] + G[16]*w[0][ip + 125] + G[17]*w[0][ip + 25] + G[18]*w[0][ip + 115] + G[19]*w[0][ip + 145] + G[20]*w[0][ip + 105] + G[21]*w[0][ip + 135] + G[22]*w[0][ip + 5] + G[23]*w[0][ip + 15]);
      
      // Number of operations: 18
      I[56] = W5[ip]*(G[15]*w[0][ip + 115] + G[16]*w[0][ip + 145] + G[17]*w[0][ip + 10] + G[18]*w[0][ip + 100] + G[19]*w[0][ip + 130] + G[20]*w[0][ip + 110] + G[21]*w[0][ip + 140] + G[22]*w[0][ip + 25] + G[23]*w[0][ip + 20]);
      
      // Number of operations: 18
      I[57] = W5[ip]*(G[15]*w[0][ip + 45] + G[16]*w[0][ip + 165] + G[17]*w[0][ip + 110] + G[18]*w[0][ip + 50] + G[19]*w[0][ip + 170] + G[20]*w[0][ip + 30] + G[21]*w[0][ip + 150] + G[22]*w[0][ip + 105] + G[23]*w[0][ip + 90]);
      
      // Number of operations: 18
      I[58] = W5[ip]*(G[15]*w[0][ip + 35] + G[16]*w[0][ip + 155] + G[17]*w[0][ip + 115] + G[18]*w[0][ip + 55] + G[19]*w[0][ip + 175] + G[20]*w[0][ip + 45] + G[21]*w[0][ip + 165] + G[22]*w[0][ip + 95] + G[23]*w[0][ip + 105]);
      
      // Number of operations: 18
      I[59] = W5[ip]*(G[15]*w[0][ip + 55] + G[16]*w[0][ip + 175] + G[17]*w[0][ip + 100] + G[18]*w[0][ip + 40] + G[19]*w[0][ip + 160] + G[20]*w[0][ip + 50] + G[21]*w[0][ip + 170] + G[22]*w[0][ip + 115] + G[23]*w[0][ip + 110]);
      
      // Number of operations: 18
      I[60] = W5[ip]*(G[15]*w[0][ip + 165] + G[16]*w[0][ip + 75] + G[17]*w[0][ip + 140] + G[18]*w[0][ip + 170] + G[19]*w[0][ip + 80] + G[20]*w[0][ip + 150] + G[21]*w[0][ip + 60] + G[22]*w[0][ip + 135] + G[23]*w[0][ip + 120]);
      
      // Number of operations: 18
      I[61] = W5[ip]*(G[15]*w[0][ip + 155] + G[16]*w[0][ip + 65] + G[17]*w[0][ip + 145] + G[18]*w[0][ip + 175] + G[19]*w[0][ip + 85] + G[20]*w[0][ip + 165] + G[21]*w[0][ip + 75] + G[22]*w[0][ip + 125] + G[23]*w[0][ip + 135]);
      
      // Number of operations: 18
      I[62] = W5[ip]*(G[15]*w[0][ip + 175] + G[16]*w[0][ip + 85] + G[17]*w[0][ip + 130] + G[18]*w[0][ip + 160] + G[19]*w[0][ip + 70] + G[20]*w[0][ip + 170] + G[21]*w[0][ip + 80] + G[22]*w[0][ip + 145] + G[23]*w[0][ip + 140]);
      
      // Number of operations: 18
      I[63] = W5[ip]*(G[30]*w[0][ip + 105] + G[31]*w[0][ip + 135] + G[32]*w[0][ip + 20] + G[33]*w[0][ip + 110] + G[34]*w[0][ip + 140] + G[35]*w[0][ip + 90] + G[36]*w[0][ip + 120] + G[37]*w[0][ip + 15] + G[38]*w[0][ip]);
      
      // Number of operations: 18
      I[64] = W5[ip]*(G[30]*w[0][ip + 95] + G[31]*w[0][ip + 125] + G[32]*w[0][ip + 25] + G[33]*w[0][ip + 115] + G[34]*w[0][ip + 145] + G[35]*w[0][ip + 105] + G[36]*w[0][ip + 135] + G[37]*w[0][ip + 5] + G[38]*w[0][ip + 15]);
      
      // Number of operations: 18
      I[65] = W5[ip]*(G[30]*w[0][ip + 115] + G[31]*w[0][ip + 145] + G[32]*w[0][ip + 10] + G[33]*w[0][ip + 100] + G[34]*w[0][ip + 130] + G[35]*w[0][ip + 110] + G[36]*w[0][ip + 140] + G[37]*w[0][ip + 25] + G[38]*w[0][ip + 20]);
      
      // Number of operations: 18
      I[66] = W5[ip]*(G[30]*w[0][ip + 45] + G[31]*w[0][ip + 165] + G[32]*w[0][ip + 110] + G[33]*w[0][ip + 50] + G[34]*w[0][ip + 170] + G[35]*w[0][ip + 30] + G[36]*w[0][ip + 150] + G[37]*w[0][ip + 105] + G[38]*w[0][ip + 90]);
      
      // Number of operations: 18
      I[67] = W5[ip]*(G[30]*w[0][ip + 35] + G[31]*w[0][ip + 155] + G[32]*w[0][ip + 115] + G[33]*w[0][ip + 55] + G[34]*w[0][ip + 175] + G[35]*w[0][ip + 45] + G[36]*w[0][ip + 165] + G[37]*w[0][ip + 95] + G[38]*w[0][ip + 105]);
      
      // Number of operations: 18
      I[68] = W5[ip]*(G[30]*w[0][ip + 55] + G[31]*w[0][ip + 175] + G[32]*w[0][ip + 100] + G[33]*w[0][ip + 40] + G[34]*w[0][ip + 160] + G[35]*w[0][ip + 50] + G[36]*w[0][ip + 170] + G[37]*w[0][ip + 115] + G[38]*w[0][ip + 110]);
      
      // Number of operations: 18
      I[69] = W5[ip]*(G[30]*w[0][ip + 165] + G[31]*w[0][ip + 75] + G[32]*w[0][ip + 140] + G[33]*w[0][ip + 170] + G[34]*w[0][ip + 80] + G[35]*w[0][ip + 150] + G[36]*w[0][ip + 60] + G[37]*w[0][ip + 135] + G[38]*w[0][ip + 120]);
      
      // Number of operations: 18
      I[70] = W5[ip]*(G[30]*w[0][ip + 155] + G[31]*w[0][ip + 65] + G[32]*w[0][ip + 145] + G[33]*w[0][ip + 175] + G[34]*w[0][ip + 85] + G[35]*w[0][ip + 165] + G[36]*w[0][ip + 75] + G[37]*w[0][ip + 125] + G[38]*w[0][ip + 135]);
      
      // Number of operations: 18
      I[71] = W5[ip]*(G[30]*w[0][ip + 175] + G[31]*w[0][ip + 85] + G[32]*w[0][ip + 130] + G[33]*w[0][ip + 160] + G[34]*w[0][ip + 70] + G[35]*w[0][ip + 170] + G[36]*w[0][ip + 80] + G[37]*w[0][ip + 145] + G[38]*w[0][ip + 140]);
      
      // Number of operations: 15
      I[72] = W5[ip]*(G[39]*w[0][ip + 105] + G[40]*(w[0][ip + 110] + w[0][ip + 135]) + G[41]*(w[0][ip + 120] + w[0][ip + 20]) + G[42]*w[0][ip + 140] + G[43]*(w[0][ip + 15] + w[0][ip + 90]) + G[44]*w[0][ip]);
      
      // Number of operations: 15
      I[73] = W5[ip]*(G[39]*w[0][ip + 95] + G[40]*(w[0][ip + 115] + w[0][ip + 125]) + G[41]*(w[0][ip + 135] + w[0][ip + 25]) + G[42]*w[0][ip + 145] + G[43]*(w[0][ip + 105] + w[0][ip + 5]) + G[44]*w[0][ip + 15]);
      
      // Number of operations: 15
      I[74] = W5[ip]*(G[39]*w[0][ip + 115] + G[40]*(w[0][ip + 100] + w[0][ip + 145]) + G[41]*(w[0][ip + 10] + w[0][ip + 140]) + G[42]*w[0][ip + 130] + G[43]*(w[0][ip + 110] + w[0][ip + 25]) + G[44]*w[0][ip + 20]);
      
      // Number of operations: 15
      I[75] = W5[ip]*(G[39]*w[0][ip + 45] + G[40]*(w[0][ip + 165] + w[0][ip + 50]) + G[41]*(w[0][ip + 110] + w[0][ip + 150]) + G[42]*w[0][ip + 170] + G[43]*(w[0][ip + 105] + w[0][ip + 30]) + G[44]*w[0][ip + 90]);
      
      // Number of operations: 15
      I[76] = W5[ip]*(G[39]*w[0][ip + 35] + G[40]*(w[0][ip + 155] + w[0][ip + 55]) + G[41]*(w[0][ip + 115] + w[0][ip + 165]) + G[42]*w[0][ip + 175] + G[43]*(w[0][ip + 45] + w[0][ip + 95]) + G[44]*w[0][ip + 105]);
      
      // Number of operations: 15
      I[77] = W5[ip]*(G[39]*w[0][ip + 55] + G[40]*(w[0][ip + 175] + w[0][ip + 40]) + G[41]*(w[0][ip + 100] + w[0][ip + 170]) + G[42]*w[0][ip + 160] + G[43]*(w[0][ip + 115] + w[0][ip + 50]) + G[44]*w[0][ip + 110]);
      
      // Number of operations: 15
      I[78] = W5[ip]*(G[39]*w[0][ip + 165] + G[40]*(w[0][ip + 170] + w[0][ip + 75]) + G[41]*(w[0][ip + 140] + w[0][ip + 60]) + G[42]*w[0][ip + 80] + G[43]*(w[0][ip + 135] + w[0][ip + 150]) + G[44]*w[0][ip + 120]);
      
      // Number of operations: 15
      I[79] = W5[ip]*(G[39]*w[0][ip + 155] + G[40]*(w[0][ip + 175] + w[0][ip + 65]) + G[41]*(w[0][ip + 145] + w[0][ip + 75]) + G[42]*w[0][ip + 85] + G[43]*(w[0][ip + 125] + w[0][ip + 165]) + G[44]*w[0][ip + 135]);
      
      // Number of operations: 15
      I[80] = W5[ip]*(G[39]*w[0][ip + 175] + G[40]*(w[0][ip + 160] + w[0][ip + 85]) + G[41]*(w[0][ip + 130] + w[0][ip + 80]) + G[42]*w[0][ip + 70] + G[43]*(w[0][ip + 145] + w[0][ip + 170]) + G[44]*w[0][ip + 140]);
      
      
      // Number of operations for primary indices: 1323
      for (unsigned int j = 0; j < 7; j++)
      {
        for (unsigned int k = 0; k < 7; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc15[j]*30 + nzc15[k]] += FE1_C0_D100[ip][j]*FE1_C0_D100[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc15[j]*30 + nzc19[k]] += FE1_C0_D100[ip][j]*FE1_C0_D100[ip][k]*I[1];
          // Number of operations to compute entry: 3
          A[nzc15[j]*30 + nzc23[k]] += FE1_C0_D100[ip][j]*FE1_C0_D100[ip][k]*I[2];
          // Number of operations to compute entry: 3
          A[nzc19[j]*30 + nzc15[k]] += FE1_C0_D100[ip][j]*FE1_C0_D100[ip][k]*I[3];
          // Number of operations to compute entry: 3
          A[nzc19[j]*30 + nzc19[k]] += FE1_C0_D100[ip][j]*FE1_C0_D100[ip][k]*I[4];
          // Number of operations to compute entry: 3
          A[nzc19[j]*30 + nzc23[k]] += FE1_C0_D100[ip][j]*FE1_C0_D100[ip][k]*I[5];
          // Number of operations to compute entry: 3
          A[nzc23[j]*30 + nzc15[k]] += FE1_C0_D100[ip][j]*FE1_C0_D100[ip][k]*I[6];
          // Number of operations to compute entry: 3
          A[nzc23[j]*30 + nzc19[k]] += FE1_C0_D100[ip][j]*FE1_C0_D100[ip][k]*I[7];
          // Number of operations to compute entry: 3
          A[nzc23[j]*30 + nzc23[k]] += FE1_C0_D100[ip][j]*FE1_C0_D100[ip][k]*I[8];
        } // end loop over 'k'
      } // end loop over 'j'
      
      // Number of operations for primary indices: 1512
      for (unsigned int j = 0; j < 7; j++)
      {
        for (unsigned int k = 0; k < 8; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc15[j]*30 + nzc14[k]] += FE1_C0_D010[ip][k]*FE1_C0_D100[ip][j]*I[9];
          // Number of operations to compute entry: 3
          A[nzc15[j]*30 + nzc18[k]] += FE1_C0_D010[ip][k]*FE1_C0_D100[ip][j]*I[10];
          // Number of operations to compute entry: 3
          A[nzc15[j]*30 + nzc22[k]] += FE1_C0_D010[ip][k]*FE1_C0_D100[ip][j]*I[11];
          // Number of operations to compute entry: 3
          A[nzc19[j]*30 + nzc14[k]] += FE1_C0_D010[ip][k]*FE1_C0_D100[ip][j]*I[12];
          // Number of operations to compute entry: 3
          A[nzc19[j]*30 + nzc18[k]] += FE1_C0_D010[ip][k]*FE1_C0_D100[ip][j]*I[13];
          // Number of operations to compute entry: 3
          A[nzc19[j]*30 + nzc22[k]] += FE1_C0_D010[ip][k]*FE1_C0_D100[ip][j]*I[14];
          // Number of operations to compute entry: 3
          A[nzc23[j]*30 + nzc14[k]] += FE1_C0_D010[ip][k]*FE1_C0_D100[ip][j]*I[15];
          // Number of operations to compute entry: 3
          A[nzc23[j]*30 + nzc18[k]] += FE1_C0_D010[ip][k]*FE1_C0_D100[ip][j]*I[16];
          // Number of operations to compute entry: 3
          A[nzc23[j]*30 + nzc22[k]] += FE1_C0_D010[ip][k]*FE1_C0_D100[ip][j]*I[17];
        } // end loop over 'k'
      } // end loop over 'j'
      
      // Number of operations for primary indices: 1890
      for (unsigned int j = 0; j < 7; j++)
      {
        for (unsigned int k = 0; k < 10; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc15[j]*30 + nzc13[k]] += FE1_C0_D001[ip][k]*FE1_C0_D100[ip][j]*I[18];
          // Number of operations to compute entry: 3
          A[nzc15[j]*30 + nzc17[k]] += FE1_C0_D001[ip][k]*FE1_C0_D100[ip][j]*I[19];
          // Number of operations to compute entry: 3
          A[nzc15[j]*30 + nzc21[k]] += FE1_C0_D001[ip][k]*FE1_C0_D100[ip][j]*I[20];
          // Number of operations to compute entry: 3
          A[nzc19[j]*30 + nzc13[k]] += FE1_C0_D001[ip][k]*FE1_C0_D100[ip][j]*I[21];
          // Number of operations to compute entry: 3
          A[nzc19[j]*30 + nzc17[k]] += FE1_C0_D001[ip][k]*FE1_C0_D100[ip][j]*I[22];
          // Number of operations to compute entry: 3
          A[nzc19[j]*30 + nzc21[k]] += FE1_C0_D001[ip][k]*FE1_C0_D100[ip][j]*I[23];
          // Number of operations to compute entry: 3
          A[nzc23[j]*30 + nzc13[k]] += FE1_C0_D001[ip][k]*FE1_C0_D100[ip][j]*I[24];
          // Number of operations to compute entry: 3
          A[nzc23[j]*30 + nzc17[k]] += FE1_C0_D001[ip][k]*FE1_C0_D100[ip][j]*I[25];
          // Number of operations to compute entry: 3
          A[nzc23[j]*30 + nzc21[k]] += FE1_C0_D001[ip][k]*FE1_C0_D100[ip][j]*I[26];
        } // end loop over 'k'
      } // end loop over 'j'
      
      // Number of operations for primary indices: 1512
      for (unsigned int j = 0; j < 8; j++)
      {
        for (unsigned int k = 0; k < 7; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc14[j]*30 + nzc15[k]] += FE1_C0_D010[ip][j]*FE1_C0_D100[ip][k]*I[27];
          // Number of operations to compute entry: 3
          A[nzc14[j]*30 + nzc19[k]] += FE1_C0_D010[ip][j]*FE1_C0_D100[ip][k]*I[28];
          // Number of operations to compute entry: 3
          A[nzc14[j]*30 + nzc23[k]] += FE1_C0_D010[ip][j]*FE1_C0_D100[ip][k]*I[29];
          // Number of operations to compute entry: 3
          A[nzc18[j]*30 + nzc15[k]] += FE1_C0_D010[ip][j]*FE1_C0_D100[ip][k]*I[30];
          // Number of operations to compute entry: 3
          A[nzc18[j]*30 + nzc19[k]] += FE1_C0_D010[ip][j]*FE1_C0_D100[ip][k]*I[31];
          // Number of operations to compute entry: 3
          A[nzc18[j]*30 + nzc23[k]] += FE1_C0_D010[ip][j]*FE1_C0_D100[ip][k]*I[32];
          // Number of operations to compute entry: 3
          A[nzc22[j]*30 + nzc15[k]] += FE1_C0_D010[ip][j]*FE1_C0_D100[ip][k]*I[33];
          // Number of operations to compute entry: 3
          A[nzc22[j]*30 + nzc19[k]] += FE1_C0_D010[ip][j]*FE1_C0_D100[ip][k]*I[34];
          // Number of operations to compute entry: 3
          A[nzc22[j]*30 + nzc23[k]] += FE1_C0_D010[ip][j]*FE1_C0_D100[ip][k]*I[35];
        } // end loop over 'k'
      } // end loop over 'j'
      
      // Number of operations for primary indices: 1728
      for (unsigned int j = 0; j < 8; j++)
      {
        for (unsigned int k = 0; k < 8; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc14[j]*30 + nzc14[k]] += FE1_C0_D010[ip][j]*FE1_C0_D010[ip][k]*I[36];
          // Number of operations to compute entry: 3
          A[nzc14[j]*30 + nzc18[k]] += FE1_C0_D010[ip][j]*FE1_C0_D010[ip][k]*I[37];
          // Number of operations to compute entry: 3
          A[nzc14[j]*30 + nzc22[k]] += FE1_C0_D010[ip][j]*FE1_C0_D010[ip][k]*I[38];
          // Number of operations to compute entry: 3
          A[nzc18[j]*30 + nzc14[k]] += FE1_C0_D010[ip][j]*FE1_C0_D010[ip][k]*I[39];
          // Number of operations to compute entry: 3
          A[nzc18[j]*30 + nzc18[k]] += FE1_C0_D010[ip][j]*FE1_C0_D010[ip][k]*I[40];
          // Number of operations to compute entry: 3
          A[nzc18[j]*30 + nzc22[k]] += FE1_C0_D010[ip][j]*FE1_C0_D010[ip][k]*I[41];
          // Number of operations to compute entry: 3
          A[nzc22[j]*30 + nzc14[k]] += FE1_C0_D010[ip][j]*FE1_C0_D010[ip][k]*I[42];
          // Number of operations to compute entry: 3
          A[nzc22[j]*30 + nzc18[k]] += FE1_C0_D010[ip][j]*FE1_C0_D010[ip][k]*I[43];
          // Number of operations to compute entry: 3
          A[nzc22[j]*30 + nzc22[k]] += FE1_C0_D010[ip][j]*FE1_C0_D010[ip][k]*I[44];
        } // end loop over 'k'
      } // end loop over 'j'
      
      // Number of operations for primary indices: 2160
      for (unsigned int j = 0; j < 8; j++)
      {
        for (unsigned int k = 0; k < 10; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc14[j]*30 + nzc13[k]] += FE1_C0_D001[ip][k]*FE1_C0_D010[ip][j]*I[45];
          // Number of operations to compute entry: 3
          A[nzc14[j]*30 + nzc17[k]] += FE1_C0_D001[ip][k]*FE1_C0_D010[ip][j]*I[46];
          // Number of operations to compute entry: 3
          A[nzc14[j]*30 + nzc21[k]] += FE1_C0_D001[ip][k]*FE1_C0_D010[ip][j]*I[47];
          // Number of operations to compute entry: 3
          A[nzc18[j]*30 + nzc13[k]] += FE1_C0_D001[ip][k]*FE1_C0_D010[ip][j]*I[48];
          // Number of operations to compute entry: 3
          A[nzc18[j]*30 + nzc17[k]] += FE1_C0_D001[ip][k]*FE1_C0_D010[ip][j]*I[49];
          // Number of operations to compute entry: 3
          A[nzc18[j]*30 + nzc21[k]] += FE1_C0_D001[ip][k]*FE1_C0_D010[ip][j]*I[50];
          // Number of operations to compute entry: 3
          A[nzc22[j]*30 + nzc13[k]] += FE1_C0_D001[ip][k]*FE1_C0_D010[ip][j]*I[51];
          // Number of operations to compute entry: 3
          A[nzc22[j]*30 + nzc17[k]] += FE1_C0_D001[ip][k]*FE1_C0_D010[ip][j]*I[52];
          // Number of operations to compute entry: 3
          A[nzc22[j]*30 + nzc21[k]] += FE1_C0_D001[ip][k]*FE1_C0_D010[ip][j]*I[53];
        } // end loop over 'k'
      } // end loop over 'j'
      
      // Number of operations for primary indices: 1890
      for (unsigned int j = 0; j < 10; j++)
      {
        for (unsigned int k = 0; k < 7; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc13[j]*30 + nzc15[k]] += FE1_C0_D001[ip][j]*FE1_C0_D100[ip][k]*I[54];
          // Number of operations to compute entry: 3
          A[nzc13[j]*30 + nzc19[k]] += FE1_C0_D001[ip][j]*FE1_C0_D100[ip][k]*I[55];
          // Number of operations to compute entry: 3
          A[nzc13[j]*30 + nzc23[k]] += FE1_C0_D001[ip][j]*FE1_C0_D100[ip][k]*I[56];
          // Number of operations to compute entry: 3
          A[nzc17[j]*30 + nzc15[k]] += FE1_C0_D001[ip][j]*FE1_C0_D100[ip][k]*I[57];
          // Number of operations to compute entry: 3
          A[nzc17[j]*30 + nzc19[k]] += FE1_C0_D001[ip][j]*FE1_C0_D100[ip][k]*I[58];
          // Number of operations to compute entry: 3
          A[nzc17[j]*30 + nzc23[k]] += FE1_C0_D001[ip][j]*FE1_C0_D100[ip][k]*I[59];
          // Number of operations to compute entry: 3
          A[nzc21[j]*30 + nzc15[k]] += FE1_C0_D001[ip][j]*FE1_C0_D100[ip][k]*I[60];
          // Number of operations to compute entry: 3
          A[nzc21[j]*30 + nzc19[k]] += FE1_C0_D001[ip][j]*FE1_C0_D100[ip][k]*I[61];
          // Number of operations to compute entry: 3
          A[nzc21[j]*30 + nzc23[k]] += FE1_C0_D001[ip][j]*FE1_C0_D100[ip][k]*I[62];
        } // end loop over 'k'
      } // end loop over 'j'
      
      // Number of operations for primary indices: 2160
      for (unsigned int j = 0; j < 10; j++)
      {
        for (unsigned int k = 0; k < 8; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc13[j]*30 + nzc14[k]] += FE1_C0_D001[ip][j]*FE1_C0_D010[ip][k]*I[63];
          // Number of operations to compute entry: 3
          A[nzc13[j]*30 + nzc18[k]] += FE1_C0_D001[ip][j]*FE1_C0_D010[ip][k]*I[64];
          // Number of operations to compute entry: 3
          A[nzc13[j]*30 + nzc22[k]] += FE1_C0_D001[ip][j]*FE1_C0_D010[ip][k]*I[65];
          // Number of operations to compute entry: 3
          A[nzc17[j]*30 + nzc14[k]] += FE1_C0_D001[ip][j]*FE1_C0_D010[ip][k]*I[66];
          // Number of operations to compute entry: 3
          A[nzc17[j]*30 + nzc18[k]] += FE1_C0_D001[ip][j]*FE1_C0_D010[ip][k]*I[67];
          // Number of operations to compute entry: 3
          A[nzc17[j]*30 + nzc22[k]] += FE1_C0_D001[ip][j]*FE1_C0_D010[ip][k]*I[68];
          // Number of operations to compute entry: 3
          A[nzc21[j]*30 + nzc14[k]] += FE1_C0_D001[ip][j]*FE1_C0_D010[ip][k]*I[69];
          // Number of operations to compute entry: 3
          A[nzc21[j]*30 + nzc18[k]] += FE1_C0_D001[ip][j]*FE1_C0_D010[ip][k]*I[70];
          // Number of operations to compute entry: 3
          A[nzc21[j]*30 + nzc22[k]] += FE1_C0_D001[ip][j]*FE1_C0_D010[ip][k]*I[71];
        } // end loop over 'k'
      } // end loop over 'j'
      
      // Number of operations for primary indices: 2700
      for (unsigned int j = 0; j < 10; j++)
      {
        for (unsigned int k = 0; k < 10; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc13[j]*30 + nzc13[k]] += FE1_C0_D001[ip][j]*FE1_C0_D001[ip][k]*I[72];
          // Number of operations to compute entry: 3
          A[nzc13[j]*30 + nzc17[k]] += FE1_C0_D001[ip][j]*FE1_C0_D001[ip][k]*I[73];
          // Number of operations to compute entry: 3
          A[nzc13[j]*30 + nzc21[k]] += FE1_C0_D001[ip][j]*FE1_C0_D001[ip][k]*I[74];
          // Number of operations to compute entry: 3
          A[nzc17[j]*30 + nzc13[k]] += FE1_C0_D001[ip][j]*FE1_C0_D001[ip][k]*I[75];
          // Number of operations to compute entry: 3
          A[nzc17[j]*30 + nzc17[k]] += FE1_C0_D001[ip][j]*FE1_C0_D001[ip][k]*I[76];
          // Number of operations to compute entry: 3
          A[nzc17[j]*30 + nzc21[k]] += FE1_C0_D001[ip][j]*FE1_C0_D001[ip][k]*I[77];
          // Number of operations to compute entry: 3
          A[nzc21[j]*30 + nzc13[k]] += FE1_C0_D001[ip][j]*FE1_C0_D001[ip][k]*I[78];
          // Number of operations to compute entry: 3
          A[nzc21[j]*30 + nzc17[k]] += FE1_C0_D001[ip][j]*FE1_C0_D001[ip][k]*I[79];
          // Number of operations to compute entry: 3
          A[nzc21[j]*30 + nzc21[k]] += FE1_C0_D001[ip][j]*FE1_C0_D001[ip][k]*I[80];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_3_otherwise::plas3d_cell_integral_3_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_3_otherwise::~plas3d_cell_integral_3_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_3_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_3_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 4
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE1_C0[5][10] = \
    {{-0.1249999999999999, -0.1249999999999999, -0.1249999999999999, -0.125, 0.25, 0.2500000000000001, 0.25, 0.2500000000000001, 0.2499999999999999, 0.2500000000000001},
    {-0.111111111111111, 0.0, -0.111111111111111, -0.1111111111111111, 0.1111111111111111, 0.3333333333333334, 0.3333333333333333, 0.1111111111111112, 0.111111111111111, 0.3333333333333334},
    {-0.111111111111111, -0.111111111111111, 0.0, -0.1111111111111111, 0.3333333333333333, 0.1111111111111111, 0.3333333333333333, 0.1111111111111112, 0.3333333333333333, 0.1111111111111112},
    {-0.1111111111111111, -0.1111111111111111, -0.1111111111111111, 0.0, 0.3333333333333333, 0.3333333333333334, 0.1111111111111111, 0.3333333333333335, 0.111111111111111, 0.1111111111111112},
    {0.0, -0.111111111111111, -0.111111111111111, -0.1111111111111111, 0.1111111111111111, 0.111111111111111, 0.111111111111111, 0.3333333333333334, 0.3333333333333333, 0.3333333333333333}};
    
    // Array of non-zero columns
    static const unsigned int nzc12[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc16[10] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc20[10] = {20, 21, 22, 23, 24, 25, 26, 27, 28, 29};
    
    static const double FE1_C0_D001[5][10] = \
    {{0.0, -1.885229172310387e-15, 0.0, -3.679135974939942e-15, 1.000000000000001, 1.000000000000006, -2.243920102470784e-15, 0.0, -1.0, -1},
    {0.3333333333333342, -2.316362320731295e-15, 0.0, -0.3333333333333372, 0.666666666666668, 2.000000000000008, -2.187199124775406e-15, -1.095906633075524e-15, -0.6666666666666665, -2.0},
    {0.3333333333333339, -1.011850266796735e-15, 0.0, -0.3333333333333374, 2.000000000000002, 0.6666666666666718, -3.672122420211553e-15, 0.0, -2.0, -0.6666666666666663},
    {0.333333333333334, -2.28491983960103e-15, 1.11994551437464e-15, 0.9999999999999971, 0.6666666666666652, 0.6666666666666737, -1.747949220781824e-15, -1.333333333333334, -0.666666666666666, -0.6666666666666671},
    {-0.9999999999999999, -1.859437530302942e-15, 0.0, -0.3333333333333374, 0.6666666666666682, 0.6666666666666721, -1.93844115146427e-15, 1.333333333333334, -0.6666666666666669, -0.6666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc13[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc17[10] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc21[10] = {20, 21, 22, 23, 24, 25, 26, 27, 28, 29};
    
    static const double FE1_C0_D010[5][8] = \
    {{1.149928286731703e-15, -2.523543805893162e-15, -2.835495863052288e-15, 1.000000000000001, 1.000000000000006, -1.000000000000001, 0.0, -1.000000000000001},
    {0.3333333333333348, -2.93011074809286e-15, -0.3333333333333359, 0.6666666666666674, 2.000000000000006, -0.6666666666666673, -1.535291929935322e-15, -2.000000000000001},
    {0.3333333333333344, -2.980558178472686e-15, 0.9999999999999967, 0.6666666666666674, 0.6666666666666731, -0.6666666666666671, -1.333333333333334, -0.6666666666666673},
    {0.3333333333333347, -1.885325904241424e-15, -0.3333333333333356, 2.000000000000002, 0.6666666666666701, -2.000000000000002, 0.0, -0.6666666666666667},
    {-0.9999999999999993, -2.428597000849257e-15, -0.3333333333333363, 0.6666666666666674, 0.6666666666666716, -0.6666666666666673, 1.333333333333333, -0.6666666666666671}};
    
    // Array of non-zero columns
    static const unsigned int nzc14[8] = {0, 1, 2, 4, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc18[8] = {10, 11, 12, 14, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc22[8] = {20, 21, 22, 24, 26, 27, 28, 29};
    
    static const double FE1_C0_D100[5][7] = \
    {{1.023181226563178e-15, -1.106447953410065e-15, 1.000000000000001, 1.000000000000001, -1.000000000000001, -1.000000000000001, 0.0},
    {0.3333333333333342, 0.999999999999999, 0.6666666666666671, 0.6666666666666671, -0.6666666666666669, -0.6666666666666674, -1.333333333333333},
    {0.3333333333333345, -0.333333333333335, 0.6666666666666672, 2.000000000000001, -0.6666666666666671, -2.000000000000002, 0.0},
    {0.3333333333333345, -0.3333333333333345, 2.000000000000002, 0.6666666666666667, -2.000000000000002, -0.666666666666667, 0.0},
    {-0.9999999999999991, -0.333333333333334, 0.6666666666666673, 0.6666666666666671, -0.6666666666666671, -0.6666666666666674, 1.333333333333333}};
    
    // Array of non-zero columns
    static const unsigned int nzc15[7] = {0, 1, 5, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc19[7] = {10, 11, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc23[7] = {20, 21, 25, 26, 27, 28, 29};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 30; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 9.
    double G[9];
    G[0] = K[1]*det;
    G[1] = K[2]*det;
    G[2] = K[0]*det;
    G[3] = K[4]*det;
    G[4] = K[5]*det;
    G[5] = K[3]*det;
    G[6] = K[7]*det;
    G[7] = K[8]*det;
    G[8] = K[6]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 1650
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      
      // Total number of operations to compute function values = 60
      for (unsigned int r = 0; r < 10; r++)
      {
        F0 += FE1_C0[ip][r]*w[0][nzc12[r]];
        F1 += FE1_C0[ip][r]*w[0][nzc16[r]];
        F2 += FE1_C0[ip][r]*w[0][nzc20[r]];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 60
      double I[12];
      // Number of operations: 6
      I[0] = W5[ip]*(G[0]*w[1][ip + 15] + G[1]*w[1][ip + 20] + G[2]*w[1][ip]);
      
      // Number of operations: 6
      I[1] = W5[ip]*(G[0]*w[1][ip + 5] + G[1]*w[1][ip + 25] + G[2]*w[1][ip + 15]);
      
      // Number of operations: 6
      I[2] = W5[ip]*(G[0]*w[1][ip + 25] + G[1]*w[1][ip + 10] + G[2]*w[1][ip + 20]);
      
      // Number of operations: 6
      I[3] = W5[ip]*(G[3]*w[1][ip + 15] + G[4]*w[1][ip + 20] + G[5]*w[1][ip]);
      
      // Number of operations: 6
      I[4] = W5[ip]*(G[3]*w[1][ip + 5] + G[4]*w[1][ip + 25] + G[5]*w[1][ip + 15]);
      
      // Number of operations: 6
      I[5] = W5[ip]*(G[3]*w[1][ip + 25] + G[4]*w[1][ip + 10] + G[5]*w[1][ip + 20]);
      
      // Number of operations: 2
      I[6] =  - F0*W5[ip]*det;
      
      // Number of operations: 6
      I[7] = W5[ip]*(G[6]*w[1][ip + 15] + G[7]*w[1][ip + 20] + G[8]*w[1][ip]);
      
      // Number of operations: 2
      I[8] =  - F1*W5[ip]*det;
      
      // Number of operations: 6
      I[9] = W5[ip]*(G[6]*w[1][ip + 5] + G[7]*w[1][ip + 25] + G[8]*w[1][ip + 15]);
      
      // Number of operations: 2
      I[10] =  - F2*W5[ip]*det;
      
      // Number of operations: 6
      I[11] = W5[ip]*(G[6]*w[1][ip + 25] + G[7]*w[1][ip + 10] + G[8]*w[1][ip + 20]);
      
      
      // Number of operations for primary indices: 42
      for (unsigned int j = 0; j < 7; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc15[j]] += FE1_C0_D100[ip][j]*I[0];
        // Number of operations to compute entry: 2
        A[nzc19[j]] += FE1_C0_D100[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc23[j]] += FE1_C0_D100[ip][j]*I[2];
      } // end loop over 'j'
      
      // Number of operations for primary indices: 48
      for (unsigned int j = 0; j < 8; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc14[j]] += FE1_C0_D010[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc18[j]] += FE1_C0_D010[ip][j]*I[4];
        // Number of operations to compute entry: 2
        A[nzc22[j]] += FE1_C0_D010[ip][j]*I[5];
      } // end loop over 'j'
      
      // Number of operations for primary indices: 120
      for (unsigned int j = 0; j < 10; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc12[j]] += FE1_C0[ip][j]*I[6];
        // Number of operations to compute entry: 2
        A[nzc13[j]] += FE1_C0_D001[ip][j]*I[7];
        // Number of operations to compute entry: 2
        A[nzc16[j]] += FE1_C0[ip][j]*I[8];
        // Number of operations to compute entry: 2
        A[nzc17[j]] += FE1_C0_D001[ip][j]*I[9];
        // Number of operations to compute entry: 2
        A[nzc20[j]] += FE1_C0[ip][j]*I[10];
        // Number of operations to compute entry: 2
        A[nzc21[j]] += FE1_C0_D001[ip][j]*I[11];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_4_otherwise::plas3d_cell_integral_4_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_4_otherwise::~plas3d_cell_integral_4_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_4_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void plas3d_cell_integral_4_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0_C0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[4] = {0, 1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc1[4] = {4, 5, 6, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc2[4] = {8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc3[4] = {12, 13, 14, 15};
    
    // Array of non-zero columns
    static const unsigned int nzc4[4] = {16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc5[4] = {20, 21, 22, 23};
    
    // Array of non-zero columns
    static const unsigned int nzc6[4] = {24, 25, 26, 27};
    
    // Array of non-zero columns
    static const unsigned int nzc7[4] = {28, 29, 30, 31};
    
    // Array of non-zero columns
    static const unsigned int nzc8[4] = {32, 33, 34, 35};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 1296; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 2165
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1
      double I[1];
      // Number of operations: 1
      I[0] = W5[ip]*det;
      
      
      // Number of operations for primary indices: 432
      for (unsigned int j = 0; j < 4; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc0[j]*36 + nzc0[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc1[j]*36 + nzc1[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc2[j]*36 + nzc2[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc3[j]*36 + nzc3[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc4[j]*36 + nzc4[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc5[j]*36 + nzc5[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc6[j]*36 + nzc6[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc7[j]*36 + nzc7[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc8[j]*36 + nzc8[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_5_otherwise::plas3d_cell_integral_5_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_5_otherwise::~plas3d_cell_integral_5_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_5_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_5_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0_C0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[4] = {0, 1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc1[4] = {4, 5, 6, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc2[4] = {8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc3[4] = {12, 13, 14, 15};
    
    // Array of non-zero columns
    static const unsigned int nzc4[4] = {16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc5[4] = {20, 21, 22, 23};
    
    // Array of non-zero columns
    static const unsigned int nzc6[4] = {24, 25, 26, 27};
    
    // Array of non-zero columns
    static const unsigned int nzc7[4] = {28, 29, 30, 31};
    
    // Array of non-zero columns
    static const unsigned int nzc8[4] = {32, 33, 34, 35};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc12[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc14[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc15[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc16[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc18[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc19[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc20[2] = {8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 36; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 27.
    double G[18];
    G[0] = K[3]*det;
    G[1] = K[6]*det;
    G[2] = K[0]*det;
    G[3] = 0.5*K[4]*det;
    G[4] = 0.5*K[7]*det;
    G[5] = 0.5*K[0]*det;
    G[6] = 0.5*K[3]*det;
    G[7] = 0.5*K[6]*det;
    G[8] = 0.5*K[1]*det;
    G[9] = 0.5*K[5]*det;
    G[10] = 0.5*K[8]*det;
    G[11] = 0.5*K[2]*det;
    G[12] = K[1]*det;
    G[13] = K[4]*det;
    G[14] = K[7]*det;
    G[15] = K[2]*det;
    G[16] = K[5]*det;
    G[17] = K[8]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 1440
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      double F10 = 0.0;
      double F11 = 0.0;
      double F12 = 0.0;
      double F13 = 0.0;
      double F14 = 0.0;
      double F15 = 0.0;
      double F16 = 0.0;
      double F17 = 0.0;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F9 += FE1_C0_D001[ip][r]*w[0][nzc12[r]];
        F10 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F11 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F12 += FE1_C0_D001[ip][r]*w[0][nzc16[r]];
        F13 += FE1_C0_D001[ip][r]*w[0][nzc15[r]];
        F14 += FE1_C0_D001[ip][r]*w[0][nzc14[r]];
        F15 += FE1_C0_D001[ip][r]*w[0][nzc20[r]];
        F16 += FE1_C0_D001[ip][r]*w[0][nzc19[r]];
        F17 += FE1_C0_D001[ip][r]*w[0][nzc18[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 72
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0_C0[ip][r]*w[1][nzc0[r]];
        F1 += FE0_C0[ip][r]*w[1][nzc3[r]];
        F2 += FE0_C0[ip][r]*w[1][nzc6[r]];
        F3 += FE0_C0[ip][r]*w[1][nzc1[r]];
        F4 += FE0_C0[ip][r]*w[1][nzc4[r]];
        F5 += FE0_C0[ip][r]*w[1][nzc7[r]];
        F6 += FE0_C0[ip][r]*w[1][nzc2[r]];
        F7 += FE0_C0[ip][r]*w[1][nzc5[r]];
        F8 += FE0_C0[ip][r]*w[1][nzc8[r]];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 108
      double I[9];
      // Number of operations: 8
      I[0] = W5[ip]*(F10*G[0] + F11*G[1] + F9*G[2] - F0*det);
      
      // Number of operations: 14
      I[1] = W5[ip]*(F10*G[3] + F11*G[4] + F12*G[5] + F13*G[6] + F14*G[7] + F9*G[8] - F3*det);
      
      // Number of operations: 14
      I[2] = W5[ip]*(F10*G[9] + F11*G[10] + F15*G[5] + F16*G[6] + F17*G[7] + F9*G[11] - F6*det);
      
      // Number of operations: 14
      I[3] = W5[ip]*(F10*G[3] + F11*G[4] + F12*G[5] + F13*G[6] + F14*G[7] + F9*G[8] - F1*det);
      
      // Number of operations: 8
      I[4] = W5[ip]*(F12*G[12] + F13*G[13] + F14*G[14] - F4*det);
      
      // Number of operations: 14
      I[5] = W5[ip]*(F12*G[11] + F13*G[9] + F14*G[10] + F15*G[8] + F16*G[3] + F17*G[4] - F7*det);
      
      // Number of operations: 14
      I[6] = W5[ip]*(F10*G[9] + F11*G[10] + F15*G[5] + F16*G[6] + F17*G[7] + F9*G[11] - F2*det);
      
      // Number of operations: 14
      I[7] = W5[ip]*(F12*G[11] + F13*G[9] + F14*G[10] + F15*G[8] + F16*G[3] + F17*G[4] - F5*det);
      
      // Number of operations: 8
      I[8] = W5[ip]*(F15*G[15] + F16*G[16] + F17*G[17] - F8*det);
      
      
      // Number of operations for primary indices: 72
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc0[j]] += FE0_C0[ip][j]*I[0];
        // Number of operations to compute entry: 2
        A[nzc1[j]] += FE0_C0[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc2[j]] += FE0_C0[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc3[j]] += FE0_C0[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE0_C0[ip][j]*I[4];
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE0_C0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE0_C0[ip][j]*I[6];
        // Number of operations to compute entry: 2
        A[nzc7[j]] += FE0_C0[ip][j]*I[7];
        // Number of operations to compute entry: 2
        A[nzc8[j]] += FE0_C0[ip][j]*I[8];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_6_otherwise::plas3d_cell_integral_6_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_6_otherwise::~plas3d_cell_integral_6_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_6_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void plas3d_cell_integral_6_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0_C0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[4] = {0, 1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc1[4] = {4, 5, 6, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc2[4] = {8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc3[4] = {12, 13, 14, 15};
    
    // Array of non-zero columns
    static const unsigned int nzc4[4] = {16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc5[4] = {20, 21, 22, 23};
    
    // Array of non-zero columns
    static const unsigned int nzc6[4] = {24, 25, 26, 27};
    
    // Array of non-zero columns
    static const unsigned int nzc7[4] = {28, 29, 30, 31};
    
    // Array of non-zero columns
    static const unsigned int nzc8[4] = {32, 33, 34, 35};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 1296; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 2165
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1
      double I[1];
      // Number of operations: 1
      I[0] = W5[ip]*det;
      
      
      // Number of operations for primary indices: 432
      for (unsigned int j = 0; j < 4; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc0[j]*36 + nzc0[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc1[j]*36 + nzc1[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc2[j]*36 + nzc2[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc3[j]*36 + nzc3[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc4[j]*36 + nzc4[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc5[j]*36 + nzc5[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc6[j]*36 + nzc6[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc7[j]*36 + nzc7[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc8[j]*36 + nzc8[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_7_otherwise::plas3d_cell_integral_7_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_7_otherwise::~plas3d_cell_integral_7_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_7_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_7_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 4
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0_C0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[4] = {0, 1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc1[4] = {4, 5, 6, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc2[4] = {8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc3[4] = {12, 13, 14, 15};
    
    // Array of non-zero columns
    static const unsigned int nzc4[4] = {16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc5[4] = {20, 21, 22, 23};
    
    // Array of non-zero columns
    static const unsigned int nzc6[4] = {24, 25, 26, 27};
    
    // Array of non-zero columns
    static const unsigned int nzc7[4] = {28, 29, 30, 31};
    
    // Array of non-zero columns
    static const unsigned int nzc8[4] = {32, 33, 34, 35};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 36; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 855
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      
      // Total number of operations to compute function values = 72
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0_C0[ip][r]*w[0][nzc0[r]];
        F1 += FE0_C0[ip][r]*w[0][nzc3[r]];
        F2 += FE0_C0[ip][r]*w[0][nzc6[r]];
        F3 += FE0_C0[ip][r]*w[0][nzc1[r]];
        F4 += FE0_C0[ip][r]*w[0][nzc4[r]];
        F5 += FE0_C0[ip][r]*w[0][nzc7[r]];
        F6 += FE0_C0[ip][r]*w[0][nzc2[r]];
        F7 += FE0_C0[ip][r]*w[0][nzc5[r]];
        F8 += FE0_C0[ip][r]*w[0][nzc8[r]];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 27
      double I[9];
      // Number of operations: 3
      I[0] = W5[ip]*det*(w[1][ip] - F0);
      
      // Number of operations: 3
      I[1] = W5[ip]*det*(w[1][ip + 15] - F3);
      
      // Number of operations: 3
      I[2] = W5[ip]*det*(w[1][ip + 20] - F6);
      
      // Number of operations: 3
      I[3] = W5[ip]*det*(w[1][ip + 15] - F1);
      
      // Number of operations: 3
      I[4] = W5[ip]*det*(w[1][ip + 5] - F4);
      
      // Number of operations: 3
      I[5] = W5[ip]*det*(w[1][ip + 25] - F7);
      
      // Number of operations: 3
      I[6] = W5[ip]*det*(w[1][ip + 20] - F2);
      
      // Number of operations: 3
      I[7] = W5[ip]*det*(w[1][ip + 25] - F5);
      
      // Number of operations: 3
      I[8] = W5[ip]*det*(w[1][ip + 10] - F8);
      
      
      // Number of operations for primary indices: 72
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc0[j]] += FE0_C0[ip][j]*I[0];
        // Number of operations to compute entry: 2
        A[nzc1[j]] += FE0_C0[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc2[j]] += FE0_C0[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc3[j]] += FE0_C0[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE0_C0[ip][j]*I[4];
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE0_C0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE0_C0[ip][j]*I[6];
        // Number of operations to compute entry: 2
        A[nzc7[j]] += FE0_C0[ip][j]*I[7];
        // Number of operations to compute entry: 2
        A[nzc8[j]] += FE0_C0[ip][j]*I[8];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_8_otherwise::plas3d_cell_integral_8_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_8_otherwise::~plas3d_cell_integral_8_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_8_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void plas3d_cell_integral_8_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0_C0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[4] = {0, 1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc1[4] = {4, 5, 6, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc2[4] = {8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc3[4] = {12, 13, 14, 15};
    
    // Array of non-zero columns
    static const unsigned int nzc4[4] = {16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc5[4] = {20, 21, 22, 23};
    
    // Array of non-zero columns
    static const unsigned int nzc6[4] = {24, 25, 26, 27};
    
    // Array of non-zero columns
    static const unsigned int nzc7[4] = {28, 29, 30, 31};
    
    // Array of non-zero columns
    static const unsigned int nzc8[4] = {32, 33, 34, 35};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 1296; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 2165
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1
      double I[1];
      // Number of operations: 1
      I[0] = W5[ip]*det;
      
      
      // Number of operations for primary indices: 432
      for (unsigned int j = 0; j < 4; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[nzc0[j]*36 + nzc0[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc1[j]*36 + nzc1[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc2[j]*36 + nzc2[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc3[j]*36 + nzc3[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc4[j]*36 + nzc4[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc5[j]*36 + nzc5[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc6[j]*36 + nzc6[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc7[j]*36 + nzc7[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
          // Number of operations to compute entry: 3
          A[nzc8[j]*36 + nzc8[k]] += FE0_C0[ip][j]*FE0_C0[ip][k]*I[0];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_9_otherwise::plas3d_cell_integral_9_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_9_otherwise::~plas3d_cell_integral_9_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_9_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true});
return enabled;
}

void plas3d_cell_integral_9_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 4
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0_C0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[4] = {0, 1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc1[4] = {4, 5, 6, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc2[4] = {8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc3[4] = {12, 13, 14, 15};
    
    // Array of non-zero columns
    static const unsigned int nzc4[4] = {16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc5[4] = {20, 21, 22, 23};
    
    // Array of non-zero columns
    static const unsigned int nzc6[4] = {24, 25, 26, 27};
    
    // Array of non-zero columns
    static const unsigned int nzc7[4] = {28, 29, 30, 31};
    
    // Array of non-zero columns
    static const unsigned int nzc8[4] = {32, 33, 34, 35};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc12[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc14[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc15[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc16[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc18[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc19[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc20[2] = {8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 36; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 57.
    double G[30];
    G[0] = 3844444.444444444*K[3]*det;
    G[1] = 3844444.444444444*K[6]*det;
    G[2] = 961111.1111111111*K[1]*det;
    G[3] = 961111.1111111111*K[4]*det;
    G[4] = 961111.1111111111*K[7]*det;
    G[5] = 961111.1111111111*K[2]*det;
    G[6] = 961111.1111111111*K[5]*det;
    G[7] = 961111.1111111111*K[8]*det;
    G[8] = 3844444.444444444*K[0]*det;
    G[9] = -961111.1111111111*det;
    G[10] = -3844444.444444444*det;
    G[11] = 1441666.666666667*K[4]*det;
    G[12] = 1441666.666666667*K[7]*det;
    G[13] = 1441666.666666667*K[0]*det;
    G[14] = 1441666.666666667*K[3]*det;
    G[15] = 1441666.666666667*K[6]*det;
    G[16] = 1441666.666666667*K[1]*det;
    G[17] = -2883333.333333333*det;
    G[18] = 1441666.666666667*K[5]*det;
    G[19] = 1441666.666666667*K[8]*det;
    G[20] = 1441666.666666667*K[2]*det;
    G[21] = 961111.1111111111*K[3]*det;
    G[22] = 961111.1111111111*K[6]*det;
    G[23] = 3844444.444444444*K[1]*det;
    G[24] = 3844444.444444444*K[4]*det;
    G[25] = 3844444.444444444*K[7]*det;
    G[26] = 961111.1111111111*K[0]*det;
    G[27] = 3844444.444444444*K[2]*det;
    G[28] = 3844444.444444444*K[5]*det;
    G[29] = 3844444.444444444*K[8]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 1755
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      double F10 = 0.0;
      double F11 = 0.0;
      double F12 = 0.0;
      double F13 = 0.0;
      double F14 = 0.0;
      double F15 = 0.0;
      double F16 = 0.0;
      double F17 = 0.0;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F9 += FE1_C0_D001[ip][r]*w[1][nzc12[r]];
        F10 += FE1_C0_D001[ip][r]*w[1][nzc11[r]];
        F11 += FE1_C0_D001[ip][r]*w[1][nzc10[r]];
        F12 += FE1_C0_D001[ip][r]*w[1][nzc16[r]];
        F13 += FE1_C0_D001[ip][r]*w[1][nzc15[r]];
        F14 += FE1_C0_D001[ip][r]*w[1][nzc14[r]];
        F15 += FE1_C0_D001[ip][r]*w[1][nzc20[r]];
        F16 += FE1_C0_D001[ip][r]*w[1][nzc19[r]];
        F17 += FE1_C0_D001[ip][r]*w[1][nzc18[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 72
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0_C0[ip][r]*w[0][nzc0[r]];
        F1 += FE0_C0[ip][r]*w[0][nzc3[r]];
        F2 += FE0_C0[ip][r]*w[0][nzc6[r]];
        F3 += FE0_C0[ip][r]*w[0][nzc1[r]];
        F4 += FE0_C0[ip][r]*w[0][nzc4[r]];
        F5 += FE0_C0[ip][r]*w[0][nzc7[r]];
        F6 += FE0_C0[ip][r]*w[0][nzc2[r]];
        F7 += FE0_C0[ip][r]*w[0][nzc5[r]];
        F8 += FE0_C0[ip][r]*w[0][nzc8[r]];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 171
      double I[9];
      // Number of operations: 25
      I[0] = W5[ip]*(F10*G[0] + F11*G[1] + F12*G[2] + F13*G[3] + F14*G[4] + F15*G[5] + F16*G[6] + F17*G[7] + F9*G[8] + G[10]*w[2][ip] + G[9]*(w[2][ip + 10] + w[2][ip + 5]) - F0*det);
      
      // Number of operations: 16
      I[1] = W5[ip]*(F10*G[11] + F11*G[12] + F12*G[13] + F13*G[14] + F14*G[15] + F9*G[16] + G[17]*w[2][ip + 15] - F3*det);
      
      // Number of operations: 16
      I[2] = W5[ip]*(F10*G[18] + F11*G[19] + F15*G[13] + F16*G[14] + F17*G[15] + F9*G[20] + G[17]*w[2][ip + 20] - F6*det);
      
      // Number of operations: 16
      I[3] = W5[ip]*(F10*G[11] + F11*G[12] + F12*G[13] + F13*G[14] + F14*G[15] + F9*G[16] + G[17]*w[2][ip + 15] - F1*det);
      
      // Number of operations: 25
      I[4] = W5[ip]*(F10*G[21] + F11*G[22] + F12*G[23] + F13*G[24] + F14*G[25] + F15*G[5] + F16*G[6] + F17*G[7] + F9*G[26] + G[10]*w[2][ip + 5] + G[9]*(w[2][ip + 10] + w[2][ip]) - F4*det);
      
      // Number of operations: 16
      I[5] = W5[ip]*(F12*G[20] + F13*G[18] + F14*G[19] + F15*G[16] + F16*G[11] + F17*G[12] + G[17]*w[2][ip + 25] - F7*det);
      
      // Number of operations: 16
      I[6] = W5[ip]*(F10*G[18] + F11*G[19] + F15*G[13] + F16*G[14] + F17*G[15] + F9*G[20] + G[17]*w[2][ip + 20] - F2*det);
      
      // Number of operations: 16
      I[7] = W5[ip]*(F12*G[20] + F13*G[18] + F14*G[19] + F15*G[16] + F16*G[11] + F17*G[12] + G[17]*w[2][ip + 25] - F5*det);
      
      // Number of operations: 25
      I[8] = W5[ip]*(F10*G[21] + F11*G[22] + F12*G[2] + F13*G[3] + F14*G[4] + F15*G[27] + F16*G[28] + F17*G[29] + F9*G[26] + G[10]*w[2][ip + 10] + G[9]*(w[2][ip + 5] + w[2][ip]) - F8*det);
      
      
      // Number of operations for primary indices: 72
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc0[j]] += FE0_C0[ip][j]*I[0];
        // Number of operations to compute entry: 2
        A[nzc1[j]] += FE0_C0[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc2[j]] += FE0_C0[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc3[j]] += FE0_C0[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE0_C0[ip][j]*I[4];
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE0_C0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE0_C0[ip][j]*I[6];
        // Number of operations to compute entry: 2
        A[nzc7[j]] += FE0_C0[ip][j]*I[7];
        // Number of operations to compute entry: 2
        A[nzc8[j]] += FE0_C0[ip][j]*I[8];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_10_otherwise::plas3d_cell_integral_10_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_10_otherwise::~plas3d_cell_integral_10_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_10_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void plas3d_cell_integral_10_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 16; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 245
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1
      double I[1];
      // Number of operations: 1
      I[0] = W5[ip]*det;
      
      
      // Number of operations for primary indices: 48
      for (unsigned int j = 0; j < 4; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[j*4 + k] += FE0[ip][j]*FE0[ip][k]*I[0];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_11_otherwise::plas3d_cell_integral_11_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_11_otherwise::~plas3d_cell_integral_11_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_11_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true});
return enabled;
}

void plas3d_cell_integral_11_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 4
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc3[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc7[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 4; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 19.
    double G[10];
    G[0] = -1922222.222222222*K[0]*det;
    G[1] = -1922222.222222222*K[3]*det;
    G[2] = -1922222.222222222*K[6]*det;
    G[3] = -1922222.222222222*K[1]*det;
    G[4] = -1922222.222222222*K[4]*det;
    G[5] = -1922222.222222222*K[7]*det;
    G[6] = -1922222.222222222*K[2]*det;
    G[7] = -1922222.222222222*K[5]*det;
    G[8] = -1922222.222222222*K[8]*det;
    G[9] = 1922222.222222222*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 380
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F1 += FE1_C0_D001[ip][r]*w[0][nzc3[r]];
        F2 += FE1_C0_D001[ip][r]*w[0][nzc2[r]];
        F3 += FE1_C0_D001[ip][r]*w[0][nzc1[r]];
        F4 += FE1_C0_D001[ip][r]*w[0][nzc7[r]];
        F5 += FE1_C0_D001[ip][r]*w[0][nzc6[r]];
        F6 += FE1_C0_D001[ip][r]*w[0][nzc5[r]];
        F7 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F8 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F9 += FE1_C0_D001[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[2][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 24
      double I[1];
      // Number of operations: 24
      I[0] = W5[ip]*(F1*G[0] + F2*G[1] + F3*G[2] + F4*G[3] + F5*G[4] + F6*G[5] + F7*G[6] + F8*G[7] + F9*G[8] + G[9]*(w[1][ip + 10] + w[1][ip + 5] + w[1][ip]) - F0*det);
      
      
      // Number of operations for primary indices: 8
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[j] += FE0[ip][j]*I[0];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_12_otherwise::plas3d_cell_integral_12_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_12_otherwise::~plas3d_cell_integral_12_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_12_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void plas3d_cell_integral_12_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 16; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 245
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1
      double I[1];
      // Number of operations: 1
      I[0] = W5[ip]*det;
      
      
      // Number of operations for primary indices: 48
      for (unsigned int j = 0; j < 4; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[j*4 + k] += FE0[ip][j]*FE0[ip][k]*I[0];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_13_otherwise::plas3d_cell_integral_13_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_13_otherwise::~plas3d_cell_integral_13_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_13_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true});
return enabled;
}

void plas3d_cell_integral_13_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 9
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc3[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc7[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 4; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 8170
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F1 += FE1_C0_D001[ip][r]*w[0][nzc3[r]];
        F2 += FE1_C0_D001[ip][r]*w[0][nzc2[r]];
        F3 += FE1_C0_D001[ip][r]*w[0][nzc1[r]];
        F4 += FE1_C0_D001[ip][r]*w[0][nzc7[r]];
        F5 += FE1_C0_D001[ip][r]*w[0][nzc6[r]];
        F6 += FE1_C0_D001[ip][r]*w[0][nzc5[r]];
        F7 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F8 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F9 += FE1_C0_D001[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[2][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 1582
      double I[1];
      // Number of operations: 1582
      I[0] = W5[ip]*det*(std::sqrt(1.5*((2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])))*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]))) + (2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])))*(2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]))) + (2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])))*(2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]))) + 2883333.333333333*(0.5*(F1*K[1] + F2*K[4] + F3*K[7] + F4*K[0] + F5*K[3] + F6*K[6]) - w[1][ip + 15])*2883333.333333333*(0.5*(F1*K[1] + F2*K[4] + F3*K[7] + F4*K[0] + F5*K[3] + F6*K[6]) - w[1][ip + 15]) + 2883333.333333333*(0.5*(F1*K[1] + F2*K[4] + F3*K[7] + F4*K[0] + F5*K[3] + F6*K[6]) - w[1][ip + 15])*2883333.333333333*(0.5*(F1*K[1] + F2*K[4] + F3*K[7] + F4*K[0] + F5*K[3] + F6*K[6]) - w[1][ip + 15]) + 2883333.333333333*(0.5*(F1*K[2] + F2*K[5] + F3*K[8] + F7*K[0] + F8*K[3] + F9*K[6]) - w[1][ip + 20])*2883333.333333333*(0.5*(F1*K[2] + F2*K[5] + F3*K[8] + F7*K[0] + F8*K[3] + F9*K[6]) - w[1][ip + 20]) + 2883333.333333333*(0.5*(F1*K[2] + F2*K[5] + F3*K[8] + F7*K[0] + F8*K[3] + F9*K[6]) - w[1][ip + 20])*2883333.333333333*(0.5*(F1*K[2] + F2*K[5] + F3*K[8] + F7*K[0] + F8*K[3] + F9*K[6]) - w[1][ip + 20]) + 2883333.333333333*(0.5*(F4*K[2] + F5*K[5] + F6*K[8] + F7*K[1] + F8*K[4] + F9*K[7]) - w[1][ip + 25])*2883333.333333333*(0.5*(F4*K[2] + F5*K[5] + F6*K[8] + F7*K[1] + F8*K[4] + F9*K[7]) - w[1][ip + 25]) + 2883333.333333333*(0.5*(F4*K[2] + F5*K[5] + F6*K[8] + F7*K[1] + F8*K[4] + F9*K[7]) - w[1][ip + 25])*2883333.333333333*(0.5*(F4*K[2] + F5*K[5] + F6*K[8] + F7*K[1] + F8*K[4] + F9*K[7]) - w[1][ip + 25]))) - F0);
      
      
      // Number of operations for primary indices: 8
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[j] += FE0[ip][j]*I[0];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_14_otherwise::plas3d_cell_integral_14_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_14_otherwise::~plas3d_cell_integral_14_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_14_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void plas3d_cell_integral_14_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 16; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 245
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1
      double I[1];
      // Number of operations: 1
      I[0] = W5[ip]*det;
      
      
      // Number of operations for primary indices: 48
      for (unsigned int j = 0; j < 4; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[j*4 + k] += FE0[ip][j]*FE0[ip][k]*I[0];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_15_otherwise::plas3d_cell_integral_15_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_15_otherwise::~plas3d_cell_integral_15_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_15_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_15_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc3[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc7[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 4; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 9.
    double G[9];
    G[0] = K[0]*det;
    G[1] = K[3]*det;
    G[2] = K[6]*det;
    G[3] = K[1]*det;
    G[4] = K[4]*det;
    G[5] = K[7]*det;
    G[6] = K[2]*det;
    G[7] = K[5]*det;
    G[8] = K[8]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 360
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F1 += FE1_C0_D001[ip][r]*w[0][nzc3[r]];
        F2 += FE1_C0_D001[ip][r]*w[0][nzc2[r]];
        F3 += FE1_C0_D001[ip][r]*w[0][nzc1[r]];
        F4 += FE1_C0_D001[ip][r]*w[0][nzc7[r]];
        F5 += FE1_C0_D001[ip][r]*w[0][nzc6[r]];
        F6 += FE1_C0_D001[ip][r]*w[0][nzc5[r]];
        F7 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F8 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F9 += FE1_C0_D001[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[1][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 20
      double I[1];
      // Number of operations: 20
      I[0] = W5[ip]*(F1*G[0] + F2*G[1] + F3*G[2] + F4*G[3] + F5*G[4] + F6*G[5] + F7*G[6] + F8*G[7] + F9*G[8] - F0*det);
      
      
      // Number of operations for primary indices: 8
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[j] += FE0[ip][j]*I[0];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_16_otherwise::plas3d_cell_integral_16_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_16_otherwise::~plas3d_cell_integral_16_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_16_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void plas3d_cell_integral_16_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 16; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 245
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1
      double I[1];
      // Number of operations: 1
      I[0] = W5[ip]*det;
      
      
      // Number of operations for primary indices: 48
      for (unsigned int j = 0; j < 4; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[j*4 + k] += FE0[ip][j]*FE0[ip][k]*I[0];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_17_otherwise::plas3d_cell_integral_17_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_17_otherwise::~plas3d_cell_integral_17_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_17_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_17_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 4; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 3.
    double G[3];
    G[0] = K[2]*det;
    G[1] = K[5]*det;
    G[2] = K[8]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 180
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      
      // Total number of operations to compute function values = 12
      for (unsigned int r = 0; r < 2; r++)
      {
        F0 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F1 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F2 += FE1_C0_D001[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F3 += FE0[ip][r]*w[1][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 8
      double I[1];
      // Number of operations: 8
      I[0] = W5[ip]*(F0*G[0] + F1*G[1] + F2*G[2] - F3*det);
      
      
      // Number of operations for primary indices: 8
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[j] += FE0[ip][j]*I[0];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_18_otherwise::plas3d_cell_integral_18_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_18_otherwise::~plas3d_cell_integral_18_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_18_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void plas3d_cell_integral_18_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 16; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 245
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1
      double I[1];
      // Number of operations: 1
      I[0] = W5[ip]*det;
      
      
      // Number of operations for primary indices: 48
      for (unsigned int j = 0; j < 4; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[j*4 + k] += FE0[ip][j]*FE0[ip][k]*I[0];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_19_otherwise::plas3d_cell_integral_19_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_19_otherwise::~plas3d_cell_integral_19_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_19_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_19_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 4
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 4; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 105
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[1][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 5
      double I[1];
      // Number of operations: 5
      I[0] = W5[ip]*det*(w[0][ip + 10] + w[0][ip + 5] + w[0][ip] - F0);
      
      
      // Number of operations for primary indices: 8
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[j] += FE0[ip][j]*I[0];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_20_otherwise::plas3d_cell_integral_20_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_20_otherwise::~plas3d_cell_integral_20_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_20_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void plas3d_cell_integral_20_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 16; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 245
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1
      double I[1];
      // Number of operations: 1
      I[0] = W5[ip]*det;
      
      
      // Number of operations for primary indices: 48
      for (unsigned int j = 0; j < 4; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[j*4 + k] += FE0[ip][j]*FE0[ip][k]*I[0];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_21_otherwise::plas3d_cell_integral_21_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_21_otherwise::~plas3d_cell_integral_21_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_21_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_21_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc3[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc7[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 4; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 180.
    double G[45];
    G[0] = det*(0.5*(K[1]*K[1] + K[2]*K[2]) + K[0]*K[0]);
    G[1] = det*(2.0*K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[2] = det*(2.0*K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[3] = K[0]*K[1]*det;
    G[4] = K[1]*K[3]*det;
    G[5] = K[1]*K[6]*det;
    G[6] = K[0]*K[2]*det;
    G[7] = K[2]*K[3]*det;
    G[8] = K[2]*K[6]*det;
    G[9] = det*(0.5*(K[4]*K[4] + K[5]*K[5]) + K[3]*K[3]);
    G[10] = det*(2.0*K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[11] = K[0]*K[4]*det;
    G[12] = K[3]*K[4]*det;
    G[13] = K[4]*K[6]*det;
    G[14] = K[0]*K[5]*det;
    G[15] = K[3]*K[5]*det;
    G[16] = K[5]*K[6]*det;
    G[17] = det*(0.5*(K[7]*K[7] + K[8]*K[8]) + K[6]*K[6]);
    G[18] = K[0]*K[7]*det;
    G[19] = K[3]*K[7]*det;
    G[20] = K[6]*K[7]*det;
    G[21] = K[0]*K[8]*det;
    G[22] = K[3]*K[8]*det;
    G[23] = K[6]*K[8]*det;
    G[24] = det*(0.5*(K[0]*K[0] + K[2]*K[2]) + K[1]*K[1]);
    G[25] = det*(2.0*K[1]*K[4] + K[0]*K[3] + K[2]*K[5]);
    G[26] = det*(2.0*K[1]*K[7] + K[0]*K[6] + K[2]*K[8]);
    G[27] = K[1]*K[2]*det;
    G[28] = K[2]*K[4]*det;
    G[29] = K[2]*K[7]*det;
    G[30] = det*(0.5*(K[3]*K[3] + K[5]*K[5]) + K[4]*K[4]);
    G[31] = det*(2.0*K[4]*K[7] + K[3]*K[6] + K[5]*K[8]);
    G[32] = K[1]*K[5]*det;
    G[33] = K[4]*K[5]*det;
    G[34] = K[5]*K[7]*det;
    G[35] = det*(0.5*(K[6]*K[6] + K[8]*K[8]) + K[7]*K[7]);
    G[36] = K[1]*K[8]*det;
    G[37] = K[4]*K[8]*det;
    G[38] = K[7]*K[8]*det;
    G[39] = det*(0.5*(K[0]*K[0] + K[1]*K[1]) + K[2]*K[2]);
    G[40] = det*(2.0*K[2]*K[5] + K[0]*K[3] + K[1]*K[4]);
    G[41] = det*(2.0*K[2]*K[8] + K[0]*K[6] + K[1]*K[7]);
    G[42] = det*(0.5*(K[3]*K[3] + K[4]*K[4]) + K[5]*K[5]);
    G[43] = det*(2.0*K[5]*K[8] + K[3]*K[6] + K[4]*K[7]);
    G[44] = det*(0.5*(K[6]*K[6] + K[7]*K[7]) + K[8]*K[8]);
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 765
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F1 += FE1_C0_D001[ip][r]*w[0][nzc3[r]];
        F2 += FE1_C0_D001[ip][r]*w[0][nzc2[r]];
        F3 += FE1_C0_D001[ip][r]*w[0][nzc1[r]];
        F4 += FE1_C0_D001[ip][r]*w[0][nzc7[r]];
        F5 += FE1_C0_D001[ip][r]*w[0][nzc6[r]];
        F6 += FE1_C0_D001[ip][r]*w[0][nzc5[r]];
        F7 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F8 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F9 += FE1_C0_D001[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[1][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 101
      double I[1];
      // Number of operations: 101
      I[0] = W5[ip]*(F1*F1*G[0] + F2*(F1*G[1] + F2*G[9]) + F3*(F1*G[2] + F2*G[10] + F3*G[17]) + F4*(F1*G[3] + F2*G[11] + F3*G[18] + F4*G[24]) + F5*(F1*G[4] + F2*G[12] + F3*G[19] + F4*G[25] + F5*G[30]) + F6*(F1*G[5] + F2*G[13] + F3*G[20] + F4*G[26] + F5*G[31] + F6*G[35]) + F7*(F1*G[6] + F2*G[14] + F3*G[21] + F4*G[27] + F5*G[32] + F6*G[36] + F7*G[39]) + F8*(F1*G[7] + F2*G[15] + F3*G[22] + F4*G[28] + F5*G[33] + F6*G[37] + F7*G[40] + F8*G[42]) + F9*(F1*G[8] + F2*G[16] + F3*G[23] + F4*G[29] + F5*G[34] + F6*G[38] + F7*G[41] + F8*G[43] + F9*G[44]) - F0*det);
      
      
      // Number of operations for primary indices: 8
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[j] += FE0[ip][j]*I[0];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_22_otherwise::plas3d_cell_integral_22_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_22_otherwise::~plas3d_cell_integral_22_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_22_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({});
return enabled;
}

void plas3d_cell_integral_22_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 2
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 16; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 245
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Number of operations to compute ip constants: 1
      double I[1];
      // Number of operations: 1
      I[0] = W5[ip]*det;
      
      
      // Number of operations for primary indices: 48
      for (unsigned int j = 0; j < 4; j++)
      {
        for (unsigned int k = 0; k < 4; k++)
        {
          // Number of operations to compute entry: 3
          A[j*4 + k] += FE0[ip][j]*FE0[ip][k]*I[0];
        } // end loop over 'k'
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_23_otherwise::plas3d_cell_integral_23_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_23_otherwise::~plas3d_cell_integral_23_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_23_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_23_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 7
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 4; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 1.
    double G[1];
    G[0] = 2.0*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 155
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[1][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 15
      double I[1];
      // Number of operations: 15
      I[0] = W5[ip]*(G[0]*(w[0][ip + 15]*w[0][ip + 15] + w[0][ip + 20]*w[0][ip + 20] + w[0][ip + 25]*w[0][ip + 25]) + det*(w[0][ip + 10]*w[0][ip + 10] + w[0][ip + 5]*w[0][ip + 5] + w[0][ip]*w[0][ip] - F0));
      
      
      // Number of operations for primary indices: 8
      for (unsigned int j = 0; j < 4; j++)
      {
        // Number of operations to compute entry: 2
        A[j] += FE0[ip][j]*I[0];
      } // end loop over 'j'
    } // end loop over 'ip'
}


plas3d_cell_integral_24_otherwise::plas3d_cell_integral_24_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_24_otherwise::~plas3d_cell_integral_24_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_24_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_24_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 1
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc3[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc7[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    // Number of operations to compute geometry constants: 9.
    double G[9];
    G[0] = K[0]*det;
    G[1] = K[3]*det;
    G[2] = K[6]*det;
    G[3] = K[1]*det;
    G[4] = K[4]*det;
    G[5] = K[7]*det;
    G[6] = K[2]*det;
    G[7] = K[5]*det;
    G[8] = K[8]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 325
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F1 += FE1_C0_D001[ip][r]*w[0][nzc3[r]];
        F2 += FE1_C0_D001[ip][r]*w[0][nzc2[r]];
        F3 += FE1_C0_D001[ip][r]*w[0][nzc1[r]];
        F4 += FE1_C0_D001[ip][r]*w[0][nzc7[r]];
        F5 += FE1_C0_D001[ip][r]*w[0][nzc6[r]];
        F6 += FE1_C0_D001[ip][r]*w[0][nzc5[r]];
        F7 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F8 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F9 += FE1_C0_D001[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[1][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 20
      double I[1];
      // Number of operations: 20
      I[0] = W5[ip]*(F1*G[0] + F2*G[1] + F3*G[2] + F4*G[3] + F5*G[4] + F6*G[5] + F7*G[6] + F8*G[7] + F9*G[8] - F0*det);
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    } // end loop over 'ip'
}


plas3d_cell_integral_25_otherwise::plas3d_cell_integral_25_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_25_otherwise::~plas3d_cell_integral_25_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_25_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_25_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 3
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 70
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[1][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 5
      double I[1];
      // Number of operations: 5
      I[0] = W5[ip]*det*(w[0][ip + 10] + w[0][ip + 5] + w[0][ip] - F0);
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    } // end loop over 'ip'
}


plas3d_cell_integral_26_otherwise::plas3d_cell_integral_26_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_26_otherwise::~plas3d_cell_integral_26_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_26_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_26_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 1
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    // Number of operations to compute geometry constants: 3.
    double G[3];
    G[0] = K[2]*det;
    G[1] = K[5]*det;
    G[2] = K[8]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 145
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      
      // Total number of operations to compute function values = 12
      for (unsigned int r = 0; r < 2; r++)
      {
        F0 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F1 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F2 += FE1_C0_D001[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F3 += FE0[ip][r]*w[1][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 8
      double I[1];
      // Number of operations: 8
      I[0] = W5[ip]*(F0*G[0] + F1*G[1] + F2*G[2] - F3*det);
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    } // end loop over 'ip'
}


plas3d_cell_integral_27_otherwise::plas3d_cell_integral_27_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_27_otherwise::~plas3d_cell_integral_27_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_27_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_27_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 1
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc3[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc7[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    // Number of operations to compute geometry constants: 180.
    double G[45];
    G[0] = det*(0.5*(K[1]*K[1] + K[2]*K[2]) + K[0]*K[0]);
    G[1] = det*(2.0*K[0]*K[3] + K[1]*K[4] + K[2]*K[5]);
    G[2] = det*(2.0*K[0]*K[6] + K[1]*K[7] + K[2]*K[8]);
    G[3] = K[0]*K[1]*det;
    G[4] = K[1]*K[3]*det;
    G[5] = K[1]*K[6]*det;
    G[6] = K[0]*K[2]*det;
    G[7] = K[2]*K[3]*det;
    G[8] = K[2]*K[6]*det;
    G[9] = det*(0.5*(K[4]*K[4] + K[5]*K[5]) + K[3]*K[3]);
    G[10] = det*(2.0*K[3]*K[6] + K[4]*K[7] + K[5]*K[8]);
    G[11] = K[0]*K[4]*det;
    G[12] = K[3]*K[4]*det;
    G[13] = K[4]*K[6]*det;
    G[14] = K[0]*K[5]*det;
    G[15] = K[3]*K[5]*det;
    G[16] = K[5]*K[6]*det;
    G[17] = det*(0.5*(K[7]*K[7] + K[8]*K[8]) + K[6]*K[6]);
    G[18] = K[0]*K[7]*det;
    G[19] = K[3]*K[7]*det;
    G[20] = K[6]*K[7]*det;
    G[21] = K[0]*K[8]*det;
    G[22] = K[3]*K[8]*det;
    G[23] = K[6]*K[8]*det;
    G[24] = det*(0.5*(K[0]*K[0] + K[2]*K[2]) + K[1]*K[1]);
    G[25] = det*(2.0*K[1]*K[4] + K[0]*K[3] + K[2]*K[5]);
    G[26] = det*(2.0*K[1]*K[7] + K[0]*K[6] + K[2]*K[8]);
    G[27] = K[1]*K[2]*det;
    G[28] = K[2]*K[4]*det;
    G[29] = K[2]*K[7]*det;
    G[30] = det*(0.5*(K[3]*K[3] + K[5]*K[5]) + K[4]*K[4]);
    G[31] = det*(2.0*K[4]*K[7] + K[3]*K[6] + K[5]*K[8]);
    G[32] = K[1]*K[5]*det;
    G[33] = K[4]*K[5]*det;
    G[34] = K[5]*K[7]*det;
    G[35] = det*(0.5*(K[6]*K[6] + K[8]*K[8]) + K[7]*K[7]);
    G[36] = K[1]*K[8]*det;
    G[37] = K[4]*K[8]*det;
    G[38] = K[7]*K[8]*det;
    G[39] = det*(0.5*(K[0]*K[0] + K[1]*K[1]) + K[2]*K[2]);
    G[40] = det*(2.0*K[2]*K[5] + K[0]*K[3] + K[1]*K[4]);
    G[41] = det*(2.0*K[2]*K[8] + K[0]*K[6] + K[1]*K[7]);
    G[42] = det*(0.5*(K[3]*K[3] + K[4]*K[4]) + K[5]*K[5]);
    G[43] = det*(2.0*K[5]*K[8] + K[3]*K[6] + K[4]*K[7]);
    G[44] = det*(0.5*(K[6]*K[6] + K[7]*K[7]) + K[8]*K[8]);
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 730
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F1 += FE1_C0_D001[ip][r]*w[0][nzc3[r]];
        F2 += FE1_C0_D001[ip][r]*w[0][nzc2[r]];
        F3 += FE1_C0_D001[ip][r]*w[0][nzc1[r]];
        F4 += FE1_C0_D001[ip][r]*w[0][nzc7[r]];
        F5 += FE1_C0_D001[ip][r]*w[0][nzc6[r]];
        F6 += FE1_C0_D001[ip][r]*w[0][nzc5[r]];
        F7 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F8 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F9 += FE1_C0_D001[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[1][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 101
      double I[1];
      // Number of operations: 101
      I[0] = W5[ip]*(F1*F1*G[0] + F2*(F1*G[1] + F2*G[9]) + F3*(F1*G[2] + F2*G[10] + F3*G[17]) + F4*(F1*G[3] + F2*G[11] + F3*G[18] + F4*G[24]) + F5*(F1*G[4] + F2*G[12] + F3*G[19] + F4*G[25] + F5*G[30]) + F6*(F1*G[5] + F2*G[13] + F3*G[20] + F4*G[26] + F5*G[31] + F6*G[35]) + F7*(F1*G[6] + F2*G[14] + F3*G[21] + F4*G[27] + F5*G[32] + F6*G[36] + F7*G[39]) + F8*(F1*G[7] + F2*G[15] + F3*G[22] + F4*G[28] + F5*G[33] + F6*G[37] + F7*G[40] + F8*G[42]) + F9*(F1*G[8] + F2*G[16] + F3*G[23] + F4*G[29] + F5*G[34] + F6*G[38] + F7*G[41] + F8*G[43] + F9*G[44]) - F0*det);
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    } // end loop over 'ip'
}


plas3d_cell_integral_28_otherwise::plas3d_cell_integral_28_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_28_otherwise::~plas3d_cell_integral_28_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_28_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true});
return enabled;
}

void plas3d_cell_integral_28_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 6
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    // Number of operations to compute geometry constants: 1.
    double G[1];
    G[0] = 2.0*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 120
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[1][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 15
      double I[1];
      // Number of operations: 15
      I[0] = W5[ip]*(G[0]*(w[0][ip + 15]*w[0][ip + 15] + w[0][ip + 20]*w[0][ip + 20] + w[0][ip + 25]*w[0][ip + 25]) + det*(w[0][ip + 10]*w[0][ip + 10] + w[0][ip + 5]*w[0][ip + 5] + w[0][ip]*w[0][ip] - F0));
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    } // end loop over 'ip'
}


plas3d_cell_integral_29_otherwise::plas3d_cell_integral_29_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_29_otherwise::~plas3d_cell_integral_29_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_29_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true});
return enabled;
}

void plas3d_cell_integral_29_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 3
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc3[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc7[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    // Number of operations to compute geometry constants: 19.
    double G[10];
    G[0] = -1922222.222222222*K[0]*det;
    G[1] = -1922222.222222222*K[3]*det;
    G[2] = -1922222.222222222*K[6]*det;
    G[3] = -1922222.222222222*K[1]*det;
    G[4] = -1922222.222222222*K[4]*det;
    G[5] = -1922222.222222222*K[7]*det;
    G[6] = -1922222.222222222*K[2]*det;
    G[7] = -1922222.222222222*K[5]*det;
    G[8] = -1922222.222222222*K[8]*det;
    G[9] = 1922222.222222222*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 345
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F1 += FE1_C0_D001[ip][r]*w[0][nzc3[r]];
        F2 += FE1_C0_D001[ip][r]*w[0][nzc2[r]];
        F3 += FE1_C0_D001[ip][r]*w[0][nzc1[r]];
        F4 += FE1_C0_D001[ip][r]*w[0][nzc7[r]];
        F5 += FE1_C0_D001[ip][r]*w[0][nzc6[r]];
        F6 += FE1_C0_D001[ip][r]*w[0][nzc5[r]];
        F7 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F8 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F9 += FE1_C0_D001[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[2][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 24
      double I[1];
      // Number of operations: 24
      I[0] = W5[ip]*(F1*G[0] + F2*G[1] + F3*G[2] + F4*G[3] + F5*G[4] + F6*G[5] + F7*G[6] + F8*G[7] + F9*G[8] + G[9]*(w[1][ip + 10] + w[1][ip + 5] + w[1][ip]) - F0*det);
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    } // end loop over 'ip'
}


plas3d_cell_integral_30_otherwise::plas3d_cell_integral_30_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_30_otherwise::~plas3d_cell_integral_30_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_30_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true, true, true});
return enabled;
}

void plas3d_cell_integral_30_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 8
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    static const double FE1_C0_D001[5][2] = \
    {{-1.0, 1},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999998, 1.0},
    {-0.9999999999999999, 1.0},
    {-0.9999999999999998, 1.0}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc3[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc5[2] = {4, 7};
    
    // Array of non-zero columns
    static const unsigned int nzc6[2] = {4, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc7[2] = {4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc9[2] = {8, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc10[2] = {8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc11[2] = {8, 9};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 8135
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 2; r++)
      {
        F1 += FE1_C0_D001[ip][r]*w[0][nzc3[r]];
        F2 += FE1_C0_D001[ip][r]*w[0][nzc2[r]];
        F3 += FE1_C0_D001[ip][r]*w[0][nzc1[r]];
        F4 += FE1_C0_D001[ip][r]*w[0][nzc7[r]];
        F5 += FE1_C0_D001[ip][r]*w[0][nzc6[r]];
        F6 += FE1_C0_D001[ip][r]*w[0][nzc5[r]];
        F7 += FE1_C0_D001[ip][r]*w[0][nzc11[r]];
        F8 += FE1_C0_D001[ip][r]*w[0][nzc10[r]];
        F9 += FE1_C0_D001[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[2][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 1582
      double I[1];
      // Number of operations: 1582
      I[0] = W5[ip]*det*(std::sqrt(1.5*((2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])))*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]))) + (2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])))*(2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]))) + (2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])))*(2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip])-0.3333333333333333*(2883333.333333333*(0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10]) + 2883333.333333333*(0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) - w[1][ip + 5]) + 2883333.333333333*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]) + 961111.1111111111*(0.5*(F1*K[0] + F1*K[0] + F2*K[3] + F2*K[3] + F3*K[6] + F3*K[6]) + 0.5*(F4*K[1] + F4*K[1] + F5*K[4] + F5*K[4] + F6*K[7] + F6*K[7]) + 0.5*(F7*K[2] + F7*K[2] + F8*K[5] + F8*K[5] + F9*K[8] + F9*K[8]) - w[1][ip + 10] - w[1][ip + 5] - w[1][ip]))) + 2883333.333333333*(0.5*(F1*K[1] + F2*K[4] + F3*K[7] + F4*K[0] + F5*K[3] + F6*K[6]) - w[1][ip + 15])*2883333.333333333*(0.5*(F1*K[1] + F2*K[4] + F3*K[7] + F4*K[0] + F5*K[3] + F6*K[6]) - w[1][ip + 15]) + 2883333.333333333*(0.5*(F1*K[1] + F2*K[4] + F3*K[7] + F4*K[0] + F5*K[3] + F6*K[6]) - w[1][ip + 15])*2883333.333333333*(0.5*(F1*K[1] + F2*K[4] + F3*K[7] + F4*K[0] + F5*K[3] + F6*K[6]) - w[1][ip + 15]) + 2883333.333333333*(0.5*(F1*K[2] + F2*K[5] + F3*K[8] + F7*K[0] + F8*K[3] + F9*K[6]) - w[1][ip + 20])*2883333.333333333*(0.5*(F1*K[2] + F2*K[5] + F3*K[8] + F7*K[0] + F8*K[3] + F9*K[6]) - w[1][ip + 20]) + 2883333.333333333*(0.5*(F1*K[2] + F2*K[5] + F3*K[8] + F7*K[0] + F8*K[3] + F9*K[6]) - w[1][ip + 20])*2883333.333333333*(0.5*(F1*K[2] + F2*K[5] + F3*K[8] + F7*K[0] + F8*K[3] + F9*K[6]) - w[1][ip + 20]) + 2883333.333333333*(0.5*(F4*K[2] + F5*K[5] + F6*K[8] + F7*K[1] + F8*K[4] + F9*K[7]) - w[1][ip + 25])*2883333.333333333*(0.5*(F4*K[2] + F5*K[5] + F6*K[8] + F7*K[1] + F8*K[4] + F9*K[7]) - w[1][ip + 25]) + 2883333.333333333*(0.5*(F4*K[2] + F5*K[5] + F6*K[8] + F7*K[1] + F8*K[4] + F9*K[7]) - w[1][ip + 25])*2883333.333333333*(0.5*(F4*K[2] + F5*K[5] + F6*K[8] + F7*K[1] + F8*K[4] + F9*K[7]) - w[1][ip + 25]))) - F0);
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    } // end loop over 'ip'
}


plas3d_cell_integral_31_otherwise::plas3d_cell_integral_31_otherwise() : ufc::cell_integral()
{

}

plas3d_cell_integral_31_otherwise::~plas3d_cell_integral_31_otherwise()
{

}

const std::vector<bool> & plas3d_cell_integral_31_otherwise::enabled_coefficients() const
{
static const std::vector<bool> enabled({true});
return enabled;
}

void plas3d_cell_integral_31_otherwise::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    // num_cells:         None
    // optimize:          True
    // precision:         16
    // quadrature_degree: 3
    // quadrature_rule:   'default'
    // representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    // estimated_polynomial_degree: 1
    // optimize:                    True
    // precision:                   16
    // quadrature_degree:           3
    // quadrature_rule:             'default'
    // representation:              'quadrature'
    // Compute Jacobian
    double J[9];
    compute_jacobian_tetrahedron_3d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[9];
    double detJ;
    compute_jacobian_inverse_tetrahedron_3d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius
    
    
    // Array of quadrature weights.
    static const double W5[5] = {-0.1333333333333333, 0.075, 0.075, 0.075, 0.075};
    // Quadrature points on the UFC reference element: (0.25, 0.25, 0.25), (0.5, 0.1666666666666666, 0.1666666666666666), (0.1666666666666666, 0.5, 0.1666666666666666), (0.1666666666666666, 0.1666666666666666, 0.5), (0.1666666666666666, 0.1666666666666666, 0.1666666666666666)
    
    // Values of basis functions at quadrature points.
    static const double FE0[5][4] = \
    {{0.2500000000000001, 0.25, 0.25, 0.25},
    {0.1666666666666668, 0.4999999999999999, 0.1666666666666667, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.5, 0.1666666666666667},
    {0.1666666666666668, 0.1666666666666666, 0.1666666666666667, 0.5},
    {0.5000000000000001, 0.1666666666666665, 0.1666666666666667, 0.1666666666666667}};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 55
    for (unsigned int ip = 0; ip < 5; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      
      // Total number of operations to compute function values = 8
      for (unsigned int r = 0; r < 4; r++)
      {
        F0 += FE0[ip][r]*w[0][r];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 2
      double I[1];
      // Number of operations: 2
      I[0] = F0*W5[ip]*det;
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    } // end loop over 'ip'
}


plas3d_form_0::plas3d_form_0() : ufc::form()
{
    // Do nothing
}

plas3d_form_0::~plas3d_form_0()
{
    // Do nothing
}

const char * plas3d_form_0::signature() const
{
    return "446a35487e835a875c5c340930951ac62639ecea8e216d7f0ea8ef9e43d44c49d7172aadee420a1c010657e77a836ce4e9ce9e2d5ad07b9ece32b1a39c5273b4";
}

std::size_t plas3d_form_0::rank() const
{
    return 1;
}

std::size_t plas3d_form_0::num_coefficients() const
{
    return 1;
}

std::size_t plas3d_form_0::original_coefficient_position(std::size_t i) const
{
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0};
    return position[i];
}

ufc::finite_element * plas3d_form_0::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_0::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_0::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_0::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_1();
    case 1:
        return new plas3d_finite_element_4();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_0::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_1();
    case 1:
        return new plas3d_dofmap_4();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_0::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_0::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_0::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_0::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_0::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_0::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_0::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_0::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_0::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_0::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_0::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_0::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_0::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_0::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_0::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_0::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_0::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_0::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_0::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_0::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_0::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_0::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_0::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_0::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_0::create_default_cell_integral() const
{
    return new plas3d_cell_integral_0_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_0::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_0::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_0::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_0::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_0::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_0::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_0::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_1::plas3d_form_1() : ufc::form()
{
    // Do nothing
}

plas3d_form_1::~plas3d_form_1()
{
    // Do nothing
}

const char * plas3d_form_1::signature() const
{
    return "7e428357cd480f295a6415cda05cc0d4d4241c5d4980e2b05869f6889bc79f792a476bbd5cc09e689328e05bcf8cab46f4ced880a5277e5b52a13b121f3d2710";
}

std::size_t plas3d_form_1::rank() const
{
    return 1;
}

std::size_t plas3d_form_1::num_coefficients() const
{
    return 0;
}

std::size_t plas3d_form_1::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * plas3d_form_1::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_1::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_1::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_1::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_1();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_1::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_1();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_1::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_1::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_1::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_1::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_1::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_1::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_1::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_1::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_1::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_1::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_1::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_1::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_1::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_1::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_1::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_1::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_1::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_1::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_1::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_1::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_1::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_1::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_1::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_1::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_1::create_default_cell_integral() const
{
    return new plas3d_cell_integral_1_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_1::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_1::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_1::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_1::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_1::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_1::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_1::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_2::plas3d_form_2() : ufc::form()
{
    // Do nothing
}

plas3d_form_2::~plas3d_form_2()
{
    // Do nothing
}

const char * plas3d_form_2::signature() const
{
    return "8995ac97c9006bfbf2465154e9303a322790fa7574dd131825d66b36581960e7ed39755b90d90b35f67fdac6d8e28ff1f9e7027f39464107f4285be910a4f7ea";
}

std::size_t plas3d_form_2::rank() const
{
    return 2;
}

std::size_t plas3d_form_2::num_coefficients() const
{
    return 1;
}

std::size_t plas3d_form_2::original_coefficient_position(std::size_t i) const
{
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0};
    return position[i];
}

ufc::finite_element * plas3d_form_2::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_2::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_2::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_2::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_4();
    case 1:
        return new plas3d_finite_element_4();
    case 2:
        return new plas3d_finite_element_2();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_2::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_4();
    case 1:
        return new plas3d_dofmap_4();
    case 2:
        return new plas3d_dofmap_2();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_2::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_2::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_2::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_2::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_2::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_2::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_2::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_2::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_2::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_2::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_2::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_2::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_2::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_2::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_2::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_2::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_2::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_2::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_2::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_2::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_2::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_2::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_2::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_2::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_2::create_default_cell_integral() const
{
    return new plas3d_cell_integral_2_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_2::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_2::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_2::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_2::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_2::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_2::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_2::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_3::plas3d_form_3() : ufc::form()
{
    // Do nothing
}

plas3d_form_3::~plas3d_form_3()
{
    // Do nothing
}

const char * plas3d_form_3::signature() const
{
    return "40e87d81315d0692768fbaba58996634b70b665aa172ca69f02a81e0b8852a0f3f881eda6c3aedcb78f412a03a8e785cf32af268364f02c297b4f036b12ebff9";
}

std::size_t plas3d_form_3::rank() const
{
    return 1;
}

std::size_t plas3d_form_3::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_3::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_3::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_3::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_3::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_3::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_4();
    case 1:
        return new plas3d_finite_element_4();
    case 2:
        return new plas3d_finite_element_1();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_3::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_4();
    case 1:
        return new plas3d_dofmap_4();
    case 2:
        return new plas3d_dofmap_1();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_3::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_3::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_3::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_3::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_3::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_3::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_3::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_3::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_3::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_3::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_3::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_3::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_3::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_3::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_3::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_3::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_3::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_3::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_3::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_3::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_3::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_3::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_3::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_3::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_3::create_default_cell_integral() const
{
    return new plas3d_cell_integral_3_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_3::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_3::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_3::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_3::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_3::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_3::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_3::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_4::plas3d_form_4() : ufc::form()
{
    // Do nothing
}

plas3d_form_4::~plas3d_form_4()
{
    // Do nothing
}

const char * plas3d_form_4::signature() const
{
    return "0df54b3513f57762438951718681802bc4d2be220760333128a13784caa4018f65abc16eee6ca1e38c4bf9ad6429ca530bf45ac0ea4402e541d546eaaedfab0d";
}

std::size_t plas3d_form_4::rank() const
{
    return 2;
}

std::size_t plas3d_form_4::num_coefficients() const
{
    return 0;
}

std::size_t plas3d_form_4::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * plas3d_form_4::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_4::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_4::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_4::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_7();
    case 1:
        return new plas3d_finite_element_7();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_4::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_7();
    case 1:
        return new plas3d_dofmap_7();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_4::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_4::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_4::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_4::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_4::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_4::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_4::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_4::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_4::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_4::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_4::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_4::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_4::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_4::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_4::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_4::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_4::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_4::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_4::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_4::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_4::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_4::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_4::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_4::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_4::create_default_cell_integral() const
{
    return new plas3d_cell_integral_4_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_4::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_4::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_4::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_4::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_4::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_4::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_4::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_5::plas3d_form_5() : ufc::form()
{
    // Do nothing
}

plas3d_form_5::~plas3d_form_5()
{
    // Do nothing
}

const char * plas3d_form_5::signature() const
{
    return "4964a78c5c419695b3ed7f9425d5e4272c012d1ed5c1b95b9773b00524d404d81ab56efb0bd9443fab7e8fc3a1569fa93d75ef62e2e4e03b4f167d04bf150820";
}

std::size_t plas3d_form_5::rank() const
{
    return 1;
}

std::size_t plas3d_form_5::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_5::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_5::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_5::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_5::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_5::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_7();
    case 1:
        return new plas3d_finite_element_6();
    case 2:
        return new plas3d_finite_element_7();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_5::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_7();
    case 1:
        return new plas3d_dofmap_6();
    case 2:
        return new plas3d_dofmap_7();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_5::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_5::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_5::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_5::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_5::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_5::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_5::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_5::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_5::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_5::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_5::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_5::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_5::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_5::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_5::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_5::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_5::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_5::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_5::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_5::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_5::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_5::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_5::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_5::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_5::create_default_cell_integral() const
{
    return new plas3d_cell_integral_5_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_5::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_5::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_5::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_5::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_5::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_5::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_5::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_6::plas3d_form_6() : ufc::form()
{
    // Do nothing
}

plas3d_form_6::~plas3d_form_6()
{
    // Do nothing
}

const char * plas3d_form_6::signature() const
{
    return "0df54b3513f57762438951718681802bc4d2be220760333128a13784caa4018f65abc16eee6ca1e38c4bf9ad6429ca530bf45ac0ea4402e541d546eaaedfab0d";
}

std::size_t plas3d_form_6::rank() const
{
    return 2;
}

std::size_t plas3d_form_6::num_coefficients() const
{
    return 0;
}

std::size_t plas3d_form_6::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * plas3d_form_6::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_6::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_6::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_6::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_7();
    case 1:
        return new plas3d_finite_element_7();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_6::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_7();
    case 1:
        return new plas3d_dofmap_7();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_6::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_6::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_6::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_6::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_6::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_6::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_6::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_6::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_6::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_6::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_6::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_6::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_6::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_6::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_6::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_6::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_6::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_6::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_6::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_6::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_6::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_6::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_6::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_6::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_6::create_default_cell_integral() const
{
    return new plas3d_cell_integral_6_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_6::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_6::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_6::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_6::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_6::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_6::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_6::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_7::plas3d_form_7() : ufc::form()
{
    // Do nothing
}

plas3d_form_7::~plas3d_form_7()
{
    // Do nothing
}

const char * plas3d_form_7::signature() const
{
    return "00c32770459452fcbbd0c88071e2964afcd67dea0f513f7f12b64d1ea1e405b04f0dcb536a3891078ec964d52d5808e41f73d1112a994fdf5f0d481dae88f973";
}

std::size_t plas3d_form_7::rank() const
{
    return 1;
}

std::size_t plas3d_form_7::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_7::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_7::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_7::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_7::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_7::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_7();
    case 1:
        return new plas3d_finite_element_7();
    case 2:
        return new plas3d_finite_element_1();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_7::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_7();
    case 1:
        return new plas3d_dofmap_7();
    case 2:
        return new plas3d_dofmap_1();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_7::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_7::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_7::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_7::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_7::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_7::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_7::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_7::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_7::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_7::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_7::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_7::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_7::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_7::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_7::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_7::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_7::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_7::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_7::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_7::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_7::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_7::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_7::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_7::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_7::create_default_cell_integral() const
{
    return new plas3d_cell_integral_7_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_7::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_7::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_7::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_7::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_7::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_7::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_7::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_8::plas3d_form_8() : ufc::form()
{
    // Do nothing
}

plas3d_form_8::~plas3d_form_8()
{
    // Do nothing
}

const char * plas3d_form_8::signature() const
{
    return "0df54b3513f57762438951718681802bc4d2be220760333128a13784caa4018f65abc16eee6ca1e38c4bf9ad6429ca530bf45ac0ea4402e541d546eaaedfab0d";
}

std::size_t plas3d_form_8::rank() const
{
    return 2;
}

std::size_t plas3d_form_8::num_coefficients() const
{
    return 0;
}

std::size_t plas3d_form_8::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * plas3d_form_8::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_8::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_8::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_8::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_7();
    case 1:
        return new plas3d_finite_element_7();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_8::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_7();
    case 1:
        return new plas3d_dofmap_7();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_8::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_8::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_8::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_8::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_8::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_8::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_8::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_8::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_8::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_8::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_8::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_8::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_8::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_8::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_8::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_8::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_8::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_8::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_8::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_8::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_8::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_8::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_8::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_8::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_8::create_default_cell_integral() const
{
    return new plas3d_cell_integral_8_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_8::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_8::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_8::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_8::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_8::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_8::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_8::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_9::plas3d_form_9() : ufc::form()
{
    // Do nothing
}

plas3d_form_9::~plas3d_form_9()
{
    // Do nothing
}

const char * plas3d_form_9::signature() const
{
    return "18b49da2b7f7d14954ce34e16ab84d2e44b291e9af3d03773250ad0535a48460fd565ecb457fc2e1c7fe22627e9da98f56c41b2947ab0986c5a9e7e42a870eb4";
}

std::size_t plas3d_form_9::rank() const
{
    return 1;
}

std::size_t plas3d_form_9::num_coefficients() const
{
    return 3;
}

std::size_t plas3d_form_9::original_coefficient_position(std::size_t i) const
{
    if (i >= 3)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2};
    return position[i];
}

ufc::finite_element * plas3d_form_9::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_9::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_9::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_9::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_7();
    case 1:
        return new plas3d_finite_element_7();
    case 2:
        return new plas3d_finite_element_6();
    case 3:
        return new plas3d_finite_element_1();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_9::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_7();
    case 1:
        return new plas3d_dofmap_7();
    case 2:
        return new plas3d_dofmap_6();
    case 3:
        return new plas3d_dofmap_1();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_9::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_9::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_9::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_9::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_9::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_9::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_9::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_9::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_9::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_9::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_9::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_9::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_9::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_9::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_9::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_9::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_9::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_9::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_9::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_9::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_9::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_9::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_9::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_9::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_9::create_default_cell_integral() const
{
    return new plas3d_cell_integral_9_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_9::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_9::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_9::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_9::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_9::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_9::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_9::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_10::plas3d_form_10() : ufc::form()
{
    // Do nothing
}

plas3d_form_10::~plas3d_form_10()
{
    // Do nothing
}

const char * plas3d_form_10::signature() const
{
    return "60cc4f4e9623abce1c1f27a46d6b99bcf1e29731583b27042840fb890baf118b422edffccf5e65646061ca0e728b41e6620a32d9fdff29093939eaeb0f1a26f2";
}

std::size_t plas3d_form_10::rank() const
{
    return 2;
}

std::size_t plas3d_form_10::num_coefficients() const
{
    return 0;
}

std::size_t plas3d_form_10::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * plas3d_form_10::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_10::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_10::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_10::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_10::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_10::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_10::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_10::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_10::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_10::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_10::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_10::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_10::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_10::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_10::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_10::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_10::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_10::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_10::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_10::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_10::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_10::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_10::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_10::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_10::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_10::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_10::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_10::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_10::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_10::create_default_cell_integral() const
{
    return new plas3d_cell_integral_10_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_10::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_10::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_10::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_10::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_10::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_10::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_10::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_11::plas3d_form_11() : ufc::form()
{
    // Do nothing
}

plas3d_form_11::~plas3d_form_11()
{
    // Do nothing
}

const char * plas3d_form_11::signature() const
{
    return "6194205a8784fb0917e8ed809fcbdcc69a5754789447c57c6fffec78104c61ea2f5195757bfe1c84b7343ea56ab38794c65ebe6cd01bb36727d2ee486d112d2d";
}

std::size_t plas3d_form_11::rank() const
{
    return 1;
}

std::size_t plas3d_form_11::num_coefficients() const
{
    return 3;
}

std::size_t plas3d_form_11::original_coefficient_position(std::size_t i) const
{
    if (i >= 3)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2};
    return position[i];
}

ufc::finite_element * plas3d_form_11::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_11::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_11::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_11::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_6();
    case 2:
        return new plas3d_finite_element_1();
    case 3:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_11::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_6();
    case 2:
        return new plas3d_dofmap_1();
    case 3:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_11::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_11::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_11::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_11::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_11::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_11::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_11::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_11::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_11::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_11::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_11::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_11::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_11::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_11::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_11::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_11::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_11::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_11::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_11::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_11::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_11::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_11::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_11::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_11::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_11::create_default_cell_integral() const
{
    return new plas3d_cell_integral_11_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_11::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_11::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_11::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_11::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_11::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_11::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_11::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_12::plas3d_form_12() : ufc::form()
{
    // Do nothing
}

plas3d_form_12::~plas3d_form_12()
{
    // Do nothing
}

const char * plas3d_form_12::signature() const
{
    return "60cc4f4e9623abce1c1f27a46d6b99bcf1e29731583b27042840fb890baf118b422edffccf5e65646061ca0e728b41e6620a32d9fdff29093939eaeb0f1a26f2";
}

std::size_t plas3d_form_12::rank() const
{
    return 2;
}

std::size_t plas3d_form_12::num_coefficients() const
{
    return 0;
}

std::size_t plas3d_form_12::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * plas3d_form_12::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_12::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_12::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_12::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_12::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_12::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_12::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_12::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_12::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_12::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_12::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_12::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_12::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_12::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_12::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_12::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_12::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_12::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_12::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_12::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_12::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_12::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_12::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_12::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_12::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_12::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_12::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_12::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_12::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_12::create_default_cell_integral() const
{
    return new plas3d_cell_integral_12_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_12::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_12::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_12::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_12::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_12::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_12::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_12::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_13::plas3d_form_13() : ufc::form()
{
    // Do nothing
}

plas3d_form_13::~plas3d_form_13()
{
    // Do nothing
}

const char * plas3d_form_13::signature() const
{
    return "5d2414bfbfeb28d6a4119dd69f73a500e3ea1fe6013cf0c78682355ab74c23def0e43e2f374d080cfe3d27d56a07185fe06653ffbb4048edd479544b35c358bb";
}

std::size_t plas3d_form_13::rank() const
{
    return 1;
}

std::size_t plas3d_form_13::num_coefficients() const
{
    return 3;
}

std::size_t plas3d_form_13::original_coefficient_position(std::size_t i) const
{
    if (i >= 3)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2};
    return position[i];
}

ufc::finite_element * plas3d_form_13::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_13::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_13::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_13::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_6();
    case 2:
        return new plas3d_finite_element_1();
    case 3:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_13::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_6();
    case 2:
        return new plas3d_dofmap_1();
    case 3:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_13::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_13::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_13::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_13::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_13::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_13::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_13::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_13::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_13::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_13::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_13::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_13::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_13::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_13::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_13::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_13::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_13::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_13::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_13::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_13::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_13::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_13::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_13::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_13::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_13::create_default_cell_integral() const
{
    return new plas3d_cell_integral_13_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_13::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_13::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_13::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_13::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_13::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_13::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_13::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_14::plas3d_form_14() : ufc::form()
{
    // Do nothing
}

plas3d_form_14::~plas3d_form_14()
{
    // Do nothing
}

const char * plas3d_form_14::signature() const
{
    return "60cc4f4e9623abce1c1f27a46d6b99bcf1e29731583b27042840fb890baf118b422edffccf5e65646061ca0e728b41e6620a32d9fdff29093939eaeb0f1a26f2";
}

std::size_t plas3d_form_14::rank() const
{
    return 2;
}

std::size_t plas3d_form_14::num_coefficients() const
{
    return 0;
}

std::size_t plas3d_form_14::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * plas3d_form_14::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_14::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_14::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_14::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_14::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_14::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_14::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_14::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_14::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_14::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_14::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_14::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_14::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_14::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_14::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_14::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_14::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_14::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_14::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_14::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_14::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_14::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_14::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_14::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_14::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_14::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_14::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_14::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_14::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_14::create_default_cell_integral() const
{
    return new plas3d_cell_integral_14_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_14::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_14::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_14::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_14::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_14::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_14::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_14::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_15::plas3d_form_15() : ufc::form()
{
    // Do nothing
}

plas3d_form_15::~plas3d_form_15()
{
    // Do nothing
}

const char * plas3d_form_15::signature() const
{
    return "fa8c3f64c5277754e14c625712b22ed54b4f5a59afde055a9f3826a24a0e5dc240152d398f0d5a27c70a4307b63a03daedeaa37c21f061fafabbbf22d9f7d663";
}

std::size_t plas3d_form_15::rank() const
{
    return 1;
}

std::size_t plas3d_form_15::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_15::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_15::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_15::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_15::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_15::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_6();
    case 2:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_15::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_6();
    case 2:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_15::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_15::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_15::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_15::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_15::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_15::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_15::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_15::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_15::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_15::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_15::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_15::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_15::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_15::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_15::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_15::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_15::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_15::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_15::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_15::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_15::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_15::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_15::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_15::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_15::create_default_cell_integral() const
{
    return new plas3d_cell_integral_15_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_15::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_15::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_15::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_15::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_15::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_15::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_15::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_16::plas3d_form_16() : ufc::form()
{
    // Do nothing
}

plas3d_form_16::~plas3d_form_16()
{
    // Do nothing
}

const char * plas3d_form_16::signature() const
{
    return "60cc4f4e9623abce1c1f27a46d6b99bcf1e29731583b27042840fb890baf118b422edffccf5e65646061ca0e728b41e6620a32d9fdff29093939eaeb0f1a26f2";
}

std::size_t plas3d_form_16::rank() const
{
    return 2;
}

std::size_t plas3d_form_16::num_coefficients() const
{
    return 0;
}

std::size_t plas3d_form_16::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * plas3d_form_16::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_16::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_16::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_16::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_16::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_16::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_16::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_16::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_16::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_16::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_16::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_16::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_16::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_16::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_16::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_16::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_16::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_16::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_16::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_16::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_16::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_16::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_16::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_16::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_16::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_16::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_16::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_16::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_16::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_16::create_default_cell_integral() const
{
    return new plas3d_cell_integral_16_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_16::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_16::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_16::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_16::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_16::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_16::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_16::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_17::plas3d_form_17() : ufc::form()
{
    // Do nothing
}

plas3d_form_17::~plas3d_form_17()
{
    // Do nothing
}

const char * plas3d_form_17::signature() const
{
    return "8361332b19cc6e41df4f04b2b95055dd18d2ff736e899fe3a4f7354de88521020d862dc3a79e8adecd840219816e673847b6a9be334a85144652c26f8cd0323e";
}

std::size_t plas3d_form_17::rank() const
{
    return 1;
}

std::size_t plas3d_form_17::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_17::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_17::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_17::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_17::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_17::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_6();
    case 2:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_17::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_6();
    case 2:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_17::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_17::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_17::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_17::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_17::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_17::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_17::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_17::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_17::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_17::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_17::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_17::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_17::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_17::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_17::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_17::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_17::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_17::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_17::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_17::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_17::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_17::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_17::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_17::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_17::create_default_cell_integral() const
{
    return new plas3d_cell_integral_17_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_17::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_17::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_17::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_17::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_17::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_17::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_17::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_18::plas3d_form_18() : ufc::form()
{
    // Do nothing
}

plas3d_form_18::~plas3d_form_18()
{
    // Do nothing
}

const char * plas3d_form_18::signature() const
{
    return "60cc4f4e9623abce1c1f27a46d6b99bcf1e29731583b27042840fb890baf118b422edffccf5e65646061ca0e728b41e6620a32d9fdff29093939eaeb0f1a26f2";
}

std::size_t plas3d_form_18::rank() const
{
    return 2;
}

std::size_t plas3d_form_18::num_coefficients() const
{
    return 0;
}

std::size_t plas3d_form_18::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * plas3d_form_18::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_18::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_18::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_18::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_18::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_18::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_18::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_18::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_18::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_18::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_18::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_18::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_18::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_18::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_18::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_18::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_18::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_18::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_18::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_18::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_18::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_18::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_18::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_18::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_18::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_18::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_18::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_18::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_18::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_18::create_default_cell_integral() const
{
    return new plas3d_cell_integral_18_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_18::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_18::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_18::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_18::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_18::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_18::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_18::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_19::plas3d_form_19() : ufc::form()
{
    // Do nothing
}

plas3d_form_19::~plas3d_form_19()
{
    // Do nothing
}

const char * plas3d_form_19::signature() const
{
    return "d5d84ba477ecb6a8c76771f6951241269ceceb656db13e9d04333c33ff08e86279a650f14f5d6bcc658fe0be76f7ee644177d9b47d56c1f7c2d56445ab4748e5";
}

std::size_t plas3d_form_19::rank() const
{
    return 1;
}

std::size_t plas3d_form_19::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_19::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_19::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_19::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_19::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_19::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_1();
    case 2:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_19::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_1();
    case 2:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_19::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_19::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_19::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_19::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_19::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_19::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_19::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_19::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_19::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_19::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_19::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_19::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_19::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_19::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_19::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_19::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_19::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_19::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_19::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_19::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_19::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_19::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_19::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_19::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_19::create_default_cell_integral() const
{
    return new plas3d_cell_integral_19_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_19::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_19::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_19::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_19::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_19::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_19::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_19::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_20::plas3d_form_20() : ufc::form()
{
    // Do nothing
}

plas3d_form_20::~plas3d_form_20()
{
    // Do nothing
}

const char * plas3d_form_20::signature() const
{
    return "60cc4f4e9623abce1c1f27a46d6b99bcf1e29731583b27042840fb890baf118b422edffccf5e65646061ca0e728b41e6620a32d9fdff29093939eaeb0f1a26f2";
}

std::size_t plas3d_form_20::rank() const
{
    return 2;
}

std::size_t plas3d_form_20::num_coefficients() const
{
    return 0;
}

std::size_t plas3d_form_20::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * plas3d_form_20::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_20::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_20::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_20::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_20::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_20::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_20::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_20::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_20::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_20::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_20::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_20::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_20::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_20::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_20::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_20::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_20::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_20::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_20::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_20::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_20::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_20::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_20::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_20::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_20::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_20::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_20::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_20::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_20::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_20::create_default_cell_integral() const
{
    return new plas3d_cell_integral_20_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_20::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_20::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_20::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_20::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_20::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_20::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_20::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_21::plas3d_form_21() : ufc::form()
{
    // Do nothing
}

plas3d_form_21::~plas3d_form_21()
{
    // Do nothing
}

const char * plas3d_form_21::signature() const
{
    return "ba9ecdda39032f5960d61f06d6b01682fe270b83a8cc934a37d0155fe611e0357e7c14477fdb3be07dc64ff2295de2a9b3d49b4ce8dcd67dfb5ba2435a9de4e6";
}

std::size_t plas3d_form_21::rank() const
{
    return 1;
}

std::size_t plas3d_form_21::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_21::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_21::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_21::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_21::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_21::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_6();
    case 2:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_21::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_6();
    case 2:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_21::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_21::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_21::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_21::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_21::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_21::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_21::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_21::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_21::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_21::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_21::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_21::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_21::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_21::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_21::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_21::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_21::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_21::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_21::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_21::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_21::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_21::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_21::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_21::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_21::create_default_cell_integral() const
{
    return new plas3d_cell_integral_21_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_21::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_21::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_21::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_21::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_21::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_21::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_21::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_22::plas3d_form_22() : ufc::form()
{
    // Do nothing
}

plas3d_form_22::~plas3d_form_22()
{
    // Do nothing
}

const char * plas3d_form_22::signature() const
{
    return "60cc4f4e9623abce1c1f27a46d6b99bcf1e29731583b27042840fb890baf118b422edffccf5e65646061ca0e728b41e6620a32d9fdff29093939eaeb0f1a26f2";
}

std::size_t plas3d_form_22::rank() const
{
    return 2;
}

std::size_t plas3d_form_22::num_coefficients() const
{
    return 0;
}

std::size_t plas3d_form_22::original_coefficient_position(std::size_t i) const
{
    throw std::runtime_error("Invalid original coefficient index.");
    return i;
}

ufc::finite_element * plas3d_form_22::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_22::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_22::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_22::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_22::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_22::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_22::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_22::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_22::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_22::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_22::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_22::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_22::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_22::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_22::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_22::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_22::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_22::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_22::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_22::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_22::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_22::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_22::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_22::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_22::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_22::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_22::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_22::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_22::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_22::create_default_cell_integral() const
{
    return new plas3d_cell_integral_22_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_22::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_22::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_22::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_22::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_22::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_22::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_22::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_23::plas3d_form_23() : ufc::form()
{
    // Do nothing
}

plas3d_form_23::~plas3d_form_23()
{
    // Do nothing
}

const char * plas3d_form_23::signature() const
{
    return "2856b6e10f1e299e3487bbb234ef7de4edfd114c9f39345e2eae431b42c54d9c13263521db6d0e917f1f7b1433f303066abc5b8453a7c12e3116d1b5bd620ed0";
}

std::size_t plas3d_form_23::rank() const
{
    return 1;
}

std::size_t plas3d_form_23::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_23::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_23::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_23::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_23::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_23::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    case 1:
        return new plas3d_finite_element_1();
    case 2:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_23::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    case 1:
        return new plas3d_dofmap_1();
    case 2:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_23::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_23::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_23::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_23::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_23::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_23::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_23::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_23::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_23::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_23::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_23::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_23::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_23::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_23::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_23::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_23::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_23::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_23::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_23::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_23::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_23::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_23::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_23::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_23::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_23::create_default_cell_integral() const
{
    return new plas3d_cell_integral_23_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_23::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_23::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_23::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_23::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_23::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_23::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_23::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_24::plas3d_form_24() : ufc::form()
{
    // Do nothing
}

plas3d_form_24::~plas3d_form_24()
{
    // Do nothing
}

const char * plas3d_form_24::signature() const
{
    return "9a4dae3f07b4acc2541637d3013ef8f80aac4fc8d7a6251be0e94b376dd6d455d80adba8526cdfb48183ca64d912d82db25575ab8ccd069e88bb69370233a477";
}

std::size_t plas3d_form_24::rank() const
{
    return 0;
}

std::size_t plas3d_form_24::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_24::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_24::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_24::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_24::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_24::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_6();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_24::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_6();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_24::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_24::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_24::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_24::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_24::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_24::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_24::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_24::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_24::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_24::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_24::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_24::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_24::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_24::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_24::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_24::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_24::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_24::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_24::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_24::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_24::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_24::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_24::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_24::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_24::create_default_cell_integral() const
{
    return new plas3d_cell_integral_24_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_24::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_24::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_24::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_24::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_24::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_24::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_24::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_25::plas3d_form_25() : ufc::form()
{
    // Do nothing
}

plas3d_form_25::~plas3d_form_25()
{
    // Do nothing
}

const char * plas3d_form_25::signature() const
{
    return "c2c91898595e7880467ac20528116ba6a7a507d0b20d8623f18199007b880b2bd0d3eb36bfb242f16a1fe31eb906ae4bb3d97d5c47c29e5b1a0ffeff09026f0f";
}

std::size_t plas3d_form_25::rank() const
{
    return 0;
}

std::size_t plas3d_form_25::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_25::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_25::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_25::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_25::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_25::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_1();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_25::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_1();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_25::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_25::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_25::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_25::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_25::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_25::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_25::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_25::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_25::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_25::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_25::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_25::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_25::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_25::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_25::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_25::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_25::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_25::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_25::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_25::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_25::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_25::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_25::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_25::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_25::create_default_cell_integral() const
{
    return new plas3d_cell_integral_25_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_25::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_25::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_25::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_25::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_25::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_25::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_25::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_26::plas3d_form_26() : ufc::form()
{
    // Do nothing
}

plas3d_form_26::~plas3d_form_26()
{
    // Do nothing
}

const char * plas3d_form_26::signature() const
{
    return "1693f5fff4897060543864a941205f70caa15de126622470e387dc87f34f56a5d1233b1b5715792ce933eaaca55d0a59438a4335d666adfe95092c63a72e487e";
}

std::size_t plas3d_form_26::rank() const
{
    return 0;
}

std::size_t plas3d_form_26::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_26::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_26::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_26::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_26::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_26::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_6();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_26::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_6();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_26::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_26::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_26::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_26::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_26::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_26::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_26::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_26::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_26::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_26::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_26::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_26::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_26::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_26::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_26::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_26::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_26::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_26::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_26::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_26::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_26::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_26::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_26::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_26::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_26::create_default_cell_integral() const
{
    return new plas3d_cell_integral_26_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_26::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_26::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_26::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_26::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_26::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_26::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_26::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_27::plas3d_form_27() : ufc::form()
{
    // Do nothing
}

plas3d_form_27::~plas3d_form_27()
{
    // Do nothing
}

const char * plas3d_form_27::signature() const
{
    return "03646d6c9010cbfce260795a311b6a4d3e5905d926030c35aa649fc8eee26b1dd485a8c9fda08a51b95f77ef0d831179cb1acac8f8efe6880d4624c61305ecfe";
}

std::size_t plas3d_form_27::rank() const
{
    return 0;
}

std::size_t plas3d_form_27::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_27::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_27::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_27::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_27::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_27::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_6();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_27::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_6();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_27::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_27::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_27::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_27::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_27::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_27::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_27::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_27::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_27::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_27::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_27::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_27::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_27::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_27::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_27::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_27::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_27::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_27::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_27::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_27::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_27::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_27::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_27::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_27::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_27::create_default_cell_integral() const
{
    return new plas3d_cell_integral_27_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_27::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_27::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_27::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_27::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_27::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_27::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_27::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_28::plas3d_form_28() : ufc::form()
{
    // Do nothing
}

plas3d_form_28::~plas3d_form_28()
{
    // Do nothing
}

const char * plas3d_form_28::signature() const
{
    return "79e795cf9565143f2f818ec93432c8f910ddfa5c6e6a0f66b06e6879e25be31908be88f0265c4f9a2b38bb733715a29aab902dac27905c21d50bf33a0564bc71";
}

std::size_t plas3d_form_28::rank() const
{
    return 0;
}

std::size_t plas3d_form_28::num_coefficients() const
{
    return 2;
}

std::size_t plas3d_form_28::original_coefficient_position(std::size_t i) const
{
    if (i >= 2)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1};
    return position[i];
}

ufc::finite_element * plas3d_form_28::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_28::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_28::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_28::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_1();
    case 1:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_28::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_1();
    case 1:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_28::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_28::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_28::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_28::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_28::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_28::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_28::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_28::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_28::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_28::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_28::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_28::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_28::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_28::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_28::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_28::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_28::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_28::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_28::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_28::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_28::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_28::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_28::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_28::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_28::create_default_cell_integral() const
{
    return new plas3d_cell_integral_28_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_28::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_28::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_28::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_28::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_28::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_28::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_28::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_29::plas3d_form_29() : ufc::form()
{
    // Do nothing
}

plas3d_form_29::~plas3d_form_29()
{
    // Do nothing
}

const char * plas3d_form_29::signature() const
{
    return "8fc7634b9ca7d1ac64d66568dd1d1f18800856117b015100ceae2ab57609da2ba951cc2c275ac4081663c33c213c8b4adf42def66ac46d554296c2e36eb550b4";
}

std::size_t plas3d_form_29::rank() const
{
    return 0;
}

std::size_t plas3d_form_29::num_coefficients() const
{
    return 3;
}

std::size_t plas3d_form_29::original_coefficient_position(std::size_t i) const
{
    if (i >= 3)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2};
    return position[i];
}

ufc::finite_element * plas3d_form_29::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_29::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_29::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_29::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_6();
    case 1:
        return new plas3d_finite_element_1();
    case 2:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_29::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_6();
    case 1:
        return new plas3d_dofmap_1();
    case 2:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_29::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_29::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_29::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_29::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_29::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_29::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_29::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_29::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_29::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_29::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_29::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_29::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_29::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_29::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_29::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_29::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_29::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_29::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_29::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_29::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_29::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_29::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_29::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_29::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_29::create_default_cell_integral() const
{
    return new plas3d_cell_integral_29_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_29::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_29::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_29::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_29::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_29::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_29::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_29::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_30::plas3d_form_30() : ufc::form()
{
    // Do nothing
}

plas3d_form_30::~plas3d_form_30()
{
    // Do nothing
}

const char * plas3d_form_30::signature() const
{
    return "7f6e8eb445ba09d6c8a20df6aff7eda39ba108b33dba3868d85318c0ee69aa01e3d85bcfdb4164c1e52d0afaea32cad9e9360be109decc850340296ab827ab6b";
}

std::size_t plas3d_form_30::rank() const
{
    return 0;
}

std::size_t plas3d_form_30::num_coefficients() const
{
    return 3;
}

std::size_t plas3d_form_30::original_coefficient_position(std::size_t i) const
{
    if (i >= 3)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0, 1, 2};
    return position[i];
}

ufc::finite_element * plas3d_form_30::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_30::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_30::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_30::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_6();
    case 1:
        return new plas3d_finite_element_1();
    case 2:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_30::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_6();
    case 1:
        return new plas3d_dofmap_1();
    case 2:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_30::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_30::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_30::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_30::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_30::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_30::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_30::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_30::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_30::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_30::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_30::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_30::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_30::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_30::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_30::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_30::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_30::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_30::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_30::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_30::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_30::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_30::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_30::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_30::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_30::create_default_cell_integral() const
{
    return new plas3d_cell_integral_30_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_30::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_30::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_30::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_30::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_30::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_30::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_30::create_default_overlap_integral() const
{
    return nullptr;
}


plas3d_form_31::plas3d_form_31() : ufc::form()
{
    // Do nothing
}

plas3d_form_31::~plas3d_form_31()
{
    // Do nothing
}

const char * plas3d_form_31::signature() const
{
    return "a9283246d06dcacaab8e0a357cd41eca66a2340bb04505906b2b50c80127e4028bae50e0146182ce64cd493e5826d37d5635efb980f10aae932bab84d682614c";
}

std::size_t plas3d_form_31::rank() const
{
    return 0;
}

std::size_t plas3d_form_31::num_coefficients() const
{
    return 1;
}

std::size_t plas3d_form_31::original_coefficient_position(std::size_t i) const
{
    if (i >= 1)
    {
        throw std::runtime_error("Invalid original coefficient index.");
    }
    static const std::vector<std::size_t> position = {0};
    return position[i];
}

ufc::finite_element * plas3d_form_31::create_coordinate_finite_element() const
{
    return new plas3d_finite_element_6();
}

ufc::dofmap * plas3d_form_31::create_coordinate_dofmap() const
{
    return new plas3d_dofmap_6();
}

ufc::coordinate_mapping * plas3d_form_31::create_coordinate_mapping() const
{
    return new plas3d_coordinate_mapping_6();
}

ufc::finite_element * plas3d_form_31::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_finite_element_5();
    default:
        return nullptr;
    }
}

ufc::dofmap * plas3d_form_31::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
        return new plas3d_dofmap_5();
    default:
        return nullptr;
    }
}

std::size_t plas3d_form_31::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_31::max_exterior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_31::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_31::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_31::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_31::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_31::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t plas3d_form_31::max_overlap_subdomain_id() const
{
    return 0;
}

bool plas3d_form_31::has_cell_integrals() const
{
    return true;
}

bool plas3d_form_31::has_exterior_facet_integrals() const
{
    return false;
}

bool plas3d_form_31::has_interior_facet_integrals() const
{
    return false;
}

bool plas3d_form_31::has_vertex_integrals() const
{
    return false;
}

bool plas3d_form_31::has_custom_integrals() const
{
    return false;
}

bool plas3d_form_31::has_cutcell_integrals() const
{
    return false;
}

bool plas3d_form_31::has_interface_integrals() const
{
    return false;
}

bool plas3d_form_31::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * plas3d_form_31::create_cell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::exterior_facet_integral * plas3d_form_31::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_31::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_31::create_vertex_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_31::create_custom_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_31::create_cutcell_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_31::create_interface_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_31::create_overlap_integral(std::size_t subdomain_id) const
{
    return nullptr;
}

ufc::cell_integral * plas3d_form_31::create_default_cell_integral() const
{
    return new plas3d_cell_integral_31_otherwise();
}

ufc::exterior_facet_integral * plas3d_form_31::create_default_exterior_facet_integral() const
{
    return nullptr;
}

ufc::interior_facet_integral * plas3d_form_31::create_default_interior_facet_integral() const
{
    return nullptr;
}

ufc::vertex_integral * plas3d_form_31::create_default_vertex_integral() const
{
    return nullptr;
}

ufc::custom_integral * plas3d_form_31::create_default_custom_integral() const
{
    return nullptr;
}

ufc::cutcell_integral * plas3d_form_31::create_default_cutcell_integral() const
{
    return nullptr;
}

ufc::interface_integral * plas3d_form_31::create_default_interface_integral() const
{
    return nullptr;
}

ufc::overlap_integral * plas3d_form_31::create_default_overlap_integral() const
{
    return nullptr;
}

